//! Tenor code generator -- TypeScript types, schemas, and client bindings
//! from interchange JSON bundles.
//!
//! Implementation: Phase 16.

pub mod bundle;
pub mod typescript;
pub mod typescript_client;
pub mod typescript_schemas;

use std::path::PathBuf;

pub use bundle::CodegenError;

/// Configuration for TypeScript code generation.
pub struct TypeScriptConfig {
    /// Output directory for generated files.
    pub out_dir: PathBuf,
    /// SDK import path (default: @tenor/sdk).
    pub sdk_import: String,
}

/// Generate a barrel `index.ts` that re-exports all public symbols.
fn emit_index(bundle: &bundle::CodegenBundle) -> String {
    let pascal_bundle_id = typescript::to_pascal_case(&bundle.id);
    let mut out = String::new();

    out.push_str("// Auto-generated by tenor generate. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');
    out.push_str("export * from './types.ts';\n");
    out.push_str("export * from './schemas.ts';\n");
    out.push_str(&format!(
        "export {{ {}Client }} from './client.ts';\n",
        pascal_bundle_id
    ));

    out
}

/// Generate TypeScript types, schemas, client wrapper, and barrel export
/// from an interchange JSON bundle.
///
/// Creates `{out_dir}/{kebab-bundle-id}/types.ts`, `schemas.ts`,
/// `client.ts`, and `index.ts`.
pub fn generate_typescript(
    interchange_json: &serde_json::Value,
    config: &TypeScriptConfig,
) -> Result<PathBuf, CodegenError> {
    // Deserialize the bundle
    let bundle = bundle::CodegenBundle::from_interchange(interchange_json)?;

    // Generate output directory path
    let contract_dir_name = typescript::to_kebab_case(&bundle.id);
    let output_dir = config.out_dir.join(&contract_dir_name);

    // Create output directory
    std::fs::create_dir_all(&output_dir).map_err(|e| {
        CodegenError::IoError(format!(
            "failed to create directory '{}': {}",
            output_dir.display(),
            e
        ))
    })?;

    // Emit types.ts
    let types_content = typescript::emit_types(&bundle);
    let types_path = output_dir.join("types.ts");
    std::fs::write(&types_path, &types_content).map_err(|e| {
        CodegenError::IoError(format!("failed to write '{}': {}", types_path.display(), e))
    })?;

    // Emit schemas.ts
    let schemas_content = typescript_schemas::emit_schemas(&bundle, &config.sdk_import);
    let schemas_path = output_dir.join("schemas.ts");
    std::fs::write(&schemas_path, &schemas_content).map_err(|e| {
        CodegenError::IoError(format!(
            "failed to write '{}': {}",
            schemas_path.display(),
            e
        ))
    })?;

    // Emit client.ts
    let client_content = typescript_client::emit_client(&bundle, &config.sdk_import);
    let client_path = output_dir.join("client.ts");
    std::fs::write(&client_path, &client_content).map_err(|e| {
        CodegenError::IoError(format!(
            "failed to write '{}': {}",
            client_path.display(),
            e
        ))
    })?;

    // Emit index.ts
    let index_content = emit_index(&bundle);
    let index_path = output_dir.join("index.ts");
    std::fs::write(&index_path, &index_content).map_err(|e| {
        CodegenError::IoError(format!("failed to write '{}': {}", index_path.display(), e))
    })?;

    Ok(output_dir)
}
