//! TypeScript `schemas.ts` Zod emitter.
//!
//! Generates Zod validators for fact input types and branded type
//! constructor helpers from a CodegenBundle.

use crate::bundle::{CodegenBundle, TypeInfo};
use crate::typescript::to_camel_case;

/// Emit the `schemas.ts` content for a contract bundle.
pub fn emit_schemas(bundle: &CodegenBundle, _sdk_import: &str) -> String {
    let mut out = String::new();

    // Header
    out.push_str("// Auto-generated by tenor generate. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');

    // Imports
    out.push_str("import { z } from 'zod';\n");
    out.push_str(
        "import type { TenorMoney, TenorDecimal, TenorDate, TenorDateTime, TenorDuration } from './types.ts';\n",
    );
    out.push('\n');

    // Branded type base schemas (used internally)
    emit_base_schemas(&mut out);

    // Facts schema
    if !bundle.facts.is_empty() {
        emit_facts_schema(&mut out, bundle);
    }

    // Branded type constructor helpers
    emit_constructor_helpers(&mut out);

    out
}

/// Emit base Zod schemas for branded types.
fn emit_base_schemas(out: &mut String) {
    out.push_str("const moneySchema = z.string().refine(\n");
    out.push_str("  (v) => /^-?\\d+(\\.\\d+)?$/.test(v),\n");
    out.push_str("  { message: 'Invalid money format' },\n");
    out.push_str(");\n\n");

    out.push_str("const decimalSchema = z.string().refine(\n");
    out.push_str("  (v) => /^-?\\d+(\\.\\d+)?$/.test(v),\n");
    out.push_str("  { message: 'Invalid decimal format' },\n");
    out.push_str(");\n\n");

    out.push_str("const dateSchema = z.string().regex(\n");
    out.push_str("  /^\\d{4}-\\d{2}-\\d{2}$/,\n");
    out.push_str("  { message: 'Invalid date format (expected YYYY-MM-DD)' },\n");
    out.push_str(");\n\n");

    out.push_str("const dateTimeSchema = z.string().datetime();\n\n");

    out.push_str("const durationSchema = z.string();\n\n");
}

/// Emit the facts Zod schema object.
fn emit_facts_schema(out: &mut String, bundle: &CodegenBundle) {
    let camel_bundle_id = to_camel_case(&bundle.id);
    out.push_str(&format!(
        "export const {}FactsSchema = z.object({{\n",
        camel_bundle_id
    ));
    for fact in &bundle.facts {
        let camel_id = to_camel_case(&fact.id);
        let zod_schema = type_info_to_zod(&fact.type_info);
        out.push_str(&format!("  {}: {},\n", camel_id, zod_schema));
    }
    out.push_str("});\n\n");
}

/// Emit branded type constructor helper functions.
fn emit_constructor_helpers(out: &mut String) {
    out.push_str(
        "export function money(value: string): TenorMoney {\n\
         \x20 return moneySchema.parse(value) as TenorMoney;\n\
         }\n\n",
    );

    out.push_str(
        "export function decimal(value: string): TenorDecimal {\n\
         \x20 return decimalSchema.parse(value) as TenorDecimal;\n\
         }\n\n",
    );

    out.push_str(
        "export function tenorDate(value: string): TenorDate {\n\
         \x20 return dateSchema.parse(value) as TenorDate;\n\
         }\n\n",
    );

    out.push_str(
        "export function tenorDateTime(value: string): TenorDateTime {\n\
         \x20 return dateTimeSchema.parse(value) as TenorDateTime;\n\
         }\n\n",
    );

    out.push_str(
        "export function duration(value: string): TenorDuration {\n\
         \x20 return durationSchema.parse(value) as TenorDuration;\n\
         }\n",
    );
}

/// Map a TypeInfo to a Zod schema expression string.
fn type_info_to_zod(t: &TypeInfo) -> String {
    match t {
        TypeInfo::Bool => "z.boolean()".to_string(),
        TypeInfo::Int { min, max } => {
            let mut s = "z.number().int()".to_string();
            if let Some(min_val) = min {
                s.push_str(&format!(".min({})", min_val));
            }
            if let Some(max_val) = max {
                s.push_str(&format!(".max({})", max_val));
            }
            s
        }
        TypeInfo::Decimal { .. } => "decimalSchema".to_string(),
        TypeInfo::Money { .. } => "moneySchema".to_string(),
        TypeInfo::Text { max_length } => {
            let mut s = "z.string()".to_string();
            if let Some(max) = max_length {
                s.push_str(&format!(".max({})", max));
            }
            s
        }
        TypeInfo::Date => "dateSchema".to_string(),
        TypeInfo::DateTime => "dateTimeSchema".to_string(),
        TypeInfo::Duration { .. } => "durationSchema".to_string(),
        TypeInfo::Enum { values } => {
            let vals: Vec<String> = values.iter().map(|v| format!("'{}'", v)).collect();
            format!("z.enum([{}])", vals.join(", "))
        }
        TypeInfo::List { element_type, max } => {
            let elem = type_info_to_zod(element_type);
            let mut s = format!("z.array({})", elem);
            if let Some(max_val) = max {
                s.push_str(&format!(".max({})", max_val));
            }
            s
        }
        TypeInfo::Record { fields } => {
            if fields.is_empty() {
                "z.object({})".to_string()
            } else {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(k, v)| format!("    {}: {}", k, type_info_to_zod(v)))
                    .collect();
                format!("z.object({{\n{},\n  }})", field_strs.join(",\n"))
            }
        }
        TypeInfo::TaggedUnion { variants } => {
            if variants.is_empty() {
                "z.never()".to_string()
            } else {
                let variant_schemas: Vec<String> = variants
                    .iter()
                    .map(|(tag, payload_type)| {
                        format!(
                            "z.object({{ tag: z.literal('{}'), payload: {} }})",
                            tag,
                            type_info_to_zod(payload_type)
                        )
                    })
                    .collect();
                if variant_schemas.len() == 1 {
                    variant_schemas[0].clone()
                } else {
                    format!("z.union([{}])", variant_schemas.join(", "))
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bundle::*;

    #[test]
    fn test_emit_schemas_basic() {
        let bundle = CodegenBundle {
            id: "operation_basic".to_string(),
            facts: vec![CodegenFact {
                id: "is_active".to_string(),
                type_info: TypeInfo::Bool,
            }],
            entities: vec![],
            operations: vec![],
            rules: vec![],
            flows: vec![],
            personas: vec![],
        };

        let output = emit_schemas(&bundle, "@tenor/sdk");
        assert!(output.contains("// Auto-generated by tenor generate. Do not edit."));
        assert!(output.contains("// Contract: operation_basic"));
        assert!(output.contains("import { z } from 'zod';"));
        assert!(output.contains("import type { TenorMoney, TenorDecimal, TenorDate, TenorDateTime, TenorDuration } from './types.ts';"));
        assert!(output.contains("export const operationBasicFactsSchema = z.object({"));
        assert!(output.contains("  isActive: z.boolean(),"));
        assert!(output.contains("export function money(value: string): TenorMoney {"));
        assert!(output.contains("export function decimal(value: string): TenorDecimal {"));
        assert!(output.contains("export function tenorDate(value: string): TenorDate {"));
        assert!(output.contains("export function tenorDateTime(value: string): TenorDateTime {"));
        assert!(output.contains("export function duration(value: string): TenorDuration {"));
    }

    #[test]
    fn test_type_info_to_zod() {
        assert_eq!(type_info_to_zod(&TypeInfo::Bool), "z.boolean()");
        assert_eq!(
            type_info_to_zod(&TypeInfo::Int {
                min: Some(0),
                max: Some(100)
            }),
            "z.number().int().min(0).max(100)"
        );
        assert_eq!(
            type_info_to_zod(&TypeInfo::Text {
                max_length: Some(256)
            }),
            "z.string().max(256)"
        );
        assert_eq!(
            type_info_to_zod(&TypeInfo::Enum {
                values: vec!["pending".to_string(), "confirmed".to_string()]
            }),
            "z.enum(['pending', 'confirmed'])"
        );
        assert_eq!(
            type_info_to_zod(&TypeInfo::Money {
                currency: Some("USD".to_string())
            }),
            "moneySchema"
        );
        assert_eq!(type_info_to_zod(&TypeInfo::Date), "dateSchema");
        assert_eq!(type_info_to_zod(&TypeInfo::DateTime), "dateTimeSchema");
    }

    #[test]
    fn test_zod_list_with_max() {
        let t = TypeInfo::List {
            element_type: Box::new(TypeInfo::Bool),
            max: Some(50),
        };
        assert_eq!(type_info_to_zod(&t), "z.array(z.boolean()).max(50)");
    }
}
