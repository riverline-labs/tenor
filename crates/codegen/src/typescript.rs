//! TypeScript `types.ts` emitter.
//!
//! Generates branded types, fact interfaces, entity state unions,
//! operation input types, and verdict type unions from a CodegenBundle.

use crate::bundle::{CodegenBundle, TypeInfo};

/// Emit the `types.ts` content for a contract bundle.
pub fn emit_types(bundle: &CodegenBundle) -> String {
    let mut out = String::new();

    // Header
    out.push_str("// Auto-generated by tenor generate. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');

    // Branded types (always emitted)
    emit_branded_types(&mut out);

    // Entity state unions
    for entity in &bundle.entities {
        emit_entity_state_union(&mut out, entity);
    }

    // Facts interface
    if !bundle.facts.is_empty() {
        emit_facts_interface(&mut out, bundle);
    }

    // Operation input interfaces
    for op in &bundle.operations {
        emit_operation_input(&mut out, op, bundle);
    }

    // Verdict type union
    let verdict_types: Vec<&str> = bundle
        .rules
        .iter()
        .map(|r| r.verdict_type.as_str())
        .collect::<std::collections::BTreeSet<_>>()
        .into_iter()
        .collect();
    if !verdict_types.is_empty() {
        emit_verdict_type_union(&mut out, bundle, &verdict_types);
    }

    out
}

/// Emit branded type aliases for Tenor special types.
fn emit_branded_types(out: &mut String) {
    out.push_str(
        "export type TenorMoney = string & { readonly __brand: 'TenorMoney' };\n\
         export type TenorDecimal = string & { readonly __brand: 'TenorDecimal' };\n\
         export type TenorDate = string & { readonly __brand: 'TenorDate' };\n\
         export type TenorDateTime = string & { readonly __brand: 'TenorDateTime' };\n\
         export type TenorDuration = string & { readonly __brand: 'TenorDuration' };\n",
    );
    out.push('\n');
}

/// Emit a state union type for an entity.
fn emit_entity_state_union(out: &mut String, entity: &crate::bundle::CodegenEntity) {
    let pascal_id = to_pascal_case(&entity.id);
    let states: Vec<String> = entity.states.iter().map(|s| format!("'{}'", s)).collect();
    out.push_str(&format!(
        "export type {}State = {};\n\n",
        pascal_id,
        states.join(" | ")
    ));
}

/// Emit the facts interface containing all facts.
fn emit_facts_interface(out: &mut String, bundle: &CodegenBundle) {
    let pascal_bundle_id = to_pascal_case(&bundle.id);
    out.push_str(&format!("export interface {}Facts {{\n", pascal_bundle_id));
    for fact in &bundle.facts {
        let camel_id = to_camel_case(&fact.id);
        let ts_type = type_info_to_ts(&fact.type_info);
        out.push_str(&format!("  {}: {};\n", camel_id, ts_type));
    }
    out.push_str("}\n\n");
}

/// Emit an operation input interface.
fn emit_operation_input(
    out: &mut String,
    op: &crate::bundle::CodegenOperation,
    bundle: &CodegenBundle,
) {
    let pascal_op_id = to_pascal_case(&op.id);
    let pascal_bundle_id = to_pascal_case(&bundle.id);
    let persona_union: Vec<String> = op
        .allowed_personas
        .iter()
        .map(|p| format!("'{}'", p))
        .collect();
    out.push_str(&format!("export interface {}Input {{\n", pascal_op_id));
    out.push_str(&format!("  facts: Partial<{}Facts>;\n", pascal_bundle_id));
    out.push_str(&format!("  persona: {};\n", persona_union.join(" | ")));
    out.push_str("}\n\n");
}

/// Emit a verdict type union.
fn emit_verdict_type_union(out: &mut String, bundle: &CodegenBundle, verdict_types: &[&str]) {
    let pascal_bundle_id = to_pascal_case(&bundle.id);
    let union: Vec<String> = verdict_types.iter().map(|vt| format!("'{}'", vt)).collect();
    out.push_str(&format!(
        "export type {}VerdictType = {};\n",
        pascal_bundle_id,
        union.join(" | ")
    ));
}

/// Map a TypeInfo to a TypeScript type string.
fn type_info_to_ts(t: &TypeInfo) -> String {
    match t {
        TypeInfo::Bool => "boolean".to_string(),
        TypeInfo::Int { .. } => "number".to_string(),
        TypeInfo::Decimal { .. } => "TenorDecimal".to_string(),
        TypeInfo::Money { .. } => "TenorMoney".to_string(),
        TypeInfo::Text { .. } => "string".to_string(),
        TypeInfo::Date => "TenorDate".to_string(),
        TypeInfo::DateTime => "TenorDateTime".to_string(),
        TypeInfo::Duration { .. } => "TenorDuration".to_string(),
        TypeInfo::Enum { values } => {
            let union: Vec<String> = values.iter().map(|v| format!("'{}'", v)).collect();
            union.join(" | ")
        }
        TypeInfo::List { element_type, .. } => {
            format!("Array<{}>", type_info_to_ts(element_type))
        }
        TypeInfo::Record { fields } => {
            if fields.is_empty() {
                "Record<string, never>".to_string()
            } else {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(k, v)| format!("{}: {}", k, type_info_to_ts(v)))
                    .collect();
                format!("{{ {} }}", field_strs.join("; "))
            }
        }
        TypeInfo::TaggedUnion { variants } => {
            if variants.is_empty() {
                "never".to_string()
            } else {
                let variant_strs: Vec<String> = variants
                    .iter()
                    .map(|(tag, payload_type)| {
                        format!(
                            "{{ tag: '{}'; payload: {} }}",
                            tag,
                            type_info_to_ts(payload_type)
                        )
                    })
                    .collect();
                variant_strs.join(" | ")
            }
        }
    }
}

/// Convert a snake_case or kebab-case or PascalCase identifier to PascalCase.
pub fn to_pascal_case(s: &str) -> String {
    // If the string has no separators, it's likely already PascalCase -- just
    // ensure the first letter is uppercase and preserve the rest.
    if !s.contains('_') && !s.contains('-') {
        let mut chars = s.chars();
        return match chars.next() {
            None => String::new(),
            Some(c) => {
                let upper = c.to_uppercase().to_string();
                upper + chars.as_str()
            }
        };
    }
    // Split on separators and capitalize each segment
    s.split(['_', '-'])
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => {
                    let upper = c.to_uppercase().to_string();
                    upper + &chars.as_str().to_lowercase()
                }
            }
        })
        .collect()
}

/// Convert a snake_case or kebab-case identifier to camelCase.
pub fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars = pascal.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => {
            let lower = c.to_lowercase().to_string();
            lower + chars.as_str()
        }
    }
}

/// Convert a snake_case or PascalCase identifier to kebab-case.
pub fn to_kebab_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c == '_' {
            result.push('-');
        } else if c.is_uppercase() && i > 0 {
            // Insert hyphen before uppercase letters (for PascalCase conversion)
            let prev = s.chars().nth(i - 1);
            if let Some(p) = prev {
                if p != '_' && p != '-' {
                    result.push('-');
                }
            }
            result.push(c.to_lowercase().next().unwrap_or(c));
        } else {
            result.push(c.to_lowercase().next().unwrap_or(c));
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bundle::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("operation_basic"), "OperationBasic");
        assert_eq!(to_pascal_case("integration_escrow"), "IntegrationEscrow");
        assert_eq!(to_pascal_case("approve_order"), "ApproveOrder");
        assert_eq!(to_pascal_case("Order"), "Order");
        assert_eq!(to_pascal_case("kebab-case"), "KebabCase");
        // PascalCase identifiers (entity IDs) must be preserved
        assert_eq!(to_pascal_case("DeliveryRecord"), "DeliveryRecord");
        assert_eq!(to_pascal_case("EscrowAccount"), "EscrowAccount");
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("is_active"), "isActive");
        assert_eq!(to_camel_case("escrow_amount"), "escrowAmount");
        assert_eq!(
            to_camel_case("buyer_requested_refund"),
            "buyerRequestedRefund"
        );
    }

    #[test]
    fn test_to_kebab_case() {
        assert_eq!(to_kebab_case("operation_basic"), "operation-basic");
        assert_eq!(to_kebab_case("integration_escrow"), "integration-escrow");
    }

    #[test]
    fn test_emit_types_basic() {
        let bundle = CodegenBundle {
            id: "operation_basic".to_string(),
            facts: vec![CodegenFact {
                id: "is_active".to_string(),
                type_info: TypeInfo::Bool,
            }],
            entities: vec![CodegenEntity {
                id: "Order".to_string(),
                states: vec![
                    "draft".to_string(),
                    "submitted".to_string(),
                    "approved".to_string(),
                    "rejected".to_string(),
                ],
                transitions: vec![
                    ("draft".to_string(), "submitted".to_string()),
                    ("submitted".to_string(), "approved".to_string()),
                    ("submitted".to_string(), "rejected".to_string()),
                ],
            }],
            operations: vec![CodegenOperation {
                id: "approve_order".to_string(),
                allowed_personas: vec!["reviewer".to_string(), "admin".to_string()],
            }],
            rules: vec![CodegenRule {
                id: "account_active".to_string(),
                verdict_type: "account_active".to_string(),
            }],
            flows: vec![],
            personas: vec![],
        };

        let output = emit_types(&bundle);
        assert!(output.contains("// Auto-generated by tenor generate. Do not edit."));
        assert!(output.contains("// Contract: operation_basic"));
        assert!(output
            .contains("export type TenorMoney = string & { readonly __brand: 'TenorMoney' };"));
        assert!(output
            .contains("export type OrderState = 'draft' | 'submitted' | 'approved' | 'rejected';"));
        assert!(output.contains("export interface OperationBasicFacts {"));
        assert!(output.contains("  isActive: boolean;"));
        assert!(output.contains("export interface ApproveOrderInput {"));
        assert!(output.contains("  persona: 'reviewer' | 'admin';"));
        assert!(output.contains("export type OperationBasicVerdictType = 'account_active';"));
    }

    #[test]
    fn test_type_info_to_ts() {
        assert_eq!(type_info_to_ts(&TypeInfo::Bool), "boolean");
        assert_eq!(
            type_info_to_ts(&TypeInfo::Int {
                min: None,
                max: None
            }),
            "number"
        );
        assert_eq!(
            type_info_to_ts(&TypeInfo::Decimal {
                precision: None,
                scale: None
            }),
            "TenorDecimal"
        );
        assert_eq!(
            type_info_to_ts(&TypeInfo::Money {
                currency: Some("USD".to_string())
            }),
            "TenorMoney"
        );
        assert_eq!(
            type_info_to_ts(&TypeInfo::Text { max_length: None }),
            "string"
        );
        assert_eq!(type_info_to_ts(&TypeInfo::Date), "TenorDate");
        assert_eq!(type_info_to_ts(&TypeInfo::DateTime), "TenorDateTime");
        assert_eq!(
            type_info_to_ts(&TypeInfo::Duration {
                unit: None,
                min: None,
                max: None
            }),
            "TenorDuration"
        );
        assert_eq!(
            type_info_to_ts(&TypeInfo::Enum {
                values: vec!["a".to_string(), "b".to_string()]
            }),
            "'a' | 'b'"
        );
        assert_eq!(
            type_info_to_ts(&TypeInfo::List {
                element_type: Box::new(TypeInfo::Bool),
                max: None
            }),
            "Array<boolean>"
        );
    }
}
