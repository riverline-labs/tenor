//! TypeScript `client.ts` emitter.
//!
//! Generates a typed wrapper class around the TenorClient SDK,
//! with operation-specific methods that delegate to the generic invoke.

use crate::bundle::CodegenBundle;
use crate::typescript::{to_camel_case, to_pascal_case};

/// Emit the `client.ts` content for a contract bundle.
pub fn emit_client(bundle: &CodegenBundle, sdk_import: &str) -> String {
    let mut out = String::new();
    let pascal_bundle_id = to_pascal_case(&bundle.id);

    // Header
    out.push_str("// Auto-generated by tenor generate. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');

    // Imports
    out.push_str(&format!(
        "import type {{ TenorClient, EvalResult, FlowEvalResult }} from '{}';\n",
        sdk_import
    ));
    out.push_str(&format!(
        "import type {{ {}Facts }} from './types.ts';\n",
        pascal_bundle_id
    ));
    out.push('\n');

    // Class
    out.push_str(&format!("export class {}Client {{\n", pascal_bundle_id));

    // Private fields
    out.push_str("  private readonly client: TenorClient;\n");
    out.push_str(&format!(
        "  private readonly contractId = '{}';\n",
        bundle.id
    ));
    out.push('\n');

    // Constructor
    out.push_str("  constructor(client: TenorClient) {\n");
    out.push_str("    this.client = client;\n");
    out.push_str("  }\n");
    out.push('\n');

    // Generic invoke
    out.push_str(&format!(
        "  async invoke(facts: Partial<{}Facts>, options?: {{ flow_id?: string; persona?: string }}): Promise<EvalResult | FlowEvalResult> {{\n",
        pascal_bundle_id
    ));
    out.push_str("    return this.client.invoke(this.contractId, facts, options);\n");
    out.push_str("  }\n");

    // Operation-specific methods
    for op in &bundle.operations {
        out.push('\n');
        let camel_op_id = to_camel_case(&op.id);

        if op.allowed_personas.len() == 1 {
            // Single persona -- hardcode it
            let persona = &op.allowed_personas[0];
            out.push_str(&format!(
                "  async {}(facts: Partial<{}Facts>): Promise<EvalResult | FlowEvalResult> {{\n",
                camel_op_id, pascal_bundle_id
            ));
            out.push_str(&format!(
                "    return this.client.invoke(this.contractId, facts, {{ persona: '{}' }});\n",
                persona
            ));
            out.push_str("  }\n");
        } else {
            // Multiple personas -- accept persona as union type parameter
            let persona_union: Vec<String> = op
                .allowed_personas
                .iter()
                .map(|p| format!("'{}'", p))
                .collect();
            let union_str = persona_union.join(" | ");
            out.push_str(&format!(
                "  async {}(facts: Partial<{}Facts>, persona: {}): Promise<EvalResult | FlowEvalResult> {{\n",
                camel_op_id, pascal_bundle_id, union_str
            ));
            out.push_str("    return this.client.invoke(this.contractId, facts, { persona });\n");
            out.push_str("  }\n");
        }
    }

    // explain method
    out.push('\n');
    out.push_str("  async explain(): Promise<{ summary: string; verbose: string }> {\n");
    out.push_str("    return this.client.explain(this.contractId);\n");
    out.push_str("  }\n");

    // getOperations method
    out.push('\n');
    out.push_str("  async getOperations() {\n");
    out.push_str("    return this.client.getOperations(this.contractId);\n");
    out.push_str("  }\n");

    // Close class
    out.push_str("}\n");

    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bundle::*;

    #[test]
    fn test_emit_client_basic() {
        let bundle = CodegenBundle {
            id: "operation_basic".to_string(),
            facts: vec![CodegenFact {
                id: "is_active".to_string(),
                type_info: TypeInfo::Bool,
            }],
            entities: vec![],
            operations: vec![
                CodegenOperation {
                    id: "submit_order".to_string(),
                    allowed_personas: vec!["buyer".to_string()],
                },
                CodegenOperation {
                    id: "approve_order".to_string(),
                    allowed_personas: vec!["reviewer".to_string(), "admin".to_string()],
                },
            ],
            rules: vec![],
            flows: vec![],
            personas: vec![],
        };

        let output = emit_client(&bundle, "@tenor/sdk");

        // Header
        assert!(output.contains("// Auto-generated by tenor generate. Do not edit."));
        assert!(output.contains("// Contract: operation_basic"));

        // Imports
        assert!(output.contains(
            "import type { TenorClient, EvalResult, FlowEvalResult } from '@tenor/sdk';"
        ));
        assert!(output.contains("import type { OperationBasicFacts } from './types.ts';"));

        // Class
        assert!(output.contains("export class OperationBasicClient {"));
        assert!(output.contains("private readonly client: TenorClient;"));
        assert!(output.contains("private readonly contractId = 'operation_basic';"));

        // Constructor (composition)
        assert!(output.contains("constructor(client: TenorClient)"));
        assert!(output.contains("this.client = client;"));

        // Generic invoke
        assert!(output.contains("async invoke(facts: Partial<OperationBasicFacts>"));

        // Single-persona operation (hardcoded)
        assert!(output.contains("async submitOrder(facts: Partial<OperationBasicFacts>): Promise<EvalResult | FlowEvalResult>"));
        assert!(output.contains("persona: 'buyer'"));

        // Multi-persona operation (union)
        assert!(output.contains(
            "async approveOrder(facts: Partial<OperationBasicFacts>, persona: 'reviewer' | 'admin')"
        ));

        // Utility methods
        assert!(output.contains("async explain(): Promise<{ summary: string; verbose: string }>"));
        assert!(output.contains("async getOperations()"));
    }

    #[test]
    fn test_emit_client_no_operations() {
        let bundle = CodegenBundle {
            id: "simple_contract".to_string(),
            facts: vec![],
            entities: vec![],
            operations: vec![],
            rules: vec![],
            flows: vec![],
            personas: vec![],
        };

        let output = emit_client(&bundle, "@tenor/sdk");
        assert!(output.contains("export class SimpleContractClient {"));
        assert!(output.contains("async invoke("));
        assert!(output.contains("async explain()"));
        assert!(output.contains("async getOperations()"));
        // No operation-specific methods
        assert!(!output.contains("submitOrder"));
    }
}
