//! Adapter scaffolding generation.
//!
//! Produces:
//! - Adapter configuration TOML template
//! - Test file validating each adapter's return type
//! - Mapping documentation for human review

use std::collections::BTreeMap;
use std::path::{Path, PathBuf};

use super::introspect::ExternalSchema;
use super::matching::FactMapping;
use super::StructuredFact;
use tenor_interchange::SourceConstruct;

/// Generate scaffolding files in the output directory.
pub fn generate_scaffolding(
    sources: &[SourceConstruct],
    facts: &[StructuredFact],
    mappings: &[FactMapping],
    schemas: &BTreeMap<String, ExternalSchema>,
    output_dir: &Path,
) -> Result<Vec<PathBuf>, String> {
    std::fs::create_dir_all(output_dir)
        .map_err(|e| format!("could not create output directory: {}", e))?;

    let mut files = Vec::new();

    // 1. Generate adapter config TOML
    let config_path = output_dir.join("tenor-adapters.toml");
    let config_content = generate_config_toml(sources);
    std::fs::write(&config_path, &config_content)
        .map_err(|e| format!("could not write config: {}", e))?;
    files.push(config_path);

    // 2. Generate test file
    let test_path = output_dir.join("adapter_tests.rs");
    let test_content = generate_test_file(sources, facts, mappings);
    std::fs::write(&test_path, &test_content)
        .map_err(|e| format!("could not write tests: {}", e))?;
    files.push(test_path);

    // 3. Generate mapping documentation
    let doc_path = output_dir.join("MAPPINGS.md");
    let doc_content = generate_mapping_docs(sources, facts, mappings, schemas);
    std::fs::write(&doc_path, &doc_content).map_err(|e| format!("could not write docs: {}", e))?;
    files.push(doc_path);

    Ok(files)
}

/// Generate a TOML configuration template for adapter setup.
fn generate_config_toml(sources: &[SourceConstruct]) -> String {
    let mut out = String::new();
    out.push_str("# Tenor Adapter Configuration\n");
    out.push_str("# Generated by `tenor connect`\n");
    out.push_str("#\n");
    out.push_str("# Fill in connection details for each source.\n");
    out.push_str("# Credentials should come from environment variables,\n");
    out.push_str("# not from this file (see comments below).\n\n");

    for source in sources {
        out.push_str(&format!("[source.{}]\n", source.id));
        out.push_str(&format!("protocol = \"{}\"\n", source.protocol));

        if let Some(desc) = &source.description {
            out.push_str(&format!("# {}\n", desc));
        }

        match source.protocol.as_str() {
            "http" => {
                let base_url = source
                    .fields
                    .get("base_url")
                    .map(|s| s.as_str())
                    .unwrap_or("https://TODO");
                out.push_str(&format!("base_url = \"{}\"\n", base_url));
                out.push_str("# auth_token: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_AUTH_TOKEN env var\n");
                if let Some(schema_ref) = source.fields.get("schema_ref") {
                    out.push_str(&format!("schema_ref = \"{}\"\n", schema_ref));
                }
            }
            "database" => {
                let dialect = source
                    .fields
                    .get("dialect")
                    .map(|s| s.as_str())
                    .unwrap_or("postgres");
                out.push_str(&format!("dialect = \"{}\"\n", dialect));
                out.push_str("# connection_string: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_CONNECTION_STRING env var\n");
            }
            "graphql" => {
                let endpoint = source
                    .fields
                    .get("endpoint")
                    .map(|s| s.as_str())
                    .unwrap_or("https://TODO/graphql");
                out.push_str(&format!("endpoint = \"{}\"\n", endpoint));
                out.push_str("# auth_token: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_AUTH_TOKEN env var\n");
            }
            "grpc" => {
                let endpoint = source
                    .fields
                    .get("endpoint")
                    .map(|s| s.as_str())
                    .unwrap_or("localhost:50051");
                out.push_str(&format!("endpoint = \"{}\"\n", endpoint));
            }
            "static" => {
                out.push_str("# Static values: set TENOR_STATIC_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_<PATH> env vars\n");
            }
            "manual" => {
                out.push_str("# Manual input: values provided at runtime\n");
            }
            _ => {
                out.push_str("# Extension protocol — configure as needed\n");
                for (k, v) in &source.fields {
                    if k != "description" {
                        out.push_str(&format!("{} = \"{}\"\n", k, v));
                    }
                }
            }
        }

        out.push('\n');
    }

    out
}

/// Generate a Rust test file that validates adapter return types.
///
/// Produces one test per fact with type-specific assertions based on
/// the declared `fact_type`. Each test includes a placeholder value
/// and real assertions that verify type compatibility.
fn generate_test_file(
    sources: &[SourceConstruct],
    facts: &[StructuredFact],
    mappings: &[FactMapping],
) -> String {
    let mut out = String::new();
    out.push_str("//! Adapter validation tests\n");
    out.push_str("//! Generated by `tenor connect`\n");
    out.push_str("//!\n");
    out.push_str("//! These tests verify that each adapter returns values\n");
    out.push_str("//! compatible with the declared Fact types.\n\n");

    // Build a lookup of source_id -> SourceConstruct for comment generation
    let source_map: BTreeMap<&str, &SourceConstruct> =
        sources.iter().map(|s| (s.id.as_str(), s)).collect();

    // Build a lookup of fact_id -> FactMapping for endpoint info
    let mapping_map: BTreeMap<&str, &FactMapping> =
        mappings.iter().map(|m| (m.fact_id.as_str(), m)).collect();

    for fact in facts {
        let base_type = fact
            .fact_type
            .get("base")
            .and_then(|b| b.as_str())
            .unwrap_or("Unknown");

        let type_label = format_type_label(&fact.fact_type, base_type);

        // Doc comment: fact name and type
        out.push_str(&format!(
            "/// Test for fact '{}' ({})\n",
            fact.id, type_label
        ));

        // Doc comment: source info
        if let Some(source) = source_map.get(fact.source_id.as_str()) {
            out.push_str(&format!(
                "/// Source: {} ({}) at path {}\n",
                source.id, source.protocol, fact.path
            ));
        } else {
            out.push_str(&format!(
                "/// Source: {} at path {}\n",
                fact.source_id, fact.path
            ));
        }

        // Doc comment: mapped endpoint if available
        if let Some(mapping) = mapping_map.get(fact.id.as_str()) {
            out.push_str(&format!("/// Mapped endpoint: {}\n", mapping.description));
        }

        out.push_str("#[test]\n");
        out.push_str(&format!("fn test_fact_{}() {{\n", fact.id));

        // Generate placeholder value and assertions based on type
        generate_type_assertions(&mut out, &fact.fact_type, base_type);

        out.push_str("}\n\n");
    }

    out
}

/// Format a human-readable type label from the fact_type JSON.
fn format_type_label(fact_type: &serde_json::Value, base: &str) -> String {
    match base {
        "Money" => {
            let currency = fact_type
                .get("currency")
                .and_then(|c| c.as_str())
                .unwrap_or("?");
            format!("Money({})", currency)
        }
        "Enum" => {
            if let Some(values) = fact_type.get("values").and_then(|v| v.as_array()) {
                let vals: Vec<&str> = values.iter().filter_map(|v| v.as_str()).collect();
                format!("Enum{:?}", vals)
            } else {
                "Enum".to_string()
            }
        }
        "Decimal" => {
            let precision = fact_type.get("precision").and_then(|p| p.as_u64());
            let scale = fact_type.get("scale").and_then(|s| s.as_u64());
            match (precision, scale) {
                (Some(p), Some(s)) => format!("Decimal({}, {})", p, s),
                _ => "Decimal".to_string(),
            }
        }
        "List" => {
            let element = fact_type
                .get("element")
                .and_then(|e| e.get("base"))
                .and_then(|b| b.as_str())
                .unwrap_or("?");
            let max = fact_type.get("max").and_then(|m| m.as_u64());
            match max {
                Some(m) => format!("List<{}, max={}>", element, m),
                None => format!("List<{}>", element),
            }
        }
        other => other.to_string(),
    }
}

/// Generate placeholder value and type-checking assertions for a fact.
fn generate_type_assertions(out: &mut String, fact_type: &serde_json::Value, base: &str) {
    match base {
        "Money" => generate_money_assertions(out, fact_type),
        "Enum" => generate_enum_assertions(out, fact_type),
        "Record" => generate_record_assertions(out, fact_type),
        "List" => generate_list_assertions(out, fact_type),
        "Int" => generate_int_assertions(out),
        "Decimal" => generate_decimal_assertions(out),
        "Bool" => generate_bool_assertions(out),
        "Text" => generate_text_assertions(out),
        "Date" => generate_date_assertions(out),
        "DateTime" => generate_datetime_assertions(out),
        _ => generate_unknown_assertions(out, base),
    }
}

fn generate_money_assertions(out: &mut String, fact_type: &serde_json::Value) {
    let currency = fact_type
        .get("currency")
        .and_then(|c| c.as_str())
        .unwrap_or("USD");

    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value: serde_json::Value = serde_json::json!({\n");
    out.push_str("        \"amount\": \"0.00\",\n");
    out.push_str(&format!("        \"currency\": \"{}\"\n", currency));
    out.push_str("    });\n\n");
    out.push_str(&format!("    // Type check: Money({})\n", currency));
    out.push_str("    assert!(value.is_object(), \"Money value must be an object\");\n");
    out.push_str(
        "    assert!(value.get(\"amount\").is_some(), \"Money value must have 'amount' field\");\n",
    );
    out.push_str(
        "    assert!(value.get(\"currency\").is_some(), \"Money value must have 'currency' field\");\n",
    );
    out.push_str("    assert_eq!(\n");
    out.push_str("        value[\"currency\"].as_str().unwrap_or(\"\"),\n");
    out.push_str(&format!("        \"{}\",\n", currency));
    out.push_str("        \"Currency must match declared type\"\n");
    out.push_str("    );\n");
}

fn generate_enum_assertions(out: &mut String, fact_type: &serde_json::Value) {
    let values = fact_type
        .get("values")
        .and_then(|v| v.as_array())
        .cloned()
        .unwrap_or_default();
    let str_values: Vec<&str> = values.iter().filter_map(|v| v.as_str()).collect();

    let first = str_values.first().copied().unwrap_or("value");

    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str(&format!(
        "    let value = serde_json::json!(\"{}\");\n\n",
        first
    ));
    out.push_str(&format!("    // Type check: Enum{:?}\n", str_values));

    // Build the valid_values array literal
    let quoted: Vec<String> = str_values.iter().map(|v| format!("\"{}\"", v)).collect();
    out.push_str(&format!(
        "    let valid_values = [{}];\n",
        quoted.join(", ")
    ));
    out.push_str("    let str_val = value.as_str().expect(\"Enum value must be a string\");\n");
    out.push_str("    assert!(\n");
    out.push_str("        valid_values.contains(&str_val),\n");
    out.push_str("        \"Value '{}' not in declared enum values: {:?}\",\n");
    out.push_str("        str_val, valid_values\n");
    out.push_str("    );\n");
}

fn generate_record_assertions(out: &mut String, fact_type: &serde_json::Value) {
    let fields = fact_type
        .get("fields")
        .and_then(|f| f.as_object())
        .cloned()
        .unwrap_or_default();

    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value: serde_json::Value = serde_json::json!({\n");
    for field_name in fields.keys() {
        out.push_str(&format!("        \"{}\": null,\n", field_name));
    }
    out.push_str("    });\n\n");

    let field_names: Vec<&String> = fields.keys().collect();
    out.push_str(&format!(
        "    // Type check: Record with fields {:?}\n",
        field_names
    ));
    out.push_str("    assert!(value.is_object(), \"Record value must be an object\");\n");
    for field_name in fields.keys() {
        out.push_str(&format!(
            "    assert!(value.get(\"{}\").is_some(), \"Record must have '{}' field\");\n",
            field_name, field_name
        ));
    }
}

fn generate_list_assertions(out: &mut String, fact_type: &serde_json::Value) {
    let element_base = fact_type
        .get("element")
        .and_then(|e| e.get("base"))
        .and_then(|b| b.as_str())
        .unwrap_or("Unknown");
    let max = fact_type.get("max").and_then(|m| m.as_u64());

    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!([]);\n\n");
    out.push_str(&format!("    // Type check: List<{}>\n", element_base));
    out.push_str("    assert!(value.is_array(), \"List value must be an array\");\n");
    if let Some(max_val) = max {
        out.push_str(&format!(
            "    assert!(\n        value.as_array().unwrap().len() <= {},\n        \"List length must not exceed max of {}\"\n    );\n",
            max_val, max_val
        ));
    }
}

fn generate_int_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(0);\n\n");
    out.push_str("    // Type check: Int\n");
    out.push_str(
        "    assert!(value.is_i64() || value.is_u64(), \"Int value must be an integer\");\n",
    );
}

fn generate_decimal_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(0.0);\n\n");
    out.push_str("    // Type check: Decimal\n");
    out.push_str("    assert!(value.is_number(), \"Decimal value must be numeric\");\n");
}

fn generate_bool_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(false);\n\n");
    out.push_str("    // Type check: Bool\n");
    out.push_str("    assert!(value.is_boolean(), \"Bool value must be a boolean\");\n");
}

fn generate_text_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(\"\");\n\n");
    out.push_str("    // Type check: Text\n");
    out.push_str("    assert!(value.is_string(), \"Text value must be a string\");\n");
}

fn generate_date_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(\"2024-01-01\");\n\n");
    out.push_str("    // Type check: Date\n");
    out.push_str("    let date_str = value.as_str().expect(\"Date value must be a string\");\n");
    out.push_str("    assert!(!date_str.is_empty(), \"Date string must not be empty\");\n");
}

fn generate_datetime_assertions(out: &mut String) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(\"2024-01-01T00:00:00Z\");\n\n");
    out.push_str("    // Type check: DateTime\n");
    out.push_str("    let dt_str = value.as_str().expect(\"DateTime value must be a string\");\n");
    out.push_str("    assert!(!dt_str.is_empty(), \"DateTime string must not be empty\");\n");
}

fn generate_unknown_assertions(out: &mut String, base: &str) {
    out.push_str("    // TODO: Replace with actual adapter fetch\n");
    out.push_str("    let value = serde_json::json!(null);\n\n");
    out.push_str(&format!(
        "    // Type check: {} (unknown type — add assertions as needed)\n",
        base
    ));
    out.push_str("    assert!(!value.is_null(), \"Value must not be null\");\n");
}

/// Generate markdown documentation of the fact-to-source mappings.
fn generate_mapping_docs(
    sources: &[SourceConstruct],
    facts: &[StructuredFact],
    mappings: &[FactMapping],
    schemas: &BTreeMap<String, ExternalSchema>,
) -> String {
    let mut out = String::new();
    out.push_str("# Fact-to-Source Mappings\n\n");
    out.push_str("Generated by `tenor connect`.\n\n");

    // Sources summary
    out.push_str("## Sources\n\n");
    out.push_str("| Source | Protocol | Schema | Description |\n");
    out.push_str("|--------|----------|--------|-------------|\n");
    for source in sources {
        let has_schema = if schemas.contains_key(&source.id) {
            "loaded"
        } else {
            "none"
        };
        let desc = source.description.as_deref().unwrap_or("-");
        out.push_str(&format!(
            "| {} | {} | {} | {} |\n",
            source.id, source.protocol, has_schema, desc
        ));
    }
    out.push('\n');

    // Mappings
    out.push_str("## Mappings\n\n");
    if mappings.is_empty() {
        out.push_str("No structured source references found.\n\n");
    } else {
        out.push_str("| Fact | Type | Source | Path | Confidence | Mapping |\n");
        out.push_str("|------|------|--------|------|------------|--------|\n");
        for m in mappings {
            let fact = facts.iter().find(|f| f.id == m.fact_id);
            let base_type = fact
                .and_then(|f| f.fact_type.get("base").and_then(|b| b.as_str()))
                .unwrap_or("?");
            let confidence = match m.confidence {
                super::matching::Confidence::High => "HIGH",
                super::matching::Confidence::Medium => "MEDIUM",
                super::matching::Confidence::Low => "LOW",
            };
            out.push_str(&format!(
                "| {} | {} | {} | {} | {} | {} |\n",
                m.fact_id, base_type, m.source_id, m.path, confidence, m.description
            ));
        }
    }
    out.push('\n');

    // Notes
    let notes: Vec<&FactMapping> = mappings.iter().filter(|m| m.note.is_some()).collect();
    if !notes.is_empty() {
        out.push_str("## Notes\n\n");
        for m in notes {
            out.push_str(&format!(
                "- **{}**: {}\n",
                m.fact_id,
                m.note.as_ref().unwrap()
            ));
        }
        out.push('\n');
    }

    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_config_toml_http() {
        let source = SourceConstruct {
            id: "order_service".to_string(),
            protocol: "http".to_string(),
            fields: {
                let mut m = BTreeMap::new();
                m.insert(
                    "base_url".to_string(),
                    "https://api.example.com".to_string(),
                );
                m.insert("auth".to_string(), "bearer_token".to_string());
                m
            },
            description: Some("Order API".to_string()),
            provenance: None,
            tenor: None,
        };

        let toml = generate_config_toml(&[source]);
        assert!(toml.contains("[source.order_service]"));
        assert!(toml.contains("protocol = \"http\""));
        assert!(toml.contains("base_url = \"https://api.example.com\""));
        assert!(toml.contains("TENOR_SOURCE_ORDER_SERVICE_AUTH_TOKEN"));
    }

    #[test]
    fn test_generate_config_toml_database() {
        let source = SourceConstruct {
            id: "compliance_db".to_string(),
            protocol: "database".to_string(),
            fields: {
                let mut m = BTreeMap::new();
                m.insert("dialect".to_string(), "postgres".to_string());
                m
            },
            description: None,
            provenance: None,
            tenor: None,
        };

        let toml = generate_config_toml(&[source]);
        assert!(toml.contains("[source.compliance_db]"));
        assert!(toml.contains("dialect = \"postgres\""));
        assert!(toml.contains("TENOR_SOURCE_COMPLIANCE_DB_CONNECTION_STRING"));
    }
}
