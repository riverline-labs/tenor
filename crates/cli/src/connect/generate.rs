//! Adapter scaffolding generation.
//!
//! Produces:
//! - Adapter configuration TOML template
//! - Test file validating each adapter's return type
//! - Mapping documentation for human review

use std::collections::BTreeMap;
use std::path::{Path, PathBuf};

use super::introspect::ExternalSchema;
use super::matching::FactMapping;
use super::StructuredFact;
use tenor_interchange::SourceConstruct;

/// Generate scaffolding files in the output directory.
pub fn generate_scaffolding(
    sources: &[SourceConstruct],
    facts: &[StructuredFact],
    mappings: &[FactMapping],
    schemas: &BTreeMap<String, ExternalSchema>,
    output_dir: &Path,
) -> Result<Vec<PathBuf>, String> {
    std::fs::create_dir_all(output_dir)
        .map_err(|e| format!("could not create output directory: {}", e))?;

    let mut files = Vec::new();

    // 1. Generate adapter config TOML
    let config_path = output_dir.join("tenor-adapters.toml");
    let config_content = generate_config_toml(sources);
    std::fs::write(&config_path, &config_content)
        .map_err(|e| format!("could not write config: {}", e))?;
    files.push(config_path);

    // 2. Generate test file
    let test_path = output_dir.join("adapter_tests.rs");
    let test_content = generate_test_file(sources, facts);
    std::fs::write(&test_path, &test_content)
        .map_err(|e| format!("could not write tests: {}", e))?;
    files.push(test_path);

    // 3. Generate mapping documentation
    let doc_path = output_dir.join("MAPPINGS.md");
    let doc_content = generate_mapping_docs(sources, facts, mappings, schemas);
    std::fs::write(&doc_path, &doc_content).map_err(|e| format!("could not write docs: {}", e))?;
    files.push(doc_path);

    Ok(files)
}

/// Generate a TOML configuration template for adapter setup.
fn generate_config_toml(sources: &[SourceConstruct]) -> String {
    let mut out = String::new();
    out.push_str("# Tenor Adapter Configuration\n");
    out.push_str("# Generated by `tenor connect`\n");
    out.push_str("#\n");
    out.push_str("# Fill in connection details for each source.\n");
    out.push_str("# Credentials should come from environment variables,\n");
    out.push_str("# not from this file (see comments below).\n\n");

    for source in sources {
        out.push_str(&format!("[source.{}]\n", source.id));
        out.push_str(&format!("protocol = \"{}\"\n", source.protocol));

        if let Some(desc) = &source.description {
            out.push_str(&format!("# {}\n", desc));
        }

        match source.protocol.as_str() {
            "http" => {
                let base_url = source
                    .fields
                    .get("base_url")
                    .map(|s| s.as_str())
                    .unwrap_or("https://TODO");
                out.push_str(&format!("base_url = \"{}\"\n", base_url));
                out.push_str("# auth_token: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_AUTH_TOKEN env var\n");
                if let Some(schema_ref) = source.fields.get("schema_ref") {
                    out.push_str(&format!("schema_ref = \"{}\"\n", schema_ref));
                }
            }
            "database" => {
                let dialect = source
                    .fields
                    .get("dialect")
                    .map(|s| s.as_str())
                    .unwrap_or("postgres");
                out.push_str(&format!("dialect = \"{}\"\n", dialect));
                out.push_str("# connection_string: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_CONNECTION_STRING env var\n");
            }
            "graphql" => {
                let endpoint = source
                    .fields
                    .get("endpoint")
                    .map(|s| s.as_str())
                    .unwrap_or("https://TODO/graphql");
                out.push_str(&format!("endpoint = \"{}\"\n", endpoint));
                out.push_str("# auth_token: set TENOR_SOURCE_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_AUTH_TOKEN env var\n");
            }
            "grpc" => {
                let endpoint = source
                    .fields
                    .get("endpoint")
                    .map(|s| s.as_str())
                    .unwrap_or("localhost:50051");
                out.push_str(&format!("endpoint = \"{}\"\n", endpoint));
            }
            "static" => {
                out.push_str("# Static values: set TENOR_STATIC_");
                out.push_str(&source.id.to_uppercase());
                out.push_str("_<PATH> env vars\n");
            }
            "manual" => {
                out.push_str("# Manual input: values provided at runtime\n");
            }
            _ => {
                out.push_str("# Extension protocol â€” configure as needed\n");
                for (k, v) in &source.fields {
                    if k != "description" {
                        out.push_str(&format!("{} = \"{}\"\n", k, v));
                    }
                }
            }
        }

        out.push('\n');
    }

    out
}

/// Generate a Rust test file that validates adapter return types.
fn generate_test_file(sources: &[SourceConstruct], facts: &[StructuredFact]) -> String {
    let mut out = String::new();
    out.push_str("//! Adapter validation tests\n");
    out.push_str("//! Generated by `tenor connect`\n");
    out.push_str("//!\n");
    out.push_str("//! These tests verify that each adapter returns values\n");
    out.push_str("//! compatible with the declared Fact types.\n\n");
    out.push_str("use tenor_eval::adapter::*;\n");
    out.push_str("use std::collections::BTreeMap;\n\n");

    // Group facts by source
    let mut facts_by_source: BTreeMap<&str, Vec<&StructuredFact>> = BTreeMap::new();
    for fact in facts {
        facts_by_source
            .entry(&fact.source_id)
            .or_default()
            .push(fact);
    }

    for source in sources {
        let source_facts = match facts_by_source.get(source.id.as_str()) {
            Some(f) => f,
            None => continue,
        };

        out.push_str(&format!(
            "/// Tests for source '{}' (protocol: {})\n",
            source.id, source.protocol
        ));
        out.push_str("#[tokio::test]\n");
        out.push_str(&format!("async fn test_{}_adapter() {{\n", source.id));

        // Build source fields
        out.push_str("    let mut fields = BTreeMap::new();\n");
        for (k, v) in &source.fields {
            out.push_str(&format!(
                "    fields.insert(\"{}\".to_string(), \"{}\".to_string());\n",
                k, v
            ));
        }
        out.push('\n');

        out.push_str(&format!(
            "    // TODO: Configure adapter for '{}' protocol\n",
            source.protocol
        ));
        out.push_str("    // let adapter = ...;\n\n");

        for fact in source_facts {
            let base_type = fact
                .fact_type
                .get("base")
                .and_then(|b| b.as_str())
                .unwrap_or("Unknown");
            out.push_str(&format!(
                "    // Fact '{}' expects type '{}' from path '{}'\n",
                fact.id, base_type, fact.path
            ));
            out.push_str(&format!(
                "    // let source_ref = StructuredSourceRef {{ source_id: \"{}\".into(), path: \"{}\".into() }};\n",
                fact.source_id, fact.path
            ));
            out.push_str(&format!(
                "    // let result = adapter.fetch(\"{}\", &source_ref, &fields).await;\n",
                fact.id
            ));
            out.push_str("    // assert!(result.is_ok());\n\n");
        }

        out.push_str("}\n\n");
    }

    out
}

/// Generate markdown documentation of the fact-to-source mappings.
fn generate_mapping_docs(
    sources: &[SourceConstruct],
    facts: &[StructuredFact],
    mappings: &[FactMapping],
    schemas: &BTreeMap<String, ExternalSchema>,
) -> String {
    let mut out = String::new();
    out.push_str("# Fact-to-Source Mappings\n\n");
    out.push_str("Generated by `tenor connect`.\n\n");

    // Sources summary
    out.push_str("## Sources\n\n");
    out.push_str("| Source | Protocol | Schema | Description |\n");
    out.push_str("|--------|----------|--------|-------------|\n");
    for source in sources {
        let has_schema = if schemas.contains_key(&source.id) {
            "loaded"
        } else {
            "none"
        };
        let desc = source.description.as_deref().unwrap_or("-");
        out.push_str(&format!(
            "| {} | {} | {} | {} |\n",
            source.id, source.protocol, has_schema, desc
        ));
    }
    out.push('\n');

    // Mappings
    out.push_str("## Mappings\n\n");
    if mappings.is_empty() {
        out.push_str("No structured source references found.\n\n");
    } else {
        out.push_str("| Fact | Type | Source | Path | Confidence | Mapping |\n");
        out.push_str("|------|------|--------|------|------------|--------|\n");
        for m in mappings {
            let fact = facts.iter().find(|f| f.id == m.fact_id);
            let base_type = fact
                .and_then(|f| f.fact_type.get("base").and_then(|b| b.as_str()))
                .unwrap_or("?");
            let confidence = match m.confidence {
                super::matching::Confidence::High => "HIGH",
                super::matching::Confidence::Medium => "MEDIUM",
                super::matching::Confidence::Low => "LOW",
            };
            out.push_str(&format!(
                "| {} | {} | {} | {} | {} | {} |\n",
                m.fact_id, base_type, m.source_id, m.path, confidence, m.description
            ));
        }
    }
    out.push('\n');

    // Notes
    let notes: Vec<&FactMapping> = mappings.iter().filter(|m| m.note.is_some()).collect();
    if !notes.is_empty() {
        out.push_str("## Notes\n\n");
        for m in notes {
            out.push_str(&format!(
                "- **{}**: {}\n",
                m.fact_id,
                m.note.as_ref().unwrap()
            ));
        }
        out.push('\n');
    }

    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_config_toml_http() {
        let source = SourceConstruct {
            id: "order_service".to_string(),
            protocol: "http".to_string(),
            fields: {
                let mut m = BTreeMap::new();
                m.insert(
                    "base_url".to_string(),
                    "https://api.example.com".to_string(),
                );
                m.insert("auth".to_string(), "bearer_token".to_string());
                m
            },
            description: Some("Order API".to_string()),
            provenance: None,
            tenor: None,
        };

        let toml = generate_config_toml(&[source]);
        assert!(toml.contains("[source.order_service]"));
        assert!(toml.contains("protocol = \"http\""));
        assert!(toml.contains("base_url = \"https://api.example.com\""));
        assert!(toml.contains("TENOR_SOURCE_ORDER_SERVICE_AUTH_TOKEN"));
    }

    #[test]
    fn test_generate_config_toml_database() {
        let source = SourceConstruct {
            id: "compliance_db".to_string(),
            protocol: "database".to_string(),
            fields: {
                let mut m = BTreeMap::new();
                m.insert("dialect".to_string(), "postgres".to_string());
                m
            },
            description: None,
            provenance: None,
            tenor: None,
        };

        let toml = generate_config_toml(&[source]);
        assert!(toml.contains("[source.compliance_db]"));
        assert!(toml.contains("dialect = \"postgres\""));
        assert!(toml.contains("TENOR_SOURCE_COMPLIANCE_DB_CONNECTION_STRING"));
    }
}
