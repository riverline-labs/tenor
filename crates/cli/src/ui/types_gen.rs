//! Contract-driven TypeScript type generation for the UI.
//!
//! Generates types.ts with entity state unions, fact interface, persona union,
//! operation metadata, flow metadata, verdict types, and fact metadata for
//! input rendering â€” all derived from the contract's interchange bundle.

use tenor_codegen::bundle::{CodegenBundle, TypeInfo};
use tenor_codegen::typescript::{to_camel_case, to_pascal_case};

/// Generate the `types.ts` content for the UI project.
///
/// Produces contract-specific TypeScript types suitable for UI components:
/// entity state unions, EntityStates map, ENTITIES const with transitions,
/// Facts interface (with UI-friendly types), Persona union, PERSONAS array,
/// operation metadata, flow metadata, verdict types, and FACTS metadata array.
pub(super) fn emit_ui_types(bundle: &CodegenBundle) -> String {
    let mut out = String::new();

    out.push_str("// Auto-generated by tenor ui. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');

    // 1. Entity state union types
    for entity in &bundle.entities {
        let pascal_id = to_pascal_case(&entity.id);
        let states: Vec<String> = entity.states.iter().map(|s| format!("\"{}\"", s)).collect();
        if states.is_empty() {
            out.push_str(&format!("export type {}State = string;\n\n", pascal_id));
        } else {
            out.push_str(&format!(
                "export type {}State = {};\n\n",
                pascal_id,
                states.join(" | ")
            ));
        }
    }

    // 2. Combined entity states map type
    if !bundle.entities.is_empty() {
        out.push_str("export interface EntityStates {\n");
        for entity in &bundle.entities {
            let pascal_id = to_pascal_case(&entity.id);
            out.push_str(&format!("  {}: {}State;\n", pascal_id, pascal_id));
        }
        out.push_str("}\n\n");
    }

    // 3. Entity metadata const (states, initial state, transitions)
    if !bundle.entities.is_empty() {
        out.push_str("export const ENTITIES = {\n");
        for entity in &bundle.entities {
            let pascal_id = to_pascal_case(&entity.id);
            let states_arr: Vec<String> =
                entity.states.iter().map(|s| format!("\"{}\"", s)).collect();
            let initial = entity.states.first().map(|s| s.as_str()).unwrap_or("");
            out.push_str(&format!("  {}: {{\n", pascal_id));
            out.push_str(&format!(
                "    states: [{}] as const,\n",
                states_arr.join(", ")
            ));
            out.push_str(&format!("    initial: \"{}\",\n", initial));
            if entity.transitions.is_empty() {
                out.push_str("    transitions: [] as [string, string][],\n");
            } else {
                let pairs: Vec<String> = entity
                    .transitions
                    .iter()
                    .map(|(from, to)| format!("[\"{}\", \"{}\"]", from, to))
                    .collect();
                out.push_str(&format!(
                    "    transitions: [{}] as [string, string][],\n",
                    pairs.join(", ")
                ));
            }
            out.push_str("  },\n");
        }
        out.push_str("} as const;\n\n");
    }

    // 4. Facts interface with UI-friendly type mapping
    // For UI: Money -> { amount: number; currency: string }, Decimal -> number,
    // Date/DateTime -> string (form input values)
    if !bundle.facts.is_empty() {
        out.push_str("export interface Facts {\n");
        for fact in &bundle.facts {
            let camel_id = to_camel_case(&fact.id);
            let ts_type = type_info_to_ui_ts(&fact.type_info);
            out.push_str(&format!("  {}: {};\n", camel_id, ts_type));
        }
        out.push_str("}\n\n");
    }

    // 5. Persona union type
    if !bundle.personas.is_empty() {
        let persona_union: Vec<String> = bundle
            .personas
            .iter()
            .map(|p| format!("\"{}\"", p.id))
            .collect();
        out.push_str(&format!(
            "export type Persona = {};\n\n",
            persona_union.join(" | ")
        ));

        // 6. PERSONAS array const
        out.push_str("export const PERSONAS: Persona[] = [\n");
        for p in &bundle.personas {
            out.push_str(&format!("  \"{}\",\n", p.id));
        }
        out.push_str("];\n\n");
    }

    // 7. Operation metadata
    if !bundle.operations.is_empty() {
        out.push_str("export interface OperationMeta {\n");
        out.push_str("  id: string;\n");
        out.push_str("  allowed_personas: Persona[];\n");
        out.push_str("}\n\n");

        out.push_str("export const OPERATIONS: OperationMeta[] = [\n");
        for op in &bundle.operations {
            let personas: Vec<String> = op
                .allowed_personas
                .iter()
                .map(|p| format!("\"{}\"", p))
                .collect();
            out.push_str(&format!(
                "  {{ id: \"{}\", allowed_personas: [{}] }},\n",
                op.id,
                personas.join(", ")
            ));
        }
        out.push_str("];\n\n");
    }

    // 8. Flow metadata
    if !bundle.flows.is_empty() {
        out.push_str("export interface FlowMeta {\n");
        out.push_str("  id: string;\n");
        out.push_str("}\n\n");

        out.push_str("export const FLOWS: FlowMeta[] = [\n");
        for flow in &bundle.flows {
            out.push_str(&format!("  {{ id: \"{}\" }},\n", flow.id));
        }
        out.push_str("];\n\n");
    }

    // 9. Verdict types
    let verdict_types: Vec<&str> = {
        let mut seen = std::collections::BTreeSet::new();
        bundle
            .rules
            .iter()
            .filter(|r| seen.insert(r.verdict_type.as_str()))
            .map(|r| r.verdict_type.as_str())
            .collect()
    };
    if !verdict_types.is_empty() {
        let union: Vec<String> = verdict_types
            .iter()
            .map(|vt| format!("\"{}\"", vt))
            .collect();
        out.push_str(&format!(
            "export type VerdictType = {};\n\n",
            union.join(" | ")
        ));

        out.push_str("export const VERDICT_TYPES: VerdictType[] = [\n");
        for vt in &verdict_types {
            out.push_str(&format!("  \"{}\",\n", vt));
        }
        out.push_str("];\n\n");
    }

    // 10. Fact metadata for input rendering
    if !bundle.facts.is_empty() {
        out.push_str("export interface FactMeta {\n");
        out.push_str("  id: string;\n");
        out.push_str("  label: string;\n");
        out.push_str("  type: string;\n");
        out.push_str("  enumValues?: string[];\n");
        out.push_str("  currency?: string;\n");
        out.push_str("  fields?: Record<string, FactMeta>;\n");
        out.push_str("  elementType?: FactMeta;\n");
        out.push_str("}\n\n");

        out.push_str("export const FACTS: FactMeta[] = [\n");
        for fact in &bundle.facts {
            let label = fact
                .id
                .replace('_', " ")
                .split_whitespace()
                .map(|w| {
                    let mut c = w.chars();
                    match c.next() {
                        None => String::new(),
                        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                    }
                })
                .collect::<Vec<_>>()
                .join(" ");
            let meta = emit_fact_meta(&fact.id, &label, &fact.type_info, 1);
            out.push_str(&format!("  {},\n", meta));
        }
        out.push_str("];\n");
    }

    out
}

/// Recursively emit a FactMeta object literal for a given TypeInfo.
fn emit_fact_meta(id: &str, label: &str, type_info: &TypeInfo, _depth: usize) -> String {
    match type_info {
        TypeInfo::Bool => {
            format!("{{ id: \"{}\", label: \"{}\", type: \"Bool\" }}", id, label)
        }
        TypeInfo::Int { .. } => {
            format!("{{ id: \"{}\", label: \"{}\", type: \"Int\" }}", id, label)
        }
        TypeInfo::Decimal { .. } => {
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"Decimal\" }}",
                id, label
            )
        }
        TypeInfo::Money { currency } => {
            if let Some(cur) = currency {
                format!(
                    "{{ id: \"{}\", label: \"{}\", type: \"Money\", currency: \"{}\" }}",
                    id, label, cur
                )
            } else {
                format!(
                    "{{ id: \"{}\", label: \"{}\", type: \"Money\" }}",
                    id, label
                )
            }
        }
        TypeInfo::Text { .. } => {
            format!("{{ id: \"{}\", label: \"{}\", type: \"Text\" }}", id, label)
        }
        TypeInfo::Date => {
            format!("{{ id: \"{}\", label: \"{}\", type: \"Date\" }}", id, label)
        }
        TypeInfo::DateTime => {
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"DateTime\" }}",
                id, label
            )
        }
        TypeInfo::Duration { .. } => {
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"Duration\" }}",
                id, label
            )
        }
        TypeInfo::Enum { values } => {
            let vals: Vec<String> = values.iter().map(|v| format!("\"{}\"", v)).collect();
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"Enum\", enumValues: [{}] }}",
                id,
                label,
                vals.join(", ")
            )
        }
        TypeInfo::List { element_type, .. } => {
            let elem_meta = emit_fact_meta("_item", "Item", element_type, _depth + 1);
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"List\", elementType: {} }}",
                id, label, elem_meta
            )
        }
        TypeInfo::Record { fields } => {
            let field_entries: Vec<String> = fields
                .iter()
                .map(|(k, v)| {
                    let field_label = k
                        .replace('_', " ")
                        .split_whitespace()
                        .map(|w| {
                            let mut c = w.chars();
                            match c.next() {
                                None => String::new(),
                                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                            }
                        })
                        .collect::<Vec<_>>()
                        .join(" ");
                    let field_meta = emit_fact_meta(k, &field_label, v, _depth + 1);
                    format!("\"{}\": {}", k, field_meta)
                })
                .collect();
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"Record\", fields: {{ {} }} }}",
                id,
                label,
                field_entries.join(", ")
            )
        }
        TypeInfo::TaggedUnion { variants } => {
            // Treat tagged union like an enum for UI purposes (show variant tags as options)
            let vals: Vec<String> = variants.keys().map(|k| format!("\"{}\"", k)).collect();
            format!(
                "{{ id: \"{}\", label: \"{}\", type: \"Enum\", enumValues: [{}] }}",
                id,
                label,
                vals.join(", ")
            )
        }
    }
}

/// Map a TypeInfo to a UI-friendly TypeScript type string.
///
/// Differs from codegen typescript.rs:
/// - Money -> `{ amount: number; currency: string }` (not branded TenorMoney)
/// - Decimal -> `number` (not string)
/// - Date/DateTime -> `string` (form input values)
/// - Duration -> `string`
pub(super) fn type_info_to_ui_ts(t: &TypeInfo) -> String {
    match t {
        TypeInfo::Bool => "boolean".to_string(),
        TypeInfo::Int { .. } => "number".to_string(),
        TypeInfo::Decimal { .. } => "number".to_string(),
        TypeInfo::Money { .. } => "{ amount: number; currency: string }".to_string(),
        TypeInfo::Text { .. } => "string".to_string(),
        TypeInfo::Date => "string".to_string(),
        TypeInfo::DateTime => "string".to_string(),
        TypeInfo::Duration { .. } => "string".to_string(),
        TypeInfo::Enum { values } => {
            let union: Vec<String> = values.iter().map(|v| format!("\"{}\"", v)).collect();
            if union.is_empty() {
                "string".to_string()
            } else {
                union.join(" | ")
            }
        }
        TypeInfo::List { element_type, .. } => {
            format!("Array<{}>", type_info_to_ui_ts(element_type))
        }
        TypeInfo::Record { fields } => {
            if fields.is_empty() {
                "Record<string, unknown>".to_string()
            } else {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(k, v)| format!("{}: {}", k, type_info_to_ui_ts(v)))
                    .collect();
                format!("{{ {} }}", field_strs.join("; "))
            }
        }
        TypeInfo::TaggedUnion { variants } => {
            if variants.is_empty() {
                "never".to_string()
            } else {
                let variant_strs: Vec<String> = variants
                    .iter()
                    .map(|(tag, payload_type)| {
                        format!(
                            "{{ tag: \"{}\"; payload: {} }}",
                            tag,
                            type_info_to_ui_ts(payload_type)
                        )
                    })
                    .collect();
                variant_strs.join(" | ")
            }
        }
    }
}
