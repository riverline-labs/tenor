//! React hook generation functions for the tenor UI project.

/// Generate `useActionSpace.ts` hook content.
///
/// Fetches the action space for a given persona and facts, with 300ms debounce.
pub(super) fn emit_use_action_space() -> String {
    r#"// Auto-generated by tenor ui. Do not edit.
import { useState, useEffect, useRef, useCallback } from 'react';
import { client, ActionSpace, FactSet } from '../api';

export function useActionSpace(persona: string, facts: FactSet) {
  const [actionSpace, setActionSpace] = useState<ActionSpace | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const debounceTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const [refreshToken, setRefreshToken] = useState(0);

  const refresh = useCallback(() => {
    setRefreshToken((t) => t + 1);
  }, []);

  useEffect(() => {
    if (!persona) return;

    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }

    debounceTimer.current = setTimeout(async () => {
      setLoading(true);
      setError(null);
      try {
        const result = await client.getActionSpace(persona, facts);
        setActionSpace(result);
      } catch (e) {
        setError(e instanceof Error ? e.message : String(e));
      } finally {
        setLoading(false);
      }
    }, 300);

    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
    };
  }, [persona, JSON.stringify(facts), refreshToken]);

  return { actionSpace, loading, error, refresh };
}
"#
    .to_string()
}

/// Generate `useEntities.ts` hook content.
///
/// Fetches entity instances for each entity type and provides a helper to look
/// up the state of a specific instance.
pub(super) fn emit_use_entities() -> String {
    r#"// Auto-generated by tenor ui. Do not edit.
import { useState, useEffect, useCallback } from 'react';
import { client, EntityInstance } from '../api';
import { ENTITIES } from '../types';

export type EntityInstanceMap = Record<string, EntityInstance[]>;

export function useEntities() {
  const [instances, setInstances] = useState<EntityInstanceMap>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [refreshToken, setRefreshToken] = useState(0);

  const refresh = useCallback(() => {
    setRefreshToken((t) => t + 1);
  }, []);

  useEffect(() => {
    let cancelled = false;
    setLoading(true);
    setError(null);

    const entityIds = Object.keys(ENTITIES);
    Promise.all(
      entityIds.map((entityId) =>
        client.getEntityInstances(entityId).then((list) => ({ entityId, list }))
      )
    )
      .then((results) => {
        if (cancelled) return;
        const map: EntityInstanceMap = {};
        for (const { entityId, list } of results) {
          map[entityId] = list;
        }
        setInstances(map);
      })
      .catch((e) => {
        if (!cancelled) setError(e instanceof Error ? e.message : String(e));
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
    };
  }, [refreshToken]);

  const getInstanceState = useCallback(
    (entityId: string, instanceId: string): string | null => {
      const entityInstances = instances[entityId] ?? [];
      const found = entityInstances.find((i) => i.instance_id === instanceId);
      return found?.state ?? null;
    },
    [instances]
  );

  return { instances, loading, error, refresh, getInstanceState };
}
"#
    .to_string()
}

/// Generate `useExecution.ts` hook content.
///
/// Provides execute and simulate functions that call the TenorClient and track
/// the last result for display.
pub(super) fn emit_use_execution() -> String {
    r#"// Auto-generated by tenor ui. Do not edit.
import { useState, useCallback } from 'react';
import { client, FlowResult, FactSet, InstanceBindingMap } from '../api';

export function useExecution() {
  const [result, setResult] = useState<FlowResult | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(
    async (
      flowId: string,
      persona: string,
      facts: FactSet,
      bindings: InstanceBindingMap
    ): Promise<FlowResult | null> => {
      setLoading(true);
      setError(null);
      try {
        const res = await client.executeFlow(flowId, persona, facts, bindings);
        setResult(res);
        return res;
      } catch (e) {
        setError(e instanceof Error ? e.message : String(e));
        return null;
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const simulate = useCallback(
    async (
      flowId: string,
      persona: string,
      facts: FactSet,
      bindings: InstanceBindingMap
    ): Promise<FlowResult | null> => {
      setLoading(true);
      setError(null);
      try {
        const res = await client.simulateFlow(flowId, persona, facts, bindings);
        setResult(res);
        return res;
      } catch (e) {
        setError(e instanceof Error ? e.message : String(e));
        return null;
      } finally {
        setLoading(false);
      }
    },
    []
  );

  return { execute, simulate, result, loading, error };
}
"#
    .to_string()
}
