use std::path::{Path, PathBuf};

use tenor_codegen::bundle::{CodegenBundle, TypeInfo};
use tenor_codegen::typescript::{to_camel_case, to_pascal_case};

use super::api_client;
use super::templates;

/// Configuration for UI project generation.
pub(super) struct UiConfig {
    pub output_dir: PathBuf,
    pub api_url: String,
    pub contract_id: String,
    pub title: String,
    pub custom_theme: Option<serde_json::Value>,
}

/// Generate a complete React UI project from a contract bundle.
///
/// Returns the list of all generated file paths on success.
pub(super) fn generate_ui_project(
    bundle: &CodegenBundle,
    config: &UiConfig,
) -> Result<Vec<PathBuf>, String> {
    let out = &config.output_dir;

    // Create directory structure
    let src_dir = out.join("src");
    let components_dir = src_dir.join("components");
    let hooks_dir = src_dir.join("hooks");
    let public_dir = out.join("public");

    for dir in &[out, &src_dir, &components_dir, &hooks_dir, &public_dir] {
        std::fs::create_dir_all(dir)
            .map_err(|e| format!("failed to create directory '{}': {}", dir.display(), e))?;
    }

    // Build list of (path, content) pairs for static files
    let static_files: Vec<(PathBuf, String)> = vec![
        // Root files
        (
            out.join("package.json"),
            templates::package_json(&config.title),
        ),
        (out.join("tsconfig.json"), templates::tsconfig_json()),
        (out.join("vite.config.ts"), templates::vite_config()),
        // public/
        (
            public_dir.join("index.html"),
            templates::index_html(&config.title),
        ),
        // src/
        (src_dir.join("main.tsx"), templates::main_tsx()),
        (
            src_dir.join("App.tsx"),
            templates::app_tsx(&config.contract_id, &config.title),
        ),
        (
            src_dir.join("api.ts"),
            api_client::emit_api_client(&config.api_url, &config.contract_id),
        ),
        (src_dir.join("types.ts"), emit_types(bundle)),
        (
            src_dir.join("theme.ts"),
            emit_theme(&config.contract_id, config.custom_theme.as_ref()),
        ),
        // src/components/ â€” Layout gets a full implementation
        (
            components_dir.join("Layout.tsx"),
            templates::layout_tsx(&config.title),
        ),
    ];

    // Write static files and collect paths
    let mut files: Vec<PathBuf> = static_files
        .into_iter()
        .map(|(path, content)| write_file(&path, &content))
        .collect::<Result<Vec<_>, _>>()?;

    // Stub components (Plan 08-02 will flesh these out)
    let stub_components = [
        "Dashboard",
        "EntityList",
        "EntityDetail",
        "InstanceDetail",
        "ActionSpace",
        "BlockedActions",
        "FactInput",
        "FlowExecution",
        "FlowHistory",
        "ProvenanceDrill",
        "VerdictDisplay",
    ];
    for name in &stub_components {
        files.push(write_file(
            &components_dir.join(format!("{}.tsx", name)),
            &templates::stub_component(name),
        )?);
    }

    // Stub hooks (Plan 08-02 will flesh these out)
    let hook_files: Vec<(PathBuf, String)> = vec![
        (
            hooks_dir.join("useActionSpace.ts"),
            templates::stub_hook("useActionSpace", "null", "null"),
        ),
        (
            hooks_dir.join("useEntities.ts"),
            templates::stub_hook("useEntities", "null", "null"),
        ),
        (
            hooks_dir.join("useExecution.ts"),
            templates::stub_hook("useExecution", "null", "null"),
        ),
    ];
    for (path, content) in hook_files {
        files.push(write_file(&path, &content)?);
    }

    Ok(files)
}

/// Write content to a file, returning the path on success.
fn write_file(path: &Path, content: &str) -> Result<PathBuf, String> {
    std::fs::write(path, content)
        .map_err(|e| format!("failed to write '{}': {}", path.display(), e))?;
    Ok(path.to_path_buf())
}

/// Generate types.ts with entity state unions, fact interface, persona union,
/// operation metadata, and flow metadata.
fn emit_types(bundle: &CodegenBundle) -> String {
    let mut out = String::new();

    out.push_str("// Auto-generated by tenor ui. Do not edit.\n");
    out.push_str(&format!("// Contract: {}\n", bundle.id));
    out.push('\n');

    // Entity state union types
    for entity in &bundle.entities {
        let pascal_id = to_pascal_case(&entity.id);
        let states: Vec<String> = entity.states.iter().map(|s| format!("'{}'", s)).collect();
        out.push_str(&format!(
            "export type {}State = {};\n\n",
            pascal_id,
            states.join(" | ")
        ));
    }

    // Fact interface with TS-mapped types
    if !bundle.facts.is_empty() {
        let pascal_bundle_id = to_pascal_case(&bundle.id);
        out.push_str(&format!("export interface {}Facts {{\n", pascal_bundle_id));
        for fact in &bundle.facts {
            let camel_id = to_camel_case(&fact.id);
            let ts_type = type_info_to_ts(&fact.type_info);
            out.push_str(&format!("  {}: {};\n", camel_id, ts_type));
        }
        out.push_str("}\n\n");
    }

    // Persona string union
    if !bundle.personas.is_empty() {
        let persona_union: Vec<String> = bundle
            .personas
            .iter()
            .map(|p| format!("'{}'", p.id))
            .collect();
        out.push_str(&format!(
            "export type Persona = {};\n\n",
            persona_union.join(" | ")
        ));
    }

    // Operation metadata
    if !bundle.operations.is_empty() {
        out.push_str("export const OPERATIONS = [\n");
        for op in &bundle.operations {
            let personas: Vec<String> = op
                .allowed_personas
                .iter()
                .map(|p| format!("'{}'", p))
                .collect();
            out.push_str(&format!(
                "  {{ id: '{}', allowed_personas: [{}] }},\n",
                op.id,
                personas.join(", ")
            ));
        }
        out.push_str("] as const;\n\n");
    }

    // Flow metadata
    if !bundle.flows.is_empty() {
        out.push_str("export const FLOWS = [\n");
        for flow in &bundle.flows {
            out.push_str(&format!("  {{ id: '{}' }},\n", flow.id));
        }
        out.push_str("] as const;\n");
    }

    out
}

/// Map a TypeInfo to a TypeScript type string.
fn type_info_to_ts(t: &TypeInfo) -> String {
    match t {
        TypeInfo::Bool => "boolean".to_string(),
        TypeInfo::Int { .. } => "number".to_string(),
        TypeInfo::Decimal { .. } => "string".to_string(),
        TypeInfo::Money { .. } => "string".to_string(),
        TypeInfo::Text { .. } => "string".to_string(),
        TypeInfo::Date => "string".to_string(),
        TypeInfo::DateTime => "string".to_string(),
        TypeInfo::Duration { .. } => "string".to_string(),
        TypeInfo::Enum { values } => {
            let union: Vec<String> = values.iter().map(|v| format!("'{}'", v)).collect();
            if union.is_empty() {
                "string".to_string()
            } else {
                union.join(" | ")
            }
        }
        TypeInfo::List { element_type, .. } => {
            format!("Array<{}>", type_info_to_ts(element_type))
        }
        TypeInfo::Record { fields } => {
            if fields.is_empty() {
                "Record<string, unknown>".to_string()
            } else {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(k, v)| format!("{}: {}", k, type_info_to_ts(v)))
                    .collect();
                format!("{{ {} }}", field_strs.join("; "))
            }
        }
        TypeInfo::TaggedUnion { variants } => {
            if variants.is_empty() {
                "never".to_string()
            } else {
                let variant_strs: Vec<String> = variants
                    .iter()
                    .map(|(tag, payload_type)| {
                        format!(
                            "{{ tag: '{}'; payload: {} }}",
                            tag,
                            type_info_to_ts(payload_type)
                        )
                    })
                    .collect();
                variant_strs.join(" | ")
            }
        }
    }
}

/// Generate theme.ts with contract-derived color palette.
fn emit_theme(contract_id: &str, custom_theme: Option<&serde_json::Value>) -> String {
    // If a custom theme was provided, serialize it directly
    if let Some(theme) = custom_theme {
        let theme_str = serde_json::to_string_pretty(theme).unwrap_or_default();
        return format!(
            "// Auto-generated by tenor ui (custom theme).\nexport const theme = {} as const;\n",
            theme_str
        );
    }

    // Derive primary hue from contract_id hash
    let hue = contract_id_to_hue(contract_id);
    let primary = hsl_to_hex(hue, 0.55, 0.45);
    let primary_light = hsl_to_hex(hue, 0.55, 0.93);
    let secondary = hsl_to_hex((hue + 30) % 360, 0.40, 0.50);
    let accent = hsl_to_hex((hue + 180) % 360, 0.55, 0.45);

    format!(
        r#"// Auto-generated by tenor ui. Do not edit.
// Theme derived from contract: {contract_id}

export const theme = {{
  colors: {{
    primary: '{primary}',
    primaryLight: '{primary_light}',
    secondary: '{secondary}',
    accent: '{accent}',
    background: '#f8f9fa',
    surface: '#ffffff',
    sidebar: '#f1f3f5',
    border: '#dee2e6',
    text: '#212529',
    textMuted: '#6c757d',
    success: '#16a34a',
    warning: '#d97706',
    error: '#dc2626',
    info: '#2563eb',
  }},
  fonts: {{
    body: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif",
    mono: "'Fira Code', 'Cascadia Code', 'JetBrains Mono', Consolas, monospace",
  }},
  spacing: {{
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
  }},
  borderRadius: {{
    sm: '4px',
    md: '8px',
    lg: '12px',
  }},
}} as const;

export type Theme = typeof theme;
"#,
        contract_id = contract_id,
        primary = primary,
        primary_light = primary_light,
        secondary = secondary,
        accent = accent,
    )
}

/// Hash the contract_id to a hue value 0-359.
fn contract_id_to_hue(contract_id: &str) -> u32 {
    let mut hash: u32 = 5381;
    for byte in contract_id.bytes() {
        hash = hash.wrapping_mul(33).wrapping_add(byte as u32);
    }
    hash % 360
}

/// Convert HSL to a hex color string.
fn hsl_to_hex(h: u32, s: f64, l: f64) -> String {
    let h = h as f64 / 360.0;
    let (r, g, b) = if s == 0.0 {
        (l, l, l)
    } else {
        let q = if l < 0.5 {
            l * (1.0 + s)
        } else {
            l + s - l * s
        };
        let p = 2.0 * l - q;
        (
            hue_to_rgb(p, q, h + 1.0 / 3.0),
            hue_to_rgb(p, q, h),
            hue_to_rgb(p, q, h - 1.0 / 3.0),
        )
    };

    let ri = (r * 255.0).round() as u8;
    let gi = (g * 255.0).round() as u8;
    let bi = (b * 255.0).round() as u8;
    format!("#{:02x}{:02x}{:02x}", ri, gi, bi)
}

fn hue_to_rgb(p: f64, q: f64, mut t: f64) -> f64 {
    if t < 0.0 {
        t += 1.0;
    }
    if t > 1.0 {
        t -= 1.0;
    }
    if t < 1.0 / 6.0 {
        return p + (q - p) * 6.0 * t;
    }
    if t < 1.0 / 2.0 {
        return q;
    }
    if t < 2.0 / 3.0 {
        return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
    }
    p
}
