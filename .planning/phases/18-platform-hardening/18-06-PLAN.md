---
phase: 18-platform-hardening
plan: 06
type: execute
wave: 2
depends_on:
  - "18-05"
files_modified:
  - crates/cli/Cargo.toml
  - crates/cli/src/serve.rs
  - crates/cli/src/main.rs
  - Cargo.toml
autonomous: true
requirements:
  - HARD-06
  - HARD-08
  - HARD-09
must_haves:
  truths:
    - "HTTP server uses axum with tokio async runtime for concurrent request handling"
    - "Optional TLS support via axum-server with rustls -- enabled by --tls-cert and --tls-key CLI flags"
    - "libc dependency is removed from tenor-cli Cargo.toml -- no unsafe signal handling"
    - "Signal handling uses ctrlc or tokio::signal instead of raw libc::signal()"
    - "tenor-core and tenor-eval remain free of libc/OS dependencies"
  artifacts:
    - path: "crates/cli/src/serve.rs"
      provides: "Production-grade HTTP server with axum + tokio"
      contains: "axum"
    - path: "crates/cli/Cargo.toml"
      provides: "Dependencies updated: axum, tokio added; tiny_http, libc removed"
  key_links:
    - from: "crates/cli/src/serve.rs"
      to: "crates/eval/src/lib.rs"
      via: "evaluate() called from async handler"
      pattern: "tenor_eval::evaluate"
    - from: "crates/cli/src/serve.rs"
      to: "crates/core/src/elaborate.rs"
      via: "elaborate() called from async handler"
      pattern: "tenor_core::elaborate"
---

<objective>
Replace the entire HTTP stack: swap tiny_http for axum + tokio, remove libc dependency, and replace unsafe signal handling with safe alternatives.

Purpose: The current serve.rs is a single-threaded synchronous server using tiny_http with unsafe libc signal handlers -- unsuitable for the Hosted Evaluator Service (Phase 22). This plan replaces it with a production-grade async HTTP framework that supports concurrent requests, while isolating the libc dependency from the crate graph (WASM prerequisite for Phase 21).

Output: Production-ready HTTP server in serve.rs using axum + tokio, with safe graceful shutdown.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md
@crates/cli/src/serve.rs
@crates/cli/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace HTTP stack with axum + tokio and remove libc</name>
  <files>
    Cargo.toml
    crates/cli/Cargo.toml
    crates/cli/src/serve.rs
    crates/cli/src/main.rs
  </files>
  <action>
Rewrite `crates/cli/src/serve.rs` (currently 521 lines using tiny_http) to use axum + tokio:

**Step 1: Update dependencies**

In root `Cargo.toml` `[workspace.dependencies]`:
- Add: `axum = "0.8"`, `tokio = { version = "1", features = ["full"] }`
- Remove: `tiny_http = "0.12"`, `libc = "0.2"` (if no other workspace member uses them)

In `crates/cli/Cargo.toml`:
- Add: `axum = { workspace = true }`, `tokio = { workspace = true }`
- Remove: `tiny_http = { workspace = true }`, `libc = { workspace = true }`

**Step 2: Rewrite serve.rs**

Replace the entire file with an axum-based implementation. Maintain the same API contract (same endpoints, same request/response formats):

1. **Shared state**: Replace `Arc<Mutex<ServeState>>` with axum's `State(Arc<AppState>)` extractor. Use `RwLock` instead of `Mutex` so reads (GET endpoints) don't block each other. Pre-elaborate contracts at startup (same as current behavior).

2. **Router**:
```rust
let app = Router::new()
    .route("/health", get(handle_health))
    .route("/contracts", get(handle_list_contracts))
    .route("/contracts/{id}/operations", get(handle_get_operations))
    .route("/elaborate", post(handle_elaborate))
    .route("/evaluate", post(handle_evaluate))
    .route("/explain", post(handle_explain))
    .with_state(state);
```

3. **Handlers**: Convert each existing handler to an async axum handler function. Use `axum::extract::Json` for request/response bodies. Use `axum::extract::Path` for URL parameters. Return `(StatusCode, Json<Value>)` tuples.

4. **Body size limit**: Use `axum::extract::DefaultBodyLimit::max(10 * 1024 * 1024)` as a layer (preserving the current 10MB limit).

5. **Graceful shutdown**: Use `tokio::signal::ctrl_c()` for graceful shutdown instead of unsafe libc signal handlers:
```rust
let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", port)).await?;
axum::serve(listener, app)
    .with_graceful_shutdown(shutdown_signal())
    .await?;
```

6. **Entry point**: The `start_server()` function needs to be async. In `main.rs`, wrap the serve command dispatch in `tokio::runtime::Runtime::new()` to create a runtime:
```rust
Commands::Serve { port, contracts } => {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(serve::start_server(port, contracts, output, quiet))?;
}
```

Keep the rest of `main.rs` synchronous -- only the serve subcommand uses tokio.

**Step 2b: Optional TLS support (HARD-08 TLS clause)**

Add optional TLS via `axum-server` with `rustls`:

1. Add `axum-server = { version = "0.7", features = ["tls-rustls"] }` to workspace dependencies and `crates/cli/Cargo.toml` (as an optional feature: `tls = ["axum-server/tls-rustls"]`).

2. Add `--tls-cert <path>` and `--tls-key <path>` optional CLI flags to the `serve` subcommand in `main.rs`. Both must be provided together or neither.

3. In `serve.rs`, branch on whether TLS config is provided:
```rust
if let (Some(cert_path), Some(key_path)) = (&tls_cert, &tls_key) {
    let config = RustlsConfig::from_pem_file(cert_path, key_path).await?;
    axum_server::bind_rustls(addr, config)
        .serve(app.into_make_service())
        .await?;
} else {
    // Plain HTTP (existing path)
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;
}
```

4. When TLS is active, log the listening URL as `https://` instead of `http://`.

This satisfies HARD-08's TLS requirement. In production deployments, TLS can alternatively be handled at the reverse-proxy layer (nginx, Caddy), but the server itself supports native TLS for standalone deployments.

7. **Elaborate handler**: Still writes to tempfile, still calls `tenor_core::elaborate::elaborate()`. Run the CPU-intensive elaboration in `tokio::task::spawn_blocking()` to avoid blocking the async runtime.

8. **Evaluate handler**: Similarly use `spawn_blocking()` for `tenor_eval::evaluate()` and `tenor_eval::evaluate_flow()`.

**Step 3: Verify libc isolation**

After the rewrite:
- `grep -r 'libc' crates/` should only return results in tests or comments, not in production code
- `cargo tree -p tenor-core -i libc` should show no dependency
- `cargo tree -p tenor-eval -i libc` should show no dependency

**Step 4: Update serve_integration.rs**

The integration tests in `crates/cli/tests/serve_integration.rs` should continue to work since they use raw HTTP requests. The server now starts asynchronously but the test pattern (spawn process, send HTTP, check response) is unchanged.
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build --workspace` succeeds. `cargo test --workspace` passes. Serve integration tests pass (`cargo test -p tenor-cli --test serve_integration`). `cargo clippy --workspace -- -D warnings` clean. `grep -rn 'unsafe' crates/cli/src/serve.rs` returns no results. `grep -rn 'libc' crates/cli/Cargo.toml` returns no results. `cargo build -p tenor-cli --features tls` succeeds (TLS feature compiles).
  </verify>
  <done>serve.rs uses axum + tokio for concurrent async request handling with optional TLS via --tls-cert/--tls-key flags. libc dependency removed. Signal handling uses tokio::signal. All serve integration tests pass. No unsafe code remains in serve.rs.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- formatting clean
2. `cargo build --workspace` compiles cleanly
3. `cargo test --workspace` -- all tests pass including serve_integration tests
4. `cargo run -p tenor-cli -- test conformance` -- all 73 tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. `cargo tree -p tenor-core -i libc 2>&1` -- "libc not found" (no libc dependency)
7. `cargo tree -p tenor-eval -i libc 2>&1` -- "libc not found"
8. No `unsafe` blocks in serve.rs
9. `cargo build -p tenor-cli --features tls` -- TLS feature compiles
10. Docker build still works (`docker build .` succeeds)
</verification>

<success_criteria>
- serve.rs uses axum + tokio for production-grade HTTP
- Concurrent request handling (not single-threaded)
- Optional TLS support via --tls-cert/--tls-key flags (axum-server + rustls)
- libc dependency removed from tenor-cli
- No unsafe code in serve.rs
- Graceful shutdown via tokio::signal
- All existing endpoints preserved with identical API contract
- All serve integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-platform-hardening/18-06-SUMMARY.md`
</output>
