---
phase: 18-platform-hardening
plan: 04
type: execute
wave: 2
depends_on:
  - "18-01"
files_modified:
  - crates/eval/src/types.rs
  - crates/eval/src/rules.rs
  - crates/eval/src/flow.rs
autonomous: true
requirements:
  - HARD-13
  - HARD-17
  - HARD-18
must_haves:
  truths:
    - "Contract type uses HashMap indexes for O(1) lookups by ID on operations, flows, entities, and rules"
    - "Stratum rule evaluation uses BTreeMap<u32, Vec<&Rule>> instead of O(k*n) double scan"
    - "Flow execution avoids unnecessary deep clones of steps_executed and entity_changes vectors"
  artifacts:
    - path: "crates/eval/src/types.rs"
      provides: "HashMap-indexed Contract type"
      contains: "HashMap"
    - path: "crates/eval/src/rules.rs"
      provides: "Indexed stratum evaluation"
      contains: "BTreeMap"
    - path: "crates/eval/src/flow.rs"
      provides: "Clone-free flow execution"
  key_links:
    - from: "crates/eval/src/rules.rs"
      to: "crates/eval/src/types.rs"
      via: "Uses indexed Contract fields"
      pattern: "stratum_index"
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/types.rs"
      via: "FlowResult construction without intermediate clones"
      pattern: "FlowResult"
---

<objective>
Optimize the evaluator runtime: add HashMap indexes to Contract for O(1) lookups, index stratum rule evaluation, and eliminate unnecessary deep clones in flow execution.

Purpose: These performance improvements matter for the Hosted Evaluator Service (Phase 22) where evaluation latency directly impacts API response times. The O(k*n) stratum scan and per-failure vector cloning are the two most impactful bottlenecks identified in the codebase mapping.

Output: Faster evaluation with indexed lookups and reduced allocation overhead.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md
@crates/eval/src/types.rs
@crates/eval/src/rules.rs
@crates/eval/src/flow.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HashMap indexes to Contract type</name>
  <files>
    crates/eval/src/types.rs
  </files>
  <action>
Add HashMap indexes to the `Contract` struct for O(1) lookups:

1. **Add index fields** to `Contract` (in `crates/eval/src/types.rs`):
```rust
pub struct Contract {
    // Existing Vec fields:
    pub facts: Vec<FactDecl>,
    pub entities: Vec<Entity>,
    pub rules: Vec<Rule>,
    pub operations: Vec<Operation>,
    pub flows: Vec<Flow>,
    // ... other existing fields ...

    // NEW: HashMap indexes (populated in from_interchange)
    pub operation_index: HashMap<String, usize>,  // operation_id -> index in operations Vec
    pub flow_index: HashMap<String, usize>,        // flow_id -> index in flows Vec
    pub entity_index: HashMap<String, usize>,      // entity_id -> index in entities Vec
    pub fact_index: HashMap<String, usize>,         // fact_id -> index in facts Vec
}
```

2. **Populate indexes in from_interchange()**: After deserializing the Vec collections, build the HashMap indexes:
```rust
let operation_index: HashMap<String, usize> = contract.operations.iter()
    .enumerate()
    .map(|(i, op)| (op.id.clone(), i))
    .collect();
```

3. **Add lookup methods**:
```rust
impl Contract {
    pub fn get_operation(&self, id: &str) -> Option<&Operation> {
        self.operation_index.get(id).map(|&i| &self.operations[i])
    }
    pub fn get_flow(&self, id: &str) -> Option<&Flow> {
        self.flow_index.get(id).map(|&i| &self.flows[i])
    }
    pub fn get_entity(&self, id: &str) -> Option<&Entity> {
        self.entity_index.get(id).map(|&i| &self.entities[i])
    }
    pub fn get_fact(&self, id: &str) -> Option<&FactDecl> {
        self.fact_index.get(id).map(|&i| &self.facts[i])
    }
}
```

4. **Migrate callers**: Search for `.iter().find(|x| x.id == ...)` patterns across the eval crate and replace with the new lookup methods.

5. **Add `use std::collections::HashMap`** at the top of the file if not already present.
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build -p tenor-eval` succeeds. `cargo test -p tenor-eval` passes (all ~125 tests). `cargo clippy -p tenor-eval -- -D warnings` clean.
  </verify>
  <done>Contract type has HashMap indexes. All .iter().find() lookups replaced with O(1) HashMap lookups. All eval tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Index stratum evaluation and eliminate flow deep clones</name>
  <files>
    crates/eval/src/rules.rs
    crates/eval/src/flow.rs
  </files>
  <action>
**rules.rs -- Indexed stratum evaluation (HARD-17):**

In `eval_strata()` in `crates/eval/src/rules.rs`:

1. Replace the current double-scan approach (iterate all rules to find max_stratum, then iterate per stratum) with a pre-built index:
```rust
use std::collections::BTreeMap;

// Build stratum index once
let mut stratum_index: BTreeMap<u32, Vec<&Rule>> = BTreeMap::new();
for rule in &contract.rules {
    stratum_index.entry(rule.stratum).or_default().push(rule);
}

// Evaluate in stratum order (BTreeMap iterates in key order)
for (stratum, rules) in &stratum_index {
    for rule in rules {
        // ... existing rule evaluation logic ...
    }
}
```

This eliminates the O(k*n) scan where k = number of strata and n = total rules. Now it's O(n) to build + O(n) to evaluate.

**flow.rs -- Eliminate unnecessary deep clones (HARD-18):**

In `handle_failure()` in `crates/eval/src/flow.rs` (lines ~101-106):

1. Identify the vector cloning: `steps_executed.clone()` and `entity_changes_all.clone()` when building intermediate `FlowResult` values.

2. Refactor the flow execution to use a shared accumulator pattern:
   - Instead of cloning vectors for each intermediate FlowResult, collect results in references or indices
   - Build the final FlowResult only at the function's actual return sites
   - If intermediate FlowResult values are only used for early returns, consider using `Cow<[T]>` or building FlowResult lazily

3. Alternative simpler approach if full refactor is too invasive: use `std::mem::take()` instead of `clone()` at return sites where the accumulator is no longer needed (i.e., the last use of the vectors).

4. Profile the change: The key metric is that the existing `#[test]` functions in flow.rs continue to pass and flow conformance tests produce identical results.

Be conservative with the flow.rs changes -- flow execution correctness is more important than optimization. If the clone elimination is too risky, settle for the simpler `take()` approach.
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build --workspace` succeeds. `cargo test --workspace` passes. `cargo run -p tenor-cli -- test conformance` passes. Flow evaluator conformance tests in `crates/eval/tests/conformance.rs` all pass. `cargo clippy --workspace -- -D warnings` clean.
  </verify>
  <done>Stratum evaluation uses BTreeMap index (O(n) instead of O(k*n)). Flow execution avoids unnecessary vector clones. All tests pass unchanged.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- formatting clean
2. `cargo build --workspace` compiles cleanly
3. `cargo test --workspace` -- all tests pass
4. `cargo run -p tenor-cli -- test conformance` -- all 73 conformance tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. `grep -n 'HashMap' crates/eval/src/types.rs` -- HashMap indexes present
7. `grep -n 'BTreeMap' crates/eval/src/rules.rs` -- BTreeMap stratum index present
</verification>

<success_criteria>
- Contract uses HashMap indexes for O(1) lookups
- Stratum evaluation uses indexed BTreeMap instead of double-scan
- Flow execution eliminates unnecessary deep clones
- All 508+ tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/18-platform-hardening/18-04-SUMMARY.md`
</output>
