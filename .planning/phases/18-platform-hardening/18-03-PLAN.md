---
phase: 18-platform-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/elaborate.rs
  - crates/core/src/pass1_bundle.rs
  - crates/core/src/lib.rs
  - crates/core/src/parser.rs
  - crates/core/src/lexer.rs
  - crates/core/src/error.rs
autonomous: true
requirements:
  - HARD-04
  - HARD-05
must_haves:
  truths:
    - "Parser reports multiple errors per parse (up to a configurable limit) instead of aborting on the first error"
    - "elaborate() can be called without filesystem access by providing a SourceProvider trait implementation"
    - "Existing file-based elaborate() continues to work unchanged for CLI users"
  artifacts:
    - path: "crates/core/src/parser.rs"
      provides: "Multi-error parser with error recovery at construct boundaries"
      contains: "Vec<ElabError>"
    - path: "crates/core/src/elaborate.rs"
      provides: "SourceProvider trait and elaborate_from_source() entry point"
      contains: "SourceProvider"
    - path: "crates/core/src/pass1_bundle.rs"
      provides: "SourceProvider-based file loading"
      contains: "SourceProvider"
  key_links:
    - from: "crates/core/src/elaborate.rs"
      to: "crates/core/src/pass1_bundle.rs"
      via: "SourceProvider passed through elaborate pipeline"
      pattern: "SourceProvider"
    - from: "crates/core/src/parser.rs"
      to: "crates/core/src/error.rs"
      via: "Vec<ElabError> collected during recovery"
      pattern: "Vec<ElabError>"
---

<objective>
Add multi-error reporting to the parser and factor file I/O behind a trait so the elaborator can work without filesystem access (WASM prerequisite).

Purpose: Parser error recovery improves developer experience (especially in LSP) by reporting multiple diagnostics per parse instead of stopping at the first error. The SourceProvider trait enables WASM compilation where `std::fs` is unavailable -- a hard prerequisite for Phase 21 (Embedded Evaluator).

Output: Parser with error recovery at construct boundaries; SourceProvider trait for filesystem abstraction.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md
@crates/core/src/parser.rs
@crates/core/src/elaborate.rs
@crates/core/src/pass1_bundle.rs
@crates/core/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error recovery to parser for multi-error reporting</name>
  <files>
    crates/core/src/parser.rs
    crates/core/src/error.rs
  </files>
  <action>
Modify the parser to recover from errors at construct boundaries and report multiple diagnostics:

1. **Error collection**: Change the parser's internal state to accumulate a `Vec<ElabError>` instead of returning `Err` on the first error. Add a `max_errors` limit (default 10) to prevent runaway error cascades.

2. **Recovery strategy**: When an error is encountered inside a construct body (between `{` and `}`), the parser should:
   - Record the error in the error vector
   - Skip tokens until it finds a closing `}` at the same nesting level, or a top-level keyword (`fact`, `entity`, `rule`, `operation`, `flow`, `type`, `persona`, `system`, `import`)
   - Resume parsing from the recovered position
   - Mark the skipped construct as invalid (do not include it in the parse output)

3. **Parse return type**: Change the parse function signature to return `Result<(Vec<RawConstruct>, Vec<ElabError>), ElabError>`:
   - If any constructs parsed successfully + some errors: return `Ok((constructs, errors))`
   - If a fatal error occurs that prevents any recovery (e.g., completely malformed file): return `Err(single_error)`
   - If no errors: return `Ok((constructs, vec![]))`

4. **Integration with pass1_bundle.rs**: In `load_bundle()`, after calling the parser, check the error vector. If non-empty and the caller wants all errors, collect them. For backward compatibility, keep the first-error-wins behavior as default: if there are errors, return the first one. Add an internal flag or parameter to opt into multi-error mode.

5. **ElabError changes** (`error.rs`): No changes to the ElabError struct itself. The multi-error capability is at the collection level.

6. **Testing**: Add at least 2 unit tests in parser.rs:
   - A file with 2 distinct construct errors should report both
   - A file with a fatal lexer error should still abort immediately
   - A file with one valid construct and one invalid should parse the valid one

IMPORTANT: The existing single-error behavior MUST be preserved for the main `elaborate()` path. The multi-error mode is opt-in (for LSP use).
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build -p tenor-core` succeeds. `cargo test -p tenor-core` passes. `cargo run -p tenor-cli -- test conformance` passes (all 73 tests -- single-error behavior preserved). New parser unit tests pass.
  </verify>
  <done>Parser recovers at construct boundaries and can report multiple errors. Single-error behavior preserved for backward compatibility. At least 2 new unit tests verify recovery.</done>
</task>

<task type="auto">
  <name>Task 2: Factor file I/O behind SourceProvider trait for WASM readiness</name>
  <files>
    crates/core/src/elaborate.rs
    crates/core/src/pass1_bundle.rs
    crates/core/src/lib.rs
  </files>
  <action>
Factor the filesystem-dependent code in pass1_bundle.rs behind a trait so elaborate() can work without `std::fs`:

1. **Define the trait** in `crates/core/src/elaborate.rs` (or a new `source.rs` module):
```rust
pub trait SourceProvider {
    /// Read the source text for a given path. Returns the content as a String.
    fn read_source(&self, path: &Path) -> Result<String, std::io::Error>;

    /// Resolve a relative import path against a base path.
    fn resolve_import(&self, base: &Path, import: &str) -> Result<PathBuf, std::io::Error>;

    /// Canonicalize a path for cycle detection.
    fn canonicalize(&self, path: &Path) -> Result<PathBuf, std::io::Error>;
}
```

2. **FileSystemProvider**: Create a default implementation that wraps `std::fs::read_to_string`, `Path::join`, and `Path::canonicalize`. This is what the existing `elaborate(&Path)` function uses.

3. **InMemoryProvider**: Create a simple in-memory implementation that maps paths to strings. This will be used for WASM and testing. Structure: `HashMap<PathBuf, String>`.

4. **Refactor pass1_bundle.rs**: Change `load_bundle(root_path: &Path)` to accept a `&dyn SourceProvider` parameter. Replace all `std::fs::read_to_string()` and `Path::canonicalize()` calls with calls to the provider.

5. **Refactor elaborate.rs**:
   - Add `pub fn elaborate_with_provider(root_path: &Path, provider: &dyn SourceProvider) -> Result<Value, ElabError>`
   - Keep existing `pub fn elaborate(root_path: &Path) -> Result<Value, ElabError>` as a convenience wrapper that creates a `FileSystemProvider` and delegates.

6. **Re-exports**: In `crates/core/src/lib.rs`, add `pub use elaborate::{SourceProvider, FileSystemProvider, InMemoryProvider}`.

7. **Test**: Add a unit test that uses `InMemoryProvider` to elaborate a simple contract from memory without touching the filesystem.

IMPORTANT: The existing `elaborate(&Path)` signature MUST continue to work. This is a non-breaking addition.
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build --workspace` succeeds. `cargo test --workspace` passes. `cargo run -p tenor-cli -- test conformance` passes. The InMemoryProvider test proves WASM-compatible elaboration works.
  </verify>
  <done>SourceProvider trait exists. FileSystemProvider wraps existing behavior. InMemoryProvider enables WASM. Existing elaborate(&Path) API unchanged. Unit test proves in-memory elaboration.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- formatting clean
2. `cargo build --workspace` compiles cleanly
3. `cargo test --workspace` -- all tests pass including new parser and SourceProvider tests
4. `cargo run -p tenor-cli -- test conformance` -- all 73 tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. Parser can report >1 error on a file with multiple construct errors
7. InMemoryProvider test proves elaboration works without filesystem
</verification>

<success_criteria>
- Parser recovers from errors at construct boundaries, reports multiple diagnostics
- SourceProvider trait abstracts file I/O, with FileSystemProvider (default) and InMemoryProvider
- Existing elaborate(&Path) API unchanged -- fully backward compatible
- All 508+ tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/18-platform-hardening/18-03-SUMMARY.md`
</output>
