---
phase: 18-platform-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/interchange/Cargo.toml
  - crates/interchange/src/lib.rs
  - crates/interchange/src/types.rs
  - crates/interchange/src/deserialize.rs
  - Cargo.toml
  - crates/eval/Cargo.toml
  - crates/eval/src/types.rs
  - crates/analyze/Cargo.toml
  - crates/analyze/src/bundle.rs
  - crates/codegen/Cargo.toml
  - crates/codegen/src/bundle.rs
autonomous: true
requirements:
  - HARD-01
  - HARD-27
must_haves:
  truths:
    - "A single `tenor-interchange` crate provides typed deserialization of interchange JSON bundles"
    - "eval, analyze, and codegen all depend on tenor-interchange instead of hand-rolling their own parsers"
    - "Changing an interchange field requires editing one crate, not three"
  artifacts:
    - path: "crates/interchange/src/lib.rs"
      provides: "Public API for shared interchange types"
    - path: "crates/interchange/src/types.rs"
      provides: "Typed structs for all interchange constructs (Facts, Entities, Rules, Operations, Flows, Personas, Systems)"
    - path: "crates/interchange/src/deserialize.rs"
      provides: "from_interchange() deserialization from serde_json::Value"
  key_links:
    - from: "crates/eval/src/types.rs"
      to: "crates/interchange/src/types.rs"
      via: "use tenor_interchange::"
      pattern: "tenor_interchange"
    - from: "crates/analyze/src/bundle.rs"
      to: "crates/interchange/src/types.rs"
      via: "use tenor_interchange::"
      pattern: "tenor_interchange"
    - from: "crates/codegen/src/bundle.rs"
      to: "crates/interchange/src/types.rs"
      via: "use tenor_interchange::"
      pattern: "tenor_interchange"
---

<objective>
Create a shared `tenor-interchange` crate that provides typed deserialization of TenorInterchange JSON bundles, replacing the triplicated parsing code in eval, analyze, and codegen.

Purpose: Eliminate the triple-maintenance burden where any interchange format change must be synchronized across three independent deserializers (eval/types.rs:314-361, analyze/bundle.rs:1-774, codegen/bundle.rs:126-365). This is also the prerequisite for Rust and Go SDKs in Phase 24, which need a formalized interchange schema library.

Output: New `crates/interchange/` crate with shared types, and all three consumer crates refactored to depend on it.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md
@crates/eval/src/types.rs
@crates/analyze/src/bundle.rs
@crates/codegen/src/bundle.rs
@docs/interchange-schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tenor-interchange crate with shared types and deserialization</name>
  <files>
    Cargo.toml
    crates/interchange/Cargo.toml
    crates/interchange/src/lib.rs
    crates/interchange/src/types.rs
    crates/interchange/src/deserialize.rs
  </files>
  <action>
Create a new `crates/interchange/` crate:

1. Add `"crates/interchange"` to workspace members in root `Cargo.toml`.
2. Create `crates/interchange/Cargo.toml` with dependencies: `serde = { workspace = true }`, `serde_json = { workspace = true }`, `rust_decimal = { workspace = true }`. Name: `tenor-interchange`.
3. Create `crates/interchange/src/types.rs` with typed structs representing the interchange JSON schema. Study all three existing deserializers to find the union of all fields consumed:
   - From `crates/eval/src/types.rs`: `Contract`, `FactDecl`, `Entity`, `Rule`, `Operation`, `Flow`, `TypeSpec`, `Predicate`, `Step`, etc.
   - From `crates/analyze/src/bundle.rs`: `AnalysisBundle`, `AnalysisEntity`, `AnalysisFact`, `AnalysisRule`, etc.
   - From `crates/codegen/src/bundle.rs`: `CodegenBundle`, `CodegenFact`, `CodegenEntity`, etc.
   The shared types should cover the superset. Use `#[derive(Debug, Clone, Serialize, Deserialize)]` with `serde(rename_all = "snake_case")` where appropriate. Use `serde_json::Value` for fields that only some consumers use (keep it pragmatic -- don't force every consumer to parse every nested field).
4. Create `crates/interchange/src/deserialize.rs` with a `pub fn from_interchange(bundle: &serde_json::Value) -> Result<InterchangeBundle, InterchangeError>` function that performs typed deserialization. Handle missing fields with descriptive error messages.
5. Create `crates/interchange/src/lib.rs` that re-exports the public API.

Key design decisions:
- The interchange types should use `serde_json::Value` for deeply nested expression trees (predicates, expressions) since each consumer interprets these differently. Only the top-level construct structure needs shared types.
- Include `Provenance { file: String, line: u64 }` as a shared type.
- Use `Option<T>` for fields that are present only on some construct kinds.
- The `InterchangeBundle` top-level type should have: `id: String`, `tenor: String`, `tenor_version: String`, `constructs: Vec<InterchangeConstruct>`.
- `InterchangeConstruct` should be an enum with variants for each kind (Fact, Entity, Rule, Operation, Flow, Persona, System, TypeDecl).
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build -p tenor-interchange` succeeds. `cargo test -p tenor-interchange` passes (add at least 3 unit tests: deserialize a minimal bundle, handle missing fields, round-trip a construct).
  </verify>
  <done>New `tenor-interchange` crate builds, has typed structs for all interchange constructs, and deserializes interchange JSON correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate eval, analyze, and codegen to use tenor-interchange</name>
  <files>
    crates/eval/Cargo.toml
    crates/eval/src/types.rs
    crates/analyze/Cargo.toml
    crates/analyze/src/bundle.rs
    crates/codegen/Cargo.toml
    crates/codegen/src/bundle.rs
  </files>
  <action>
Refactor each consumer crate to depend on `tenor-interchange` instead of hand-rolling deserialization:

1. **tenor-eval** (`crates/eval/Cargo.toml`): Add `tenor-interchange = { path = "../interchange" }`. In `crates/eval/src/types.rs`, replace the `Contract::from_interchange()` method to use `tenor_interchange::from_interchange()` for initial parsing, then convert shared types to eval-specific runtime types (the eval crate still needs its own `Value` enum, `FactSet`, `VerdictSet`, etc. -- only the *deserialization from JSON* is shared). Remove the duplicated JSON traversal code (the `from_interchange` impl that manually walks `serde_json::Value`).

2. **tenor-analyze** (`crates/analyze/Cargo.toml`): Add `tenor-interchange = { path = "../interchange" }`. In `crates/analyze/src/bundle.rs`, replace `AnalysisBundle::from_interchange()` to use shared types for initial parsing, then convert to analysis-specific types where needed. The analysis crate may be able to use shared types directly for many constructs (facts, entities).

3. **tenor-codegen** (`crates/codegen/Cargo.toml`): Add `tenor-interchange = { path = "../interchange" }`. In `crates/codegen/src/bundle.rs`, replace `CodegenBundle::from_interchange()` similarly.

For each crate:
- Keep crate-specific types that add domain behavior (e.g., eval's `Value` enum, `FactSet`, rule evaluation logic).
- Replace only the JSON deserialization code that duplicates interchange parsing.
- Ensure the existing public API (`evaluate()`, `analyze()`, `generate_typescript()`) continues to accept `&serde_json::Value` -- the shared deserialization is an internal implementation detail.
- Run crate-specific tests after each migration to catch regressions immediately.

IMPORTANT: Do NOT change the public API signatures. External callers still pass `&serde_json::Value`. The shared crate is used internally.
  </action>
  <verify>
    `cargo fmt --all` passes. `cargo build --workspace` succeeds. `cargo test --workspace` passes. `cargo run -p tenor-cli -- test conformance` passes (all 73 tests). `cargo clippy --workspace -- -D warnings` clean.
  </verify>
  <done>All three consumer crates use `tenor-interchange` for interchange JSON deserialization. No triplicated parsing code remains. All existing tests pass unchanged.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- formatting clean
2. `cargo build --workspace` -- all crates compile including new `tenor-interchange`
3. `cargo test --workspace` -- all existing tests pass (no regressions)
4. `cargo run -p tenor-cli -- test conformance` -- all 73 conformance tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. Grep for `from_interchange` in eval, analyze, codegen -- each should delegate to `tenor-interchange` types
</verification>

<success_criteria>
- `tenor-interchange` crate exists with typed structs for all interchange construct kinds
- eval, analyze, and codegen all depend on `tenor-interchange`
- No more triplicated JSON deserialization logic
- All 508+ existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/18-platform-hardening/18-01-SUMMARY.md`
</output>
