---
phase: 15-typescript-agent-sdk-client-to-rust-evaluator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
  - crates/cli/src/serve.rs
  - crates/cli/src/explain.rs
autonomous: true
requirements:
  - SDK-03
  - SDK-01

must_haves:
  truths:
    - "`tenor serve` starts an HTTP server on a configurable port"
    - "POST /elaborate accepts .tenor source text and returns interchange JSON"
    - "POST /evaluate accepts bundle + facts and returns verdicts JSON"
    - "POST /evaluate with flow_id and persona returns flow execution result"
    - "POST /explain accepts bundle and returns explain output"
    - "GET /contracts lists loaded contract bundles"
    - "GET /contracts/:id/operations returns operation list for a contract"
    - "GET /health returns server status"
    - "Server shuts down cleanly on SIGINT/SIGTERM"
  artifacts:
    - path: "crates/cli/src/serve.rs"
      provides: "HTTP server implementation with all API routes"
      min_lines: 200
    - path: "crates/cli/src/main.rs"
      provides: "Serve subcommand registration"
      contains: "Serve"
  key_links:
    - from: "crates/cli/src/serve.rs"
      to: "tenor_core::elaborate::elaborate"
      via: "elaborate endpoint handler"
      pattern: "tenor_core::elaborate"
    - from: "crates/cli/src/serve.rs"
      to: "tenor_eval::evaluate"
      via: "evaluate endpoint handler"
      pattern: "tenor_eval::evaluate"
    - from: "crates/cli/src/serve.rs"
      to: "tenor_eval::evaluate_flow"
      via: "flow evaluate endpoint handler"
      pattern: "tenor_eval::evaluate_flow"
---

<objective>
Implement `tenor serve` — an HTTP JSON API server that exposes the Rust elaborator and evaluator as a network service. This is the foundation the TypeScript SDK will connect to.

Purpose: The SDK needs a running evaluator process to connect to. `tenor serve` provides that process with a clean HTTP API, keeping all trust-critical evaluation logic in Rust.

Output: A working `tenor serve` CLI subcommand that starts an HTTP server, accepts contract elaboration and evaluation requests, and returns JSON responses.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files
@crates/cli/src/main.rs
@crates/cli/Cargo.toml
@crates/eval/src/lib.rs
@crates/eval/src/types.rs
@crates/core/src/elaborate.rs
@crates/cli/src/explain.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HTTP server dependencies and Serve subcommand skeleton</name>
  <files>
    Cargo.toml
    crates/cli/Cargo.toml
    crates/cli/src/main.rs
    crates/cli/src/serve.rs
  </files>
  <action>
Add `tiny_http` as a workspace dependency in the root `Cargo.toml` (version "0.12", synchronous HTTP server — matches the project's no-async-runtime convention). Add it to `crates/cli/Cargo.toml` dependencies.

Rationale for `tiny_http` over alternatives: The entire codebase is synchronous (no async runtime). Using axum/actix would require tokio, pulling in a massive dependency tree. `tiny_http` is a minimal, synchronous HTTP server that fits the existing architecture. If `tiny_http` causes issues, `rouille` (which wraps `tiny_http`) is the fallback. Do NOT use an async framework.

Create `crates/cli/src/serve.rs` with:

1. A `ServeState` struct holding:
   - `contracts: HashMap<String, serde_json::Value>` — loaded contract bundles keyed by bundle ID
   - A `Mutex` around state for thread safety (tiny_http is multi-threaded)

2. A `start_server(port: u16, contract_paths: Vec<PathBuf>)` function that:
   - Pre-loads contracts: for each path, calls `tenor_core::elaborate::elaborate()` to get the interchange JSON, stores in state by bundle ID
   - Binds `tiny_http::Server` to `0.0.0.0:{port}`
   - Prints `Tenor evaluator listening on http://0.0.0.0:{port}` to stderr
   - Enters a request loop calling `handle_request()` for each incoming request
   - Handles SIGINT gracefully (Ctrl+C exits the loop)

3. A `handle_request()` function that routes by method + path:
   - `GET /health` -> `{"status": "ok", "version": "<TENOR_VERSION>"}`
   - `GET /contracts` -> list of loaded contract IDs with metadata
   - `GET /contracts/{id}/operations` -> operations from a specific contract bundle
   - `POST /elaborate` -> accepts `{"source": "<tenor source text>"}`, writes to temp file, elaborates, returns interchange JSON
   - `POST /evaluate` -> accepts `{"bundle_id": "...", "facts": {...}}`, evaluates, returns verdicts JSON
   - `POST /evaluate` with `flow_id` and `persona` fields -> calls `evaluate_flow`, returns flow result
   - `POST /explain` -> accepts `{"bundle_id": "..."}`, returns explain output as JSON
   - All other routes -> 404 JSON error

4. All responses use `Content-Type: application/json`. Errors return structured JSON: `{"error": "<message>"}` with appropriate HTTP status codes (400 for bad request, 404 for not found, 500 for internal errors).

5. Request body parsing: read the full body with a 10MB limit, parse as JSON.

In `crates/cli/src/main.rs`:
- Add `mod serve;`
- Add `Serve` variant to `Commands` enum with `#[arg(long, default_value = "8080")] port: u16` and `#[arg()] contracts: Vec<PathBuf>` (optional list of .tenor files to pre-load)
- Add match arm calling `serve::start_server(port, contracts)`

Note on version: import `TENOR_VERSION` from `tenor_core` (the centralized version constant from Phase 14.1).
  </action>
  <verify>
Run `cargo build --workspace` — must compile without errors.
Run `cargo clippy --workspace -- -D warnings` — must pass.
Run `cargo fmt --all` — must be clean.
Run `cargo test --workspace` — existing tests must still pass.
Run `cargo run -p tenor-cli -- serve --help` — must show help text with port and contracts arguments.

Runtime health check (confirms TENOR_VERSION from Phase 14.1 is wired correctly):
```bash
# Start server in background on a test port
cargo run -p tenor-cli -- serve --port 19090 &
SERVER_PID=$!
sleep 2
# Verify /health returns tenor_version field
HEALTH=$(curl -s http://localhost:19090/health)
echo "$HEALTH" | grep -q '"tenor_version"' || (kill $SERVER_PID; echo "FAIL: tenor_version missing from /health"; exit 1)
kill $SERVER_PID
```
  </verify>
  <done>
`tenor serve` subcommand exists, compiles, and shows help. Server binary builds without async runtime. GET /health returns a response containing `tenor_version`. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement all API route handlers and test with curl</name>
  <files>
    crates/cli/src/serve.rs
    crates/cli/tests/serve_integration.rs
  </files>
  <action>
Complete the route handler implementations in `serve.rs`:

**GET /health:**
Return `{"status": "ok", "tenor_version": "<version>"}`.

**GET /contracts:**
Return `{"contracts": [{"id": "bundle_id", "construct_count": N, "facts": [...], "operations": [...], "flows": [...]}]}` by iterating the loaded bundles and extracting construct summaries from the interchange JSON. Each entry lists fact IDs, operation IDs, and flow IDs found in the bundle's constructs array.

**GET /contracts/{id}/operations:**
For the specified bundle, extract all Operation constructs from the interchange JSON and return:
```json
{
  "operations": [
    {
      "id": "op_id",
      "allowed_personas": ["persona1"],
      "effects": [
        {"entity_id": "entity_id", "from": "state_a", "to": "state_b"}
      ],
      "preconditions_summary": "from_state -> to_state"
    }
  ]
}
```
Field names MUST match the interchange JSON exactly: `allowed_personas` (not `personas`), `effects` array with `entity_id`/`from`/`to` (not a single `entity` field). The Operation struct in `crates/eval/src/types.rs` has no `entity` field — entity information lives inside `effects[].entity_id`. Operations can have multiple effects targeting different entities, so flattening to a single `entity` field would lose information. Expose the effects array directly.

This is the `getOperations` agent skill — the operation list an agent sees when reading a contract.

**POST /elaborate:**
Accept `{"source": "<tenor source>", "filename": "optional.tenor"}`. Write source to a temp file (using `tempfile` crate, already a dev-dependency — add as regular dependency or use `std::fs::write` to a temp dir). Call `tenor_core::elaborate::elaborate()` on the temp file. Return the interchange JSON on success or `{"error": "...", "details": {...}}` on elaboration error (using `ElabError::to_json_value()`).

**POST /evaluate:**
Accept `{"bundle_id": "...", "facts": {...}, "flow_id": null, "persona": null}`.
- Look up bundle by ID from loaded contracts
- If `flow_id` is present (and `persona`), call `tenor_eval::evaluate_flow()`
- Otherwise call `tenor_eval::evaluate()`
- Return the verdict JSON (from `VerdictSet::to_json()`) or flow result JSON (matching the existing CLI JSON output format from `cmd_eval`)
- Return 404 if bundle_id not found, 400 if facts invalid

**POST /explain:**
Accept `{"bundle_id": "..."}`.
- Look up bundle by ID
- Run the explain logic (reuse the typed deserialization from `crates/cli/src/explain.rs` — extract the explain formatting into a function that returns a struct/JSON instead of printing to stdout)
- Return JSON explanation

For the explain endpoint, you will need to refactor `explain.rs` slightly: extract the core logic into a `pub fn explain_bundle(bundle: &serde_json::Value) -> Result<serde_json::Value, String>` function that returns JSON instead of printing. The existing `cmd_explain` then calls this function and formats for terminal/markdown. The serve endpoint calls it directly.

**Integration test file** (`crates/cli/tests/serve_integration.rs`):
Create a test that:
1. Starts `tenor serve` as a child process with `--port 0` (let OS pick a free port) or a high random port
2. Uses `ureq` (already a dependency) to make HTTP requests to the server
3. Tests GET /health returns 200
4. Tests POST /elaborate with a simple `.tenor` source returns valid interchange JSON
5. Tests POST /evaluate with a pre-loaded contract returns verdicts
6. Kills the child process on test completion

If starting a child process is complex, alternatively test the route handlers as unit tests by constructing mock Request objects. The integration test is preferable but unit tests of the handler logic are acceptable as fallback.

Follow the Rust pre-commit quality gates from CLAUDE.md before considering this task done.
  </action>
  <verify>
Run all five pre-commit quality gates:
```
cargo fmt --all
cargo build --workspace
cargo test --workspace
cargo run -p tenor-cli -- test conformance
cargo clippy --workspace -- -D warnings
```
All must pass.

Manual verification:
```
# Terminal 1: Start server with a sample contract
cargo run -p tenor-cli -- serve --port 9090 domains/saas/saas_subscription.tenor &

# Terminal 2: Test endpoints
curl http://localhost:9090/health
curl http://localhost:9090/contracts
curl -X POST http://localhost:9090/elaborate -d '{"source": "fact is_active : Bool from system.active"}'
curl -X POST http://localhost:9090/evaluate -d '{"bundle_id": "saas_subscription", "facts": {"plan_type": "pro", "monthly_seats": 5, "is_active": true, "annual_commitment": true, "account_age_days": 365, "current_mrr": {"amount": "500.00", "currency": "USD"}, "expansion_revenue": {"amount": "100.00", "currency": "USD"}}}'
```
  </verify>
  <done>
All API routes return correct JSON responses. GET /health returns version. GET /contracts lists loaded bundles. GET /contracts/:id/operations returns operation details. POST /elaborate compiles .tenor source. POST /evaluate returns verdicts. POST /explain returns explanation. Error responses are structured JSON with appropriate HTTP status codes. Integration or unit tests cover the happy paths.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles cleanly
2. `cargo test --workspace` passes (including new serve tests)
3. `cargo run -p tenor-cli -- test conformance` passes (no regressions)
4. `cargo clippy --workspace -- -D warnings` passes
5. `tenor serve --port 9090 domains/saas/saas_subscription.tenor` starts and responds to curl requests
6. All endpoints return valid JSON with correct Content-Type headers
7. Server exits cleanly on Ctrl+C
</verification>

<success_criteria>
- `tenor serve` command exists and starts an HTTP server
- All six API endpoints (health, contracts, operations, elaborate, evaluate, explain) work correctly
- Server pre-loads .tenor contracts specified on the command line
- All responses are JSON with proper error handling
- No async runtime introduced — server uses synchronous I/O
- All existing tests and conformance suite still pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-typescript-agent-sdk-client-to-rust-evaluator/15-01-SUMMARY.md`
</output>
