---
phase: 15-typescript-agent-sdk-client-to-rust-evaluator
plan: 02
type: execute
wave: 2
depends_on:
  - 15-01
files_modified:
  - sdk/typescript/package.json
  - sdk/typescript/tsconfig.json
  - sdk/typescript/src/index.ts
  - sdk/typescript/src/client.ts
  - sdk/typescript/src/types.ts
  - sdk/typescript/src/errors.ts
  - sdk/typescript/tests/client.test.ts
autonomous: true
requirements:
  - SDK-01
  - SDK-02

must_haves:
  truths:
    - "TypeScript SDK connects to a running `tenor serve` instance over HTTP"
    - "SDK exposes `getOperations(contractId)` returning typed operation list"
    - "SDK exposes `invoke(contractId, facts, options?)` returning typed verdicts"
    - "SDK exposes `explain(contractId)` returning typed explanation"
    - "SDK lists available contracts via `listContracts()`"
    - "SDK provides typed error classes for connection failures and evaluation errors"
    - "SDK passes `npm test` with all tests green"
    - "Package builds to both ESM and CJS"
  artifacts:
    - path: "sdk/typescript/src/client.ts"
      provides: "TenorClient class with all agent skill methods"
      min_lines: 100
    - path: "sdk/typescript/src/types.ts"
      provides: "TypeScript type definitions for SDK responses"
      min_lines: 50
    - path: "sdk/typescript/src/errors.ts"
      provides: "Typed error classes"
      min_lines: 20
    - path: "sdk/typescript/package.json"
      provides: "npm package configuration"
      contains: "tenor-sdk"
    - path: "sdk/typescript/tests/client.test.ts"
      provides: "Unit tests for SDK client"
      min_lines: 50
  key_links:
    - from: "sdk/typescript/src/client.ts"
      to: "crates/cli/src/serve.rs"
      via: "HTTP fetch calls to tenor serve API"
      pattern: "fetch.*(/health|/contracts|/elaborate|/evaluate|/explain)"
    - from: "sdk/typescript/src/types.ts"
      to: "crates/eval/src/types.rs"
      via: "TypeScript mirrors of Rust evaluation types"
      pattern: "(Verdict|EvalResult|FlowResult|Operation)"
---

<objective>
Implement the TypeScript SDK package (`@tenor-lang/sdk`) that provides a typed client for the `tenor serve` HTTP API. The SDK is the primary interface agents and developers use to interact with Tenor contracts.

Purpose: Developers and AI agents need a TypeScript-native way to interact with Tenor contracts — loading them, querying operations, invoking evaluation, and getting explanations. The SDK wraps the HTTP API with typed methods and ergonomic error handling.

Output: A publishable npm package at `sdk/typescript/` with typed client, comprehensive type definitions, error classes, and passing tests.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-typescript-agent-sdk-client-to-rust-evaluator/15-01-SUMMARY.md

# API contract defined by the server
@crates/cli/src/serve.rs
@crates/eval/src/types.rs
@crates/eval/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript package with types, errors, and client skeleton</name>
  <files>
    sdk/typescript/package.json
    sdk/typescript/tsconfig.json
    sdk/typescript/tsconfig.build.json
    sdk/typescript/src/index.ts
    sdk/typescript/src/types.ts
    sdk/typescript/src/errors.ts
    sdk/typescript/src/client.ts
  </files>
  <action>
Create `sdk/typescript/` directory structure. This is a NEW package outside the Rust workspace.

**package.json:**
```json
{
  "name": "@tenor-lang/sdk",
  "version": "0.1.0",
  "description": "TypeScript SDK for Tenor contract evaluation — client to the Rust evaluator",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/types/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js",
      "types": "./dist/types/index.d.ts"
    }
  },
  "files": ["dist", "README.md"],
  "scripts": {
    "build": "tsc -p tsconfig.build.json && tsc -p tsconfig.build.json --module commonjs --outDir dist/cjs",
    "test": "node --test tests/*.test.ts --experimental-strip-types",
    "typecheck": "tsc --noEmit",
    "clean": "rm -rf dist"
  },
  "engines": { "node": ">=22.0.0" },
  "devDependencies": {
    "typescript": "^5.7"
  }
}
```

Node 22+ is chosen because it has built-in `fetch`, built-in test runner (`node:test`), and `--experimental-strip-types` for running .ts directly. This means ZERO runtime dependencies — the SDK uses only `fetch` (built into Node 22+) and Node standard library. No axios, no node-fetch, no jest.

**tsconfig.json** (for development/type checking):
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "strict": true,
    "esModuleInterop": true,
    "declaration": true,
    "declarationDir": "dist/types",
    "outDir": "dist/esm",
    "rootDir": "src",
    "skipLibCheck": true,
    "lib": ["ES2022"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

**tsconfig.build.json** — same as tsconfig.json but specifically for build output.

**src/types.ts:**
Define TypeScript interfaces mirroring the `tenor serve` API responses:

```typescript
/** Health check response */
export interface HealthResponse {
  status: string;
  tenor_version: string;
}

/** Contract summary in list response */
export interface ContractSummary {
  id: string;
  construct_count: number;
  facts: string[];
  operations: string[];
  flows: string[];
}

/** List contracts response */
export interface ContractsResponse {
  contracts: ContractSummary[];
}

/** Effect within an operation (entity state transition) */
export interface OperationEffect {
  entity_id: string;
  from: string;
  to: string;
}

/** Operation details from getOperations.
 *  Field names match the interchange JSON exactly:
 *  - `allowed_personas` (not "personas") — from Operation struct in crates/eval/src/types.rs
 *  - `effects` array (not a single "entity" field) — operations can target multiple entities
 *  Verified against: crates/core/src/pass6_serialize.rs Operation serialization
 */
export interface OperationInfo {
  id: string;
  allowed_personas: string[];
  effects: OperationEffect[];
  preconditions_summary: string;
}

/** Operations list response */
export interface OperationsResponse {
  operations: OperationInfo[];
}

/** Verdict from evaluation.
 *  Field names match VerdictSet::to_json() output in crates/eval/src/types.rs line 1583:
 *  - `type` (not "verdict_type") — the JSON key is "type"
 *  - `payload` (not "value") — the JSON key is "payload"
 *  - `provenance.rule` (not "rule_id") — the JSON key is "rule"
 */
export interface Verdict {
  type: string;
  payload: unknown;
  provenance: VerdictProvenance;
}

export interface VerdictProvenance {
  rule: string;
  stratum: number;
  facts_used: string[];
  verdicts_used: string[];
}

/** Evaluation result (rules only) */
export interface EvalResult {
  verdicts: {
    verdicts: Verdict[];
  };
}

/** Step record from flow execution */
export interface StepRecord {
  step_id: string;
  result: string;
}

/** Entity state change from flow execution */
export interface EntityStateChange {
  entity_id: string;
  from: string;
  to: string;
}

/** Flow evaluation result */
export interface FlowEvalResult {
  flow_id: string;
  outcome: string;
  initiating_persona: string | null;
  entity_state_changes: EntityStateChange[];
  steps_executed: StepRecord[];
  verdicts: {
    verdicts: Verdict[];
  };
}

/** Elaborate response (interchange JSON) */
export type InterchangeBundle = Record<string, unknown>;

/** Evaluate options */
export interface EvaluateOptions {
  flow_id?: string;
  persona?: string;
}

/** Explain response */
export interface ExplainResult {
  contract_id: string;
  summary: Record<string, unknown>;
}

/** Error response from the server */
export interface ErrorResponse {
  error: string;
  details?: Record<string, unknown>;
}
```

Refine these types based on the actual API shapes from Plan 15-01. The key principle: these types should match exactly what the `tenor serve` endpoints return. If the server shape evolves during Plan 01, update these to match.

**src/errors.ts:**
```typescript
export class TenorError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TenorError';
  }
}

export class ConnectionError extends TenorError {
  constructor(public readonly url: string, public readonly cause?: Error) {
    super(`Failed to connect to Tenor evaluator at ${url}`);
    this.name = 'ConnectionError';
  }
}

export class EvaluationError extends TenorError {
  constructor(
    message: string,
    public readonly details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'EvaluationError';
  }
}

export class ElaborationError extends TenorError {
  constructor(
    message: string,
    public readonly details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'ElaborationError';
  }
}

export class ContractNotFoundError extends TenorError {
  constructor(public readonly contractId: string) {
    super(`Contract '${contractId}' not found`);
    this.name = 'ContractNotFoundError';
  }
}
```

**src/client.ts:**
Create `TenorClient` class:

```typescript
export interface TenorClientOptions {
  /** Base URL of the tenor serve instance. Default: http://localhost:8080 */
  baseUrl?: string;
  /** Request timeout in milliseconds. Default: 30000 */
  timeout?: number;
}

export class TenorClient {
  private baseUrl: string;
  private timeout: number;

  constructor(options?: TenorClientOptions) {
    this.baseUrl = (options?.baseUrl ?? 'http://localhost:8080').replace(/\/$/, '');
    this.timeout = options?.timeout ?? 30000;
  }

  /** Check if the evaluator is reachable */
  async health(): Promise<HealthResponse> { ... }

  /** List all loaded contracts */
  async listContracts(): Promise<ContractSummary[]> { ... }

  /** Get operations available in a contract (agent skill: getOperations) */
  async getOperations(contractId: string): Promise<OperationInfo[]> { ... }

  /** Evaluate a contract against facts (agent skill: invoke) */
  async invoke(contractId: string, facts: Record<string, unknown>, options?: EvaluateOptions): Promise<EvalResult | FlowEvalResult> { ... }

  /** Explain a contract in natural language (agent skill: explain) */
  async explain(contractId: string): Promise<ExplainResult> { ... }

  /** Elaborate .tenor source text into interchange JSON */
  async elaborate(source: string, filename?: string): Promise<InterchangeBundle> { ... }

  // Private helper for HTTP calls with error handling
  private async request<T>(method: string, path: string, body?: unknown): Promise<T> { ... }
}
```

The `request` helper should:
- Use `fetch()` (built into Node 22+)
- Set `Content-Type: application/json` for POST requests
- Use `AbortSignal.timeout(this.timeout)` for timeout
- On non-2xx responses, parse the error body and throw appropriate error class
- On network errors, throw `ConnectionError`
- Parse successful responses as JSON

**src/index.ts:**
Re-export everything:
```typescript
export { TenorClient, type TenorClientOptions } from './client.js';
export * from './types.js';
export * from './errors.js';
```

Note: use `.js` extensions in imports (required for Node16 module resolution with ESM).
  </action>
  <verify>
```bash
cd sdk/typescript && npm install && npm run typecheck
```
TypeScript compilation must succeed with no errors. No runtime dependencies should be installed (only devDependencies).
  </verify>
  <done>
Package structure exists with typed client class, comprehensive type definitions, error classes, and clean TypeScript compilation. Zero runtime dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement client methods and write tests</name>
  <files>
    sdk/typescript/src/client.ts
    sdk/typescript/tests/client.test.ts
  </files>
  <action>
Complete the `TenorClient` method implementations in `client.ts`. Each method follows the same pattern: call `this.request()` with the appropriate method/path/body, destructure the response, and return the typed result.

**Implementation details:**

`health()` — GET /health, return HealthResponse directly.

`listContracts()` — GET /contracts, extract and return `response.contracts`.

`getOperations(contractId)` — GET /contracts/{contractId}/operations, extract and return `response.operations`. Throw `ContractNotFoundError` on 404.

`invoke(contractId, facts, options?)` — POST /evaluate with body `{ bundle_id: contractId, facts, flow_id: options?.flow_id ?? null, persona: options?.persona ?? null }`. If flow_id is present, return as `FlowEvalResult`. Otherwise return as `EvalResult`. Throw `ContractNotFoundError` on 404, `EvaluationError` on 400.

`explain(contractId)` — POST /explain with body `{ bundle_id: contractId }`. Return `ExplainResult`. Throw `ContractNotFoundError` on 404.

`elaborate(source, filename?)` — POST /elaborate with body `{ source, filename: filename ?? "input.tenor" }`. Return the interchange bundle JSON. Throw `ElaborationError` on 400 (elaboration failure).

`request<T>()` — the private helper that all methods use:
```typescript
private async request<T>(method: string, path: string, body?: unknown): Promise<T> {
  const url = `${this.baseUrl}${path}`;
  const init: RequestInit = {
    method,
    headers: { 'Content-Type': 'application/json' },
    signal: AbortSignal.timeout(this.timeout),
  };
  if (body !== undefined) {
    init.body = JSON.stringify(body);
  }
  let response: Response;
  try {
    response = await fetch(url, init);
  } catch (err) {
    if (err instanceof Error && err.name === 'TimeoutError') {
      throw new ConnectionError(url, err);
    }
    throw new ConnectionError(url, err instanceof Error ? err : undefined);
  }
  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({ error: response.statusText }));
    if (response.status === 404) {
      // Extract contract ID from path for better error messages
      const match = path.match(/\/contracts\/([^/]+)/);
      if (match) throw new ContractNotFoundError(match[1]);
    }
    if (path.includes('/evaluate')) {
      throw new EvaluationError(errorBody.error ?? 'Evaluation failed', errorBody.details);
    }
    if (path.includes('/elaborate')) {
      throw new ElaborationError(errorBody.error ?? 'Elaboration failed', errorBody.details);
    }
    throw new TenorError(errorBody.error ?? `HTTP ${response.status}`);
  }
  return response.json() as Promise<T>;
}
```

**Tests** (`tests/client.test.ts`):

Use Node's built-in test runner (`node:test`) and assertion module (`node:assert`). Tests should be structured in two groups:

1. **Unit tests (no server needed):**
   - Test that `TenorClient` constructor sets defaults correctly
   - Test that `TenorClient` constructor accepts custom options
   - Test that error classes have correct names and messages
   - Test URL construction (trailing slash handling)

2. **Integration tests (require running server):**
   - Guard these with a check: `if (!process.env.TENOR_SERVE_URL) { test.skip('...') }`
   - When `TENOR_SERVE_URL` is set, test all methods against a real server
   - Test health() returns valid response
   - Test listContracts() returns array
   - Test getOperations() for a known contract
   - Test invoke() with valid facts
   - Test invoke() with invalid bundle_id throws ContractNotFoundError
   - Test elaborate() with valid .tenor source
   - Test elaborate() with invalid source throws ElaborationError

Structure tests like:
```typescript
import { describe, it, test } from 'node:test';
import assert from 'node:assert/strict';
import { TenorClient, ConnectionError, ContractNotFoundError } from '../src/index.js';

describe('TenorClient', () => {
  describe('constructor', () => {
    it('uses default base URL', () => { ... });
    it('accepts custom base URL', () => { ... });
    it('strips trailing slash from base URL', () => { ... });
  });

  describe('integration', () => {
    const serverUrl = process.env.TENOR_SERVE_URL;
    if (!serverUrl) {
      test.skip('TENOR_SERVE_URL not set — skipping integration tests');
    } else {
      const client = new TenorClient({ baseUrl: serverUrl });
      // ... integration tests
    }
  });
});
```
  </action>
  <verify>
```bash
cd sdk/typescript && npm run typecheck && npm test
```
Type checking passes. Unit tests pass. Integration tests skip gracefully when no server is running.

To run integration tests:
```bash
# Terminal 1:
cargo run -p tenor-cli -- serve --port 9090 domains/saas/saas_subscription.tenor

# Terminal 2:
cd sdk/typescript && TENOR_SERVE_URL=http://localhost:9090 npm test
```
  </verify>
  <done>
All TenorClient methods are implemented with proper error handling. Unit tests pass without a server. Integration tests pass against a running `tenor serve` instance. The three agent skills (getOperations, invoke, explain) are fully functional from TypeScript.
  </done>
</task>

</tasks>

<verification>
1. `cd sdk/typescript && npm install && npm run typecheck` — passes
2. `cd sdk/typescript && npm test` — unit tests pass
3. `cd sdk/typescript && npm run build` — produces dist/esm and dist/cjs outputs
4. Integration test with running server demonstrates all three agent skills working end-to-end
5. Package has zero runtime dependencies
6. All types accurately reflect the server API
</verification>

<success_criteria>
- `@tenor-lang/sdk` package exists at `sdk/typescript/`
- TenorClient class connects to `tenor serve` over HTTP
- Three agent skills exposed: `getOperations()`, `invoke()`, `explain()`
- All responses are typed with TypeScript interfaces
- Error handling provides specific error classes (ConnectionError, EvaluationError, etc.)
- Zero runtime dependencies (uses Node 22+ built-in fetch and test runner)
- Unit tests pass, integration tests pass against running server
- Package builds to both ESM and CJS
</success_criteria>

<output>
After completion, create `.planning/phases/15-typescript-agent-sdk-client-to-rust-evaluator/15-02-SUMMARY.md`
</output>
