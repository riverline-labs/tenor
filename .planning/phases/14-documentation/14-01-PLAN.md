---
phase: 14-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/guide/author-guide.md
autonomous: true
requirements: [DEVX-05, DEVX-06]

must_haves:
  truths:
    - "docs/guide/author-guide.md exists and is well-structured with 5 parts"
    - "Part 1 explains why Tenor exists with the three-layer trust model"
    - "Part 2 covers core concepts in dependency order (Facts, Entities, Rules, Personas, Operations, Flows, System) with minimal examples and common mistakes"
    - "Part 3 has four patterns anchored in real domain contracts from domains/"
    - "Part 4 makes S1-S8 properties concrete against the supply chain contract"
    - "Part 5 shows trade_inspection_system.tenor with domain rationale first"
  artifacts:
    - path: "docs/guide/author-guide.md"
      provides: "Complete author guide for Tenor contract writers"
      contains: "three-layer trust model, four domain patterns, S1-S8 proofs, System composition"
---

<objective>
Create the Author Guide (docs/guide/author-guide.md) — the primary document for people writing .tenor files for real domains.

This is NOT a spec mirror. The spec exists. This is a different artifact with a different job: teaching contract authors how to think about and write Tenor contracts through real patterns and concrete proofs.

Structure: Five parts building from motivation through concepts, patterns, proofs, to System composition.
</objective>

<context>
@docs/TENOR.md (the formal specification — reference but do not restate)
@domains/supply_chain/inspection.tenor (Pattern 1 anchor: parallel approval)
@domains/supply_chain/types.tenor (shared types for supply chain)
@domains/saas/saas_subscription.tenor (escrow-like patterns)
@domains/healthcare/prior_auth.tenor (Pattern 4 anchor: multi-stratum)
@domains/healthcare/prior_auth_approve.tenor (approval flow)
@domains/healthcare/prior_auth_deny.tenor (denial flow)
@domains/healthcare/prior_auth_appeal.tenor (appeal flow)
@domains/system_scenario/trade_inspection_system.tenor (Part 5 anchor)
@domains/trade_finance/letter_of_credit.tenor (System member)
@domains/energy_procurement/rfp_workflow.tenor (threshold/handoff patterns)
@conformance/positive/escrow_contract.tenor (escrow for Pattern 2)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Part 1 — Why Tenor Exists</name>
  <files>docs/guide/author-guide.md</files>
  <action>
Create `docs/guide/` directory if needed. Create `docs/guide/author-guide.md`.

Part 1 — Why Tenor exists. One page max. Not marketing.

The fragmentation problem: behavior described across OpenAPI specs, policy YAML, RBAC configs, workflow engines, implementation code. None of it unified, none of it agent-legible.

Tenor is a behavioral contract language — not a programming language, not a config format. The language's constraints are the mechanism that enables formal guarantees.

Lead with: "Tenor is non-Turing complete by design. That's not a limitation — it's how we can prove things about your contracts."

Include the three-layer trust model:
- Layer 1: Language guarantees — S1-S8 properties hold for any valid contract by construction
- Layer 2: Elaborator trust — conforming elaborator guarantees interchange faithfully represents the contract
- Layer 3: Executor trust — executor obligations E1-E14 are precisely specified; conformance suite verifiable

Tone: never apologize for constraints. Non-Turing completeness, no aggregates, no pattern matching, frozen verdicts — these are the mechanisms that enable the guarantees. State the reason before the constraint.
  </action>
  <verify>File exists, Part 1 is present, three-layer trust model is described.</verify>
  <done>Part 1 written with motivation, fragmentation problem, and three-layer trust model.</done>
</task>

<task type="auto">
  <name>Task 2: Create Part 2 — Core Concepts</name>
  <files>docs/guide/author-guide.md</files>
  <action>
Part 2 — Core concepts. Introduce constructs in dependency order matching spec section 3:

1. Facts (ground typed assertions from external sources)
2. Entities (finite state machines)
3. Rules (stratified verdict-producing functions)
4. Personas (authority boundaries)
5. Operations (persona-gated state transitions)
6. Flows (finite DAG orchestration)
7. System (multi-contract composition)

Each concept gets:
- One-paragraph plain English explanation
- One minimal example (use purpose-built minimal examples — three facts, one entity, two rules. NOT the escrow contract)
- One "common mistake and why it's wrong"

Do NOT use the escrow contract here. Save real contracts for Part 3.

Reference the spec for formal definitions but write explanations in the author's voice.
  </action>
  <verify>Part 2 present, all 7 constructs covered, each has explanation + example + common mistake.</verify>
  <done>Part 2 complete with all constructs in dependency order.</done>
</task>

<task type="auto">
  <name>Task 3: Create Part 3 — Patterns</name>
  <files>docs/guide/author-guide.md</files>
  <action>
Part 3 — Patterns. The heart of the guide. Four patterns from Phase 5 domain validation, each anchored in a real domain contract from the `domains/` directory.

**Pattern 1 — Parallel approval with compensation (supply chain)**
Read `domains/supply_chain/inspection.tenor`. When two independent approval tracks must both succeed, use ParallelStep with disjoint entities. Show the supply chain inspection contract. Explain why QualityLot and ComplianceLot are separate entities — not a modeling preference, a spec requirement (parallel branches must have disjoint entity effect sets). Show the Compensate handler. Explain: compensation is not error handling, it's rollback of committed state.

**Pattern 2 — Threshold-gated handoff (escrow)**
Read `conformance/positive/escrow_contract.tenor`. When a decision crosses a compliance threshold, use a BranchStep routing to a HandoffStep. Show the escrow standard_release flow. Explain frozen verdict semantics — the threshold check uses the verdict set computed at flow initiation, not recomputed after subsequent operations fired. Make frozen verdicts concrete.

**Pattern 3 — External aggregate as Fact (any domain)**
The no-aggregate constraint exists for a reason — aggregates are derived values, not ground truth. Show the INCORRECT pattern (sum over line_items in a rule) and the CORRECT pattern (requisition_total as a Fact from an external system). Explain: the contract cannot verify the arithmetic itself, only act on a pre-computed result. This is honest about the boundary.

**Pattern 4 — Multi-stratum verdict chaining (healthcare)**
Read `domains/healthcare/prior_auth.tenor` and related flow files. Stratum 0 produces base verdicts from facts. Stratum 1 composes them into decisions. Show the healthcare contract's multi-stratum structure. Explain why same-stratum references are prohibited and how to use the re-expression theorem to fix them. This is where S8 (verdict uniqueness) becomes concrete — each verdict type from exactly one rule.

Each pattern: domain rationale first, then the Tenor code, then the formal property it demonstrates.
  </action>
  <verify>Part 3 present with all 4 patterns, each referencing real domain contracts.</verify>
  <done>Part 3 complete with 4 patterns anchored in real domain contracts.</done>
</task>

<task type="auto">
  <name>Task 4: Create Parts 4 and 5</name>
  <files>docs/guide/author-guide.md</files>
  <action>
**Part 4 — What you can prove**

This is the payoff. After Parts 1-3, the reader sees contracts as formal objects. Make S1-S8 properties concrete against the supply chain contract:

- S4 proof: customs_officer cannot release a shipment. Show the allowed_personas sets. Show the state machine. The proof is visible in the contract structure.
- S6 proof: every path through inspection_flow terminates. Enumerate the paths. No path is missing a failure handler.
- Cross-contract S6: show the `tenor check` output for trade_inspection_system.tenor — the [s6_cross/INFO] finding. One line proving the trigger chain is correctly wired.

Close with independent auditability: because Tenor is fully specified and deterministic, anyone can run your contract through their own conforming executor and verify outputs. The contract is the source of truth anyone can check.

**Part 5 — System composition**

Read `domains/system_scenario/trade_inspection_system.tenor`. Show it in full.

Explain the domain rationale first — shipment must clear inspection before LC documents can be presented. Then show what the System construct declares. Then show the S6 output.

Business logic comes first, mechanics follow.

Address empty shared_personas and shared_entities honestly — these domains have no natural overlap, and that's fine. The trigger is the only relationship and it's the right one.
  </action>
  <verify>Parts 4 and 5 present. S4/S6 proofs concrete. System composition shown with rationale first.</verify>
  <done>Author guide complete with all 5 parts.</done>
</task>

</tasks>

<verification>
1. docs/guide/author-guide.md exists
2. Five parts clearly delineated
3. Part 1 has three-layer trust model
4. Part 2 has all 7 constructs with examples and common mistakes
5. Part 3 has 4 patterns anchored in real domain contracts
6. Part 4 has concrete S4, S6, cross-contract S6 proofs
7. Part 5 shows trade_inspection_system.tenor with domain rationale first
8. Tone: never apologizes for constraints, states reasons before constraints
9. Does NOT restate the spec
</verification>

<success_criteria>
- docs/guide/author-guide.md is complete with all 5 parts
- Real domain contracts from domains/ are referenced (not made up)
- Formal properties (S1-S8) are made concrete, not just listed
- No spec restatement — patterns and proofs, not definitions
</success_criteria>

<output>
After completion, create `.planning/phases/14-documentation/14-01-SUMMARY.md`
</output>
