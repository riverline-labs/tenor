# Phase 16: TypeScript Code Generation - Context

**Gathered:** 2026-02-22
**Status:** Ready for planning

<domain>
## Phase Boundary

Generate contract-specific TypeScript types and client bindings from elaborated Tenor contracts. Provides IDE autocomplete and compile-time checking on top of the Phase 15 SDK. The SDK already works without this — codegen is an optional optimization that generates typed wrappers, interfaces, and Zod validators for specific contracts.

</domain>

<decisions>
## Implementation Decisions

### Invocation & workflow
- CLI command: `tenor generate typescript --out ./generated <input>` (subcommand per language, not a flag)
- Future languages (Rust, Go) will be separate subcommands in Phase 23
- Accepts both `.tenor` source files (elaborates internally first) and interchange JSON (generates directly)
- Always overwrites output directory — generated files are fully owned by codegen, users don't edit them
- Generated files include minimal header: `// Auto-generated by tenor generate. Do not edit.`
- Configurable SDK import path via `--sdk-import` flag — defaults to `@tenor/sdk`, overridable for monorepos

### Output shape
- Split by concern per contract: `types.ts`, `schemas.ts`, `client.ts`, `index.ts` (barrel)
- Typed client wrapper class per contract, wrapping the Phase 15 `TenorClient` via composition
- Operation-specific methods for discoverability (e.g., `client.submitApplication(facts)`) PLUS generic `invoke` for dynamic use cases
- Zod validators for fact INPUTS only — responses trust the Rust evaluator as the trust boundary
- Thin constructor helpers for branded types (e.g., `money('100.00')`) wrapping Zod parse
- Barrel export from each contract's `index.ts`
- No top-level barrel across contracts — avoids namespace collisions between contracts

### Type mapping
- Branded strings (zero runtime cost) for Money, Decimal, Date, DateTime, Duration: `type TenorMoney = string & { readonly __brand: 'TenorMoney' }`
- String union types for entity states: `type LoanState = 'pending' | 'approved' | 'rejected'`
- No enums, no const objects — plain unions are idiomatic TypeScript
- No custom classes — keep it idiomatic TypeScript that plays well with existing codebases
- Branded type consistency: all Tenor special types use the same branded string pattern

### Contract specificity
- One directory per contract, kebab-case matching contract ID: `./generated/loan-approval/`
- Multi-contract projects get separate directories under the output root
- No type name prefixing — TypeScript module system handles namespacing naturally
- Contract version embedded as a comment in generated files, not in type names — type names are stable across versions
- No top-level barrel re-export — users import directly from each contract directory

### Claude's Discretion
- Internal code generation architecture (template-based, AST builder, string concatenation, etc.)
- Zod schema precision validation details for Money/Decimal
- Exact branded type names and branding key names
- How the Rust `codegen` crate organizes its TypeScript emitter
- Error messages and diagnostics during generation

</decisions>

<specifics>
## Specific Ideas

- "The typed methods are just sugar over the generic invoke anyway" — generated operation methods should delegate to the generic invoke internally
- CI pipeline use case: elaborate once, generate for multiple languages without re-running the elaborator — interchange JSON input enables this
- Enterprise TypeScript developers are Tenor's natural customers — classes over factory functions, familiar patterns, easy to mock in tests
- Tree-shaking works better with split files — split by concern, not by construct

</specifics>

<deferred>
## Deferred Ideas

- Watch mode / build plugin integration — Phase 17 (VS Code Extension) territory
- Rust and Go code generation — Phase 23
- Runtime response validation with Zod — explicitly rejected, evaluator is the trust boundary

</deferred>

---

*Phase: 16-typescript-code-generation*
*Context gathered: 2026-02-22*
