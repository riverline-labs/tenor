---
phase: 16-typescript-code-generation
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - crates/codegen/src/typescript_client.rs
  - crates/codegen/src/lib.rs
  - crates/codegen/tests/codegen_integration.rs
autonomous: true
requirements: [CGEN-02, CGEN-03]

must_haves:
  truths:
    - "Generated client.ts contains a typed wrapper class with operation-specific methods that delegate to the SDK's generic invoke"
    - "Generated index.ts barrel re-exports everything from types.ts, schemas.ts, and client.ts"
    - "Generated TypeScript compiles with tsc --noEmit (no type errors)"
    - "Generated operation methods have typed fact parameters and persona union types, providing IDE autocompletion"
    - "Multi-contract generation produces separate directories under the output root with no namespace collisions"
    - "Constructor wraps TenorClient via composition (not inheritance)"
  artifacts:
    - path: "crates/codegen/src/typescript_client.rs"
      provides: "TypeScript client.ts emitter with typed operation methods"
      contains: "emit_client"
    - path: "crates/codegen/tests/codegen_integration.rs"
      provides: "Integration tests verifying generated TypeScript compiles and matches expected shape"
      contains: "test_generate_typescript"
  key_links:
    - from: "crates/codegen/src/typescript_client.rs"
      to: "crates/codegen/src/typescript.rs"
      via: "client references types from types.ts"
      pattern: "import.*from.*types"
    - from: "crates/codegen/src/lib.rs"
      to: "crates/codegen/src/typescript_client.rs"
      via: "generate_typescript calls emit_client and writes client.ts"
      pattern: "typescript_client::emit_client"
---

<objective>
Add the typed client wrapper generator (`client.ts`) and barrel export (`index.ts`) to the codegen pipeline, then validate the complete generated output compiles and provides correct IDE types. This completes the code generation feature with typed client bindings (CGEN-02) and verifiable IDE autocompletion support (CGEN-03).

Purpose: The typed client wrapper gives developers operation-specific methods (`client.submitOrder(facts)`) with full type safety, while the barrel export provides clean import ergonomics. Integration tests prove the generated code is valid TypeScript.

Output: Complete 4-file generation per contract (types.ts, schemas.ts, client.ts, index.ts), integration tests validating output.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-typescript-code-generation/16-CONTEXT.md
@.planning/phases/16-typescript-code-generation/16-01-SUMMARY.md
@crates/codegen/src/lib.rs
@crates/codegen/src/typescript.rs
@crates/codegen/src/typescript_schemas.rs
@crates/codegen/src/bundle.rs
@sdk/typescript/src/client.ts
@sdk/typescript/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement client.ts and index.ts emitters</name>
  <files>
    crates/codegen/src/typescript_client.rs
    crates/codegen/src/lib.rs
  </files>
  <action>
    **typescript_client.rs**: TypeScript `client.ts` emitter that generates a typed wrapper class.
    - `pub fn emit_client(bundle: &CodegenBundle, sdk_import: &str) -> String`
    - Header: `// Auto-generated by tenor generate. Do not edit.\n// Contract: {bundle.id}\n`
    - Imports:
      ```typescript
      import type { TenorClient, EvalResult, FlowEvalResult } from '{sdk_import}';
      import type { {PascalBundleId}Facts } from './types.ts';
      ```
    - Class: `export class {PascalBundleId}Client {`
      - Private field: `private readonly client: TenorClient;`
      - Private field: `private readonly contractId = '{bundle.id}';`
      - Constructor: `constructor(client: TenorClient) { this.client = client; }`
      - Generic invoke: `async invoke(facts: Partial<{PascalBundleId}Facts>, options?: { flow_id?: string; persona?: string }): Promise<EvalResult | FlowEvalResult> { return this.client.invoke(this.contractId, facts, options); }`
      - For each Operation: generate a typed method:
        ```typescript
        async {camelOpId}(facts: Partial<{PascalBundleId}Facts>): Promise<EvalResult | FlowEvalResult> {
          return this.client.invoke(this.contractId, facts, { persona: '{first_allowed_persona}' });
        }
        ```
        Per CONTEXT.md: operation methods delegate to generic invoke internally.
        If operation has single allowed persona, hardcode it. If multiple, accept persona as a parameter with a union type:
        ```typescript
        async {camelOpId}(facts: Partial<{PascalBundleId}Facts>, persona: {PersonaUnion}): Promise<EvalResult | FlowEvalResult> {
          return this.client.invoke(this.contractId, facts, { persona });
        }
        ```
        Where `{PersonaUnion}` is `'reviewer' | 'admin'` etc.
      - `async explain(): Promise<{ summary: string; verbose: string }> { return this.client.explain(this.contractId); }`
      - `async getOperations() { return this.client.getOperations(this.contractId); }`
    - Close class

    **lib.rs**: Add `pub mod typescript_client;` and a barrel emitter function.
    - Add `fn emit_index(bundle: &CodegenBundle) -> String` that generates `index.ts`:
      ```typescript
      // Auto-generated by tenor generate. Do not edit.
      // Contract: {bundle.id}
      export * from './types.ts';
      export * from './schemas.ts';
      export { {PascalBundleId}Client } from './client.ts';
      ```
      Per CONTEXT.md: no top-level barrel across contracts, but each contract directory gets a barrel.
    - Update `generate_typescript()` to also call `emit_client()` and `emit_index()`, writing `client.ts` and `index.ts` alongside `types.ts` and `schemas.ts`.
    - Contract version embedded as comment in generated files (per CONTEXT.md: "in generated files, not in type names").

    Run `cargo build --workspace` and `cargo clippy --workspace -- -D warnings`.
  </action>
  <verify>
    `cargo build --workspace` succeeds.
    `cargo clippy --workspace -- -D warnings` clean.
    `cargo run -p tenor-cli -- generate typescript --out /tmp/tenor-gen conformance/positive/operation_basic.expected.json` produces 4 files:
    - `/tmp/tenor-gen/operation-basic/types.ts`
    - `/tmp/tenor-gen/operation-basic/schemas.ts`
    - `/tmp/tenor-gen/operation-basic/client.ts`
    - `/tmp/tenor-gen/operation-basic/index.ts`
    The client.ts contains `OperationBasicClient` class with `submitOrder()`, `approveOrder()`, `rejectOrder()` methods.
  </verify>
  <done>
    client.ts emitter generates a typed wrapper class with operation-specific methods that delegate to the SDK's generic invoke. index.ts barrel re-exports all public types and the client class. Each operation method has correctly typed persona parameter (hardcoded for single-persona ops, union for multi-persona ops).
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests and TypeScript compilation verification</name>
  <files>
    crates/codegen/tests/codegen_integration.rs
  </files>
  <action>
    Create integration tests in `crates/codegen/tests/codegen_integration.rs` that verify the complete generation pipeline.

    **Test 1: `test_generate_typescript_from_json`**
    - Read `conformance/positive/operation_basic.expected.json`
    - Call `generate_typescript()` with a tempdir
    - Assert output directory `{tempdir}/operation-basic/` exists
    - Assert all 4 files exist: types.ts, schemas.ts, client.ts, index.ts
    - Assert types.ts contains:
      - `export type TenorMoney = string &` (branded type)
      - `export type OrderState = 'draft' | 'submitted' | 'approved' | 'rejected'` (entity state union)
      - `export interface OperationBasicFacts` (facts interface)
      - `is_active: boolean` (bool fact mapping)
    - Assert client.ts contains:
      - `export class OperationBasicClient` (wrapper class)
      - `submitOrder(` (operation method)
      - `approveOrder(` (operation method)
      - `private readonly client: TenorClient` (composition, not inheritance)
    - Assert index.ts contains re-exports from types.ts, schemas.ts, client.ts

    **Test 2: `test_generate_typescript_integration_escrow`**
    - Read `conformance/positive/integration_escrow.expected.json`
    - Call `generate_typescript()` with a tempdir
    - Assert types.ts contains:
      - `export type EscrowAccountState = 'held' | 'released' | 'refunded' | 'disputed'` (entity states)
      - `export type DeliveryRecordState = 'pending' | 'confirmed' | 'failed'`
      - `TenorMoney` branded type usage for money facts
      - List/Record type for line_items
    - Assert schemas.ts contains Zod validators:
      - `z.boolean()` for bool facts
      - `z.string()` with money refinement for money facts
      - `z.array(` for list facts

    **Test 3: `test_generate_typescript_overwrites_existing`**
    - Generate into a tempdir, then generate again into the same dir
    - Verify files are overwritten (per CONTEXT.md: "Always overwrites output directory")
    - Content should be identical both times

    **Test 4: `test_generate_multiple_contracts`**
    - Generate both operation_basic and integration_escrow into the same output root
    - Verify separate directories: `{tempdir}/operation-basic/` and `{tempdir}/integration-escrow/`
    - No namespace collisions

    Run the full pre-commit quality gate:
    ```bash
    cargo fmt --all
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    cargo clippy --workspace -- -D warnings
    ```
  </action>
  <verify>
    All five pre-commit checks pass:
    1. `cargo fmt --all` (no changes)
    2. `cargo build --workspace` succeeds
    3. `cargo test --workspace` passes (including new codegen integration tests)
    4. `cargo run -p tenor-cli -- test conformance` passes
    5. `cargo clippy --workspace -- -D warnings` clean
  </verify>
  <done>
    Integration tests verify: (1) complete 4-file generation from interchange JSON, (2) correct type mapping for complex contracts with Money, List, Record, Entity states, (3) overwrite behavior, (4) multi-contract isolation. All tests pass alongside existing test suite.
  </done>
</task>

</tasks>

<verification>
1. All five pre-commit quality gates pass
2. `tenor generate typescript --out /tmp/test conformance/positive/operation_basic.expected.json` produces 4 files (types.ts, schemas.ts, client.ts, index.ts)
3. `tenor generate typescript --out /tmp/test conformance/positive/integration_escrow.expected.json` produces correct types for Money/List/Record/Entity constructs
4. Generated client wraps TenorClient via composition with operation-specific typed methods
5. `cargo test --workspace` includes codegen integration tests that verify output shape
6. Generated files contain header comments and contract version
</verification>

<success_criteria>
- client.ts emitter produces typed wrapper class with operation-specific methods delegating to generic invoke
- index.ts barrel re-exports all public symbols from types.ts, schemas.ts, client.ts
- Integration tests verify output shape for operation_basic and integration_escrow contracts
- Multi-contract generation produces isolated directories
- Overwrite behavior works correctly
- All five pre-commit quality gates pass
- Complete code generation pipeline: .tenor or .json input -> 4 TypeScript files per contract
</success_criteria>

<output>
After completion, create `.planning/phases/16-typescript-code-generation/16-02-SUMMARY.md`
</output>
