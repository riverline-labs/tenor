---
phase: 16-typescript-code-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/codegen/Cargo.toml
  - crates/codegen/src/lib.rs
  - crates/codegen/src/bundle.rs
  - crates/codegen/src/typescript.rs
  - crates/codegen/src/typescript_schemas.rs
  - crates/cli/src/main.rs
  - crates/cli/Cargo.toml
autonomous: true
requirements: [CGEN-01]

must_haves:
  truths:
    - "Running `tenor generate typescript --out ./out bundle.json` produces types.ts with branded types and interfaces for all facts, entities, and operations in the contract"
    - "Running `tenor generate typescript --out ./out file.tenor` elaborates first then generates identical output"
    - "types.ts contains branded string types for Money, Decimal, Date, DateTime, Duration"
    - "types.ts contains string union types for entity states"
    - "schemas.ts contains Zod validators for fact input types only"
    - "Generated files include header comment: // Auto-generated by tenor generate. Do not edit."
  artifacts:
    - path: "crates/codegen/src/bundle.rs"
      provides: "Interchange JSON deserialization into codegen-internal typed structs"
      contains: "from_interchange"
    - path: "crates/codegen/src/typescript.rs"
      provides: "TypeScript types.ts emitter"
      contains: "emit_types"
    - path: "crates/codegen/src/typescript_schemas.rs"
      provides: "TypeScript schemas.ts Zod emitter"
      contains: "emit_schemas"
    - path: "crates/codegen/src/lib.rs"
      provides: "Public API: generate_typescript(bundle, config) -> Result"
      exports: ["generate_typescript"]
  key_links:
    - from: "crates/cli/src/main.rs"
      to: "crates/codegen/src/lib.rs"
      via: "tenor generate typescript subcommand calls generate_typescript()"
      pattern: "tenor_codegen::generate_typescript"
    - from: "crates/codegen/src/lib.rs"
      to: "crates/codegen/src/bundle.rs"
      via: "deserialize interchange JSON before emitting"
      pattern: "CodegenBundle::from_interchange"
---

<objective>
Implement the tenor-codegen TypeScript emitter that reads interchange JSON bundles and generates `types.ts` (branded types, fact interfaces, entity state unions, operation types) and `schemas.ts` (Zod validators for fact inputs). Wire the CLI `generate` command from its current stub to a working `tenor generate typescript` subcommand.

Purpose: Provides typed TypeScript interfaces generated directly from contracts, enabling IDE autocompletion and compile-time type checking for contract consumers. This is CGEN-01 (typed interfaces from interchange bundles).

Output: Working `tenor generate typescript --out <dir> <input>` command producing `types.ts` and `schemas.ts` per contract.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-typescript-code-generation/16-CONTEXT.md
@crates/codegen/src/lib.rs
@crates/codegen/Cargo.toml
@crates/cli/src/main.rs
@crates/analyze/src/bundle.rs
@docs/interchange-schema.json
@sdk/typescript/src/types.ts
@conformance/positive/integration_escrow.expected.json
@conformance/positive/operation_basic.expected.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tenor-codegen TypeScript type and schema emitters</name>
  <files>
    crates/codegen/Cargo.toml
    crates/codegen/src/lib.rs
    crates/codegen/src/bundle.rs
    crates/codegen/src/typescript.rs
    crates/codegen/src/typescript_schemas.rs
  </files>
  <action>
    **Cargo.toml**: Add `serde`, `serde_json` workspace dependencies (needed for interchange deserialization). Do NOT add `tenor-core` to runtime deps for codegen -- codegen operates on interchange JSON, not AST (same pattern as tenor-eval and tenor-analyze).

    **bundle.rs**: Create codegen-internal typed structs for interchange deserialization (same pattern as `crates/analyze/src/bundle.rs` and `crates/eval/src/types.rs` -- each crate deserializes independently, no imports from tenor-core). Key structs:
    - `CodegenBundle { id, constructs }` with `from_interchange(value: &serde_json::Value) -> Result<Self, CodegenError>`
    - `Construct` enum with variants: `Fact { id, type_info, source, default }`, `Entity { id, states, initial, transitions }`, `Operation { id, allowed_personas, effects, precondition, outcomes, error_contract }`, `Rule { id, stratum, verdict_type }`, `Flow { id, entry, steps }`, `Persona { id }`, `System { .. }`
    - `TypeInfo` enum matching BaseType from schema: `Bool`, `Int { min, max }`, `Decimal { precision, scale }`, `Money { currency }`, `Text { max_length }`, `Date`, `DateTime`, `Duration { unit, min, max }`, `Enum { values }`, `List { element_type, max }`, `Record { fields }`, `TaggedUnion { variants }`
    - `CodegenError` enum: `InvalidBundle(String)`, `IoError(String)`, `EmitError(String)`
    - Parse constructs by matching on `"kind"` field: `"Fact"`, `"Entity"`, `"Operation"`, `"Rule"`, `"Flow"`, `"Persona"`, `"System"`
    - For Rules, extract the `verdict_type` from `body.produce.verdict_type` and the payload type from `body.produce.payload.type`

    **typescript.rs**: TypeScript `types.ts` emitter.
    - `pub fn emit_types(bundle: &CodegenBundle) -> String`
    - Header: `// Auto-generated by tenor generate. Do not edit.\n// Contract: {bundle.id}\n`
    - Branded types section (always emitted):
      ```typescript
      export type TenorMoney = string & { readonly __brand: 'TenorMoney' };
      export type TenorDecimal = string & { readonly __brand: 'TenorDecimal' };
      export type TenorDate = string & { readonly __brand: 'TenorDate' };
      export type TenorDateTime = string & { readonly __brand: 'TenorDateTime' };
      export type TenorDuration = string & { readonly __brand: 'TenorDuration' };
      ```
    - For each Entity: emit state union type `export type {PascalId}State = 'state1' | 'state2' | ...;`
    - For each Fact: collect into a facts interface. Map types: Bool->boolean, Int->number, Decimal->TenorDecimal, Money->TenorMoney, Text->string, Date->TenorDate, DateTime->TenorDateTime, Duration->TenorDuration, Enum->string union, List->Array<T>, Record->inline object type.
    - Emit `export interface {PascalBundleId}Facts { fact_id: MappedType; ... }` with all facts
    - For each Operation: emit an interface for its input shape:
      `export interface {PascalOpId}Input { facts: Partial<{PascalBundleId}Facts>; persona: {allowed_personas union}; }`
    - For each Rule's verdict: collect verdict types. Emit `export type {PascalBundleId}VerdictType = 'verdict1' | 'verdict2' | ...;`
    - Use `to_pascal_case()` helper for snake_case -> PascalCase conversion (e.g., `integration_escrow` -> `IntegrationEscrow`)
    - Use `to_camel_case()` helper for fact IDs in interfaces

    **typescript_schemas.rs**: Zod schema emitter for `schemas.ts`.
    - `pub fn emit_schemas(bundle: &CodegenBundle, sdk_import: &str) -> String`
    - Header: `// Auto-generated by tenor generate. Do not edit.\n// Contract: {bundle.id}\n`
    - Import: `import { z } from 'zod';`
    - Import branded types from types.ts: `import type { TenorMoney, TenorDecimal, ... } from './types.ts';`
    - For each Tenor type, emit Zod schema: Bool->`z.boolean()`, Int->`z.number().int()` (with min/max if present), Text->`z.string()` (with max if present), Decimal->`z.string().refine(...)` (validate decimal format), Money->`z.string().refine(...)` (validate money format), Date->`z.string().regex(/^\d{4}-\d{2}-\d{2}$/)`, DateTime->`z.string().datetime()`, Duration->`z.string()`, Enum->`z.enum([...])`, List->`z.array(elementSchema)` (with max if present), Record->`z.object({...})`
    - Emit: `export const {camelBundleId}FactsSchema = z.object({ ... });`
    - Constructor helpers for branded types:
      ```typescript
      export function money(value: string): TenorMoney { return moneySchema.parse(value) as TenorMoney; }
      export function decimal(value: string): TenorDecimal { return decimalSchema.parse(value) as TenorDecimal; }
      export function tenorDate(value: string): TenorDate { return dateSchema.parse(value) as TenorDate; }
      export function tenorDateTime(value: string): TenorDateTime { return dateTimeSchema.parse(value) as TenorDateTime; }
      export function duration(value: string): TenorDuration { return durationSchema.parse(value) as TenorDuration; }
      ```
    - Zod validators are for fact INPUTS only. Do NOT generate response validators -- the Rust evaluator is the trust boundary (per CONTEXT.md locked decision).

    **lib.rs**: Public API.
    - `pub mod bundle; pub mod typescript; pub mod typescript_schemas;`
    - `pub struct TypeScriptConfig { pub out_dir: PathBuf, pub sdk_import: String }`
    - `pub fn generate_typescript(interchange_json: &serde_json::Value, config: &TypeScriptConfig) -> Result<(), CodegenError>`
    - Implementation: deserialize bundle, call emit_types + emit_schemas, write files to `{out_dir}/{kebab-bundle-id}/types.ts` and `{out_dir}/{kebab-bundle-id}/schemas.ts`
    - Use `to_kebab_case()` helper for bundle ID -> directory name (per CONTEXT.md: kebab-case matching contract ID)

    Run `cargo build --workspace` and `cargo clippy --workspace -- -D warnings` to verify compilation.
  </action>
  <verify>
    `cargo build --workspace` succeeds.
    `cargo test --workspace` passes (no regressions).
    `cargo clippy --workspace -- -D warnings` clean.
  </verify>
  <done>
    tenor-codegen crate compiles with TypeScript type and schema emitters. Generates correct types.ts with branded types, fact interfaces, entity state unions, operation input types, and verdict type union. Generates schemas.ts with Zod validators for fact inputs and branded type constructor helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI generate command and verify end-to-end</name>
  <files>
    crates/cli/src/main.rs
    crates/cli/Cargo.toml
  </files>
  <action>
    **Cargo.toml**: Verify `tenor-codegen` is already listed as a dependency (it should be based on workspace setup). If not, add `tenor-codegen = { path = "../codegen" }`.

    **main.rs**: Replace the stub `Generate` command with a proper subcommand structure.

    Change the `Generate` enum variant from:
    ```rust
    Generate {
        bundle: PathBuf,
        #[arg(long)]
        target: String,
    }
    ```
    To a subcommand-based approach per CONTEXT.md decision (`tenor generate typescript --out ./generated <input>`):
    ```rust
    Generate {
        #[command(subcommand)]
        command: GenerateCommands,
    }
    ```
    Add:
    ```rust
    #[derive(Subcommand)]
    enum GenerateCommands {
        /// Generate TypeScript types and client bindings
        Typescript {
            /// Path to .tenor source file or interchange JSON bundle
            input: PathBuf,
            /// Output directory for generated files
            #[arg(long, default_value = "./generated")]
            out: PathBuf,
            /// SDK import path (default: @tenor/sdk)
            #[arg(long, default_value = "@tenor/sdk")]
            sdk_import: String,
        },
    }
    ```

    Implement the handler: `Commands::Generate { command }` dispatches to `GenerateCommands::Typescript { input, out, sdk_import }`.
    - If `input` has `.tenor` extension: call `tenor_core::elaborate::elaborate(&input)` to get interchange JSON, then pass to codegen
    - If `input` has `.json` extension: read and parse as `serde_json::Value`, then pass to codegen
    - Otherwise: error with "unsupported input file type"
    - Call `tenor_codegen::generate_typescript(&bundle_json, &config)` with the TypeScriptConfig
    - On success: print the output directory path (unless `--quiet`)
    - On failure: print error to stderr, exit with code 1

    Run the full pre-commit quality gate:
    ```bash
    cargo fmt --all
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    cargo clippy --workspace -- -D warnings
    ```

    **End-to-end verification:** Test with a real conformance fixture:
    ```bash
    # From interchange JSON
    cargo run -p tenor-cli -- generate typescript --out /tmp/tenor-codegen-test conformance/positive/operation_basic.expected.json
    cat /tmp/tenor-codegen-test/operation-basic/types.ts
    cat /tmp/tenor-codegen-test/operation-basic/schemas.ts

    # From .tenor source
    cargo run -p tenor-cli -- generate typescript --out /tmp/tenor-codegen-test2 conformance/positive/operation_basic.tenor
    ```
    Verify both produce identical output directories.
  </action>
  <verify>
    All five pre-commit checks pass:
    1. `cargo fmt --all` (no changes)
    2. `cargo build --workspace` succeeds
    3. `cargo test --workspace` passes
    4. `cargo run -p tenor-cli -- test conformance` passes
    5. `cargo clippy --workspace -- -D warnings` clean

    End-to-end: `tenor generate typescript --out /tmp/test conformance/positive/operation_basic.expected.json` produces:
    - `/tmp/test/operation-basic/types.ts` with branded types, `OrderState` union, `OperationBasicFacts` interface, operation input interfaces
    - `/tmp/test/operation-basic/schemas.ts` with Zod validators and constructor helpers
  </verify>
  <done>
    `tenor generate typescript` command works end-to-end: accepts both .tenor and .json input, produces types.ts and schemas.ts with correct TypeScript types, branded strings, Zod validators, and entity state unions. All quality gates pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles all crates including tenor-codegen
2. `cargo test --workspace` passes with no regressions
3. `cargo run -p tenor-cli -- test conformance` conformance suite still green
4. `cargo clippy --workspace -- -D warnings` clean
5. `tenor generate typescript --out /tmp/test conformance/positive/integration_escrow.expected.json` produces branded types for Money, entity state unions for EscrowAccount and DeliveryRecord, fact interfaces, and Zod schemas
6. `tenor generate typescript --out /tmp/test conformance/positive/operation_basic.tenor` elaborates first, then generates identical output to the .json input
</verification>

<success_criteria>
- tenor-codegen crate fully implemented with interchange deserialization, TypeScript type emitter, and Zod schema emitter
- CLI `tenor generate typescript` command operational with `--out` and `--sdk-import` flags
- Generated types.ts includes branded types (TenorMoney, TenorDecimal, TenorDate, TenorDateTime, TenorDuration), entity state unions, fact interface, operation input interfaces, verdict type union
- Generated schemas.ts includes Zod validators for all fact types and branded type constructor helpers
- Accepts both .tenor source and interchange JSON as input
- All five pre-commit quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-typescript-code-generation/16-01-SUMMARY.md`
</output>
