---
phase: 01-agent-skill-examples
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/audit-agent/package.json
  - examples/audit-agent/src/auditor.ts
  - examples/audit-agent/src/report.ts
  - examples/audit-agent/src/cli.ts
  - examples/audit-agent/README.md
  - examples/audit-agent/tsconfig.json
autonomous: true
requirements:
  - SKEX-04

must_haves:
  truths:
    - "The audit agent generates a compliance report from a contract's provenance chains"
    - "The report traces each verdict back through its provenance: rule, stratum, facts used, verdicts used"
    - "The report includes a fact coverage matrix showing which facts influence which verdicts"
    - "The agent identifies potential compliance gaps: facts with no verdict dependency, verdicts with incomplete provenance"
    - "Reports are generated in both terminal-readable and markdown formats"
    - "The agent uses the TenorClient SDK to evaluate and trace"
  artifacts:
    - path: "examples/audit-agent/src/auditor.ts"
      provides: "Audit analysis engine -- provenance walking and gap detection"
      min_lines: 100
    - path: "examples/audit-agent/src/report.ts"
      provides: "Report formatting (terminal and markdown)"
      min_lines: 80
    - path: "examples/audit-agent/src/cli.ts"
      provides: "CLI entry point"
      min_lines: 30
    - path: "examples/audit-agent/package.json"
      provides: "npm package with SDK dependency"
    - path: "examples/audit-agent/README.md"
      provides: "Usage and compliance report interpretation guide"
      min_lines: 40
  key_links:
    - from: "examples/audit-agent/src/auditor.ts"
      to: "@tenor-lang/sdk"
      via: "TenorClient for evaluation and provenance retrieval"
      pattern: "TenorClient"
    - from: "examples/audit-agent/src/auditor.ts"
      to: "examples/audit-agent/src/report.ts"
      via: "passes audit findings to report formatter"
      pattern: "AuditReport"
    - from: "examples/audit-agent/src/cli.ts"
      to: "examples/audit-agent/src/auditor.ts"
      via: "orchestrates audit and output"
      pattern: "runAudit"
---

<objective>
Build an audit agent reference implementation that generates compliance reports from provenance chains.

Purpose: Show how an agent can use verdict provenance to build a complete audit trail -- which rules fired, what facts drove each decision, and where gaps exist. This is the "regulatory auditor" use case: given a contract evaluation, prove WHY each outcome was reached.

Output: Working audit agent in `examples/audit-agent/` that produces compliance reports.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@sdk/typescript/src/client.ts
@sdk/typescript/src/types.ts
@crates/eval/src/provenance.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement audit analysis engine and report formatter</name>
  <files>
    examples/audit-agent/package.json
    examples/audit-agent/tsconfig.json
    examples/audit-agent/src/auditor.ts
    examples/audit-agent/src/report.ts
  </files>
  <action>
Create `examples/audit-agent/` directory structure.

**package.json:**
```json
{
  "name": "@tenor-examples/audit-agent",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node --experimental-strip-types src/cli.ts",
    "audit": "node --experimental-strip-types src/cli.ts"
  },
  "devDependencies": {
    "typescript": "~5.7.0"
  }
}
```

No npm dependencies beyond the SDK (imported via relative path). Zero external deps.

**tsconfig.json:** Target ES2022, module NodeNext, strict mode.

**auditor.ts:**
Create the core audit analysis engine:

1. Define types:
   ```typescript
   interface AuditReport {
     contractId: string;
     timestamp: string;
     factInputs: FactInput[];
     verdictTraces: VerdictTrace[];
     factCoverage: FactCoverageEntry[];
     complianceGaps: ComplianceGap[];
     summary: AuditSummary;
   }

   interface FactInput { id: string; value: unknown; type: string; }
   interface VerdictTrace {
     verdictType: string;
     payload: unknown;
     rule: string;
     stratum: number;
     factsUsed: string[];
     verdictsUsed: string[];
     dependencyChain: string[];  // full chain: verdict <- rule <- facts
   }
   interface FactCoverageEntry {
     factId: string;
     usedByVerdicts: string[];
     usedByRules: string[];  // transitive through verdict provenance
   }
   interface ComplianceGap {
     type: 'orphan_fact' | 'shallow_provenance' | 'single_rule_dependency';
     description: string;
     severity: 'info' | 'warning' | 'critical';
     affectedItems: string[];
   }
   interface AuditSummary {
     totalFacts: number;
     totalVerdicts: number;
     factsWithCoverage: number;
     factsWithoutCoverage: number;
     gapCount: { info: number; warning: number; critical: number };
   }
   ```

2. `async function runAudit(tenorUrl: string, contractId: string, facts: Record<string, unknown>): Promise<AuditReport>`:
   - Create TenorClient
   - Call `client.invoke(contractId, facts)` to get evaluation result with verdicts
   - Call `client.listContracts()` to get the contract's declared fact list
   - Build `VerdictTrace` for each verdict by extracting provenance fields
   - Build `dependencyChain` by recursively following `verdicts_used` references (verdict A uses verdict B which uses facts X,Y)
   - Build `FactCoverageEntry` for each declared fact:
     - Walk all verdict provenance `facts_used` arrays
     - Map each fact to the verdicts that depend on it (direct and transitive)
   - Detect compliance gaps:
     - `orphan_fact`: A declared fact that no verdict references (severity: warning)
     - `shallow_provenance`: A verdict whose provenance chain is only 1 level deep and uses no other verdicts (severity: info -- not always a problem)
     - `single_rule_dependency`: A verdict type produced by exactly one rule with no redundancy (severity: info)
   - Compute summary statistics

3. Export `runAudit` and all types.

**report.ts:**
Create report formatters:

1. `formatTerminal(report: AuditReport): string` -- produces colorized terminal output:
   - Header: Contract ID, timestamp, fact count, verdict count
   - Section "Verdict Audit Trail": For each verdict, show type, payload, rule, stratum, dependency chain indented as a tree
   - Section "Fact Coverage Matrix": Table showing each fact and which verdicts depend on it
   - Section "Compliance Gaps": Grouped by severity, with descriptions
   - Footer: Summary statistics

2. `formatMarkdown(report: AuditReport): string` -- produces markdown:
   - H1: Compliance Audit Report
   - H2: Contract Metadata (table: id, timestamp, facts, verdicts)
   - H2: Verdict Audit Trail (for each verdict: heading, provenance table, dependency chain as nested list)
   - H2: Fact Coverage Matrix (markdown table: Fact | Verdicts | Rules)
   - H2: Compliance Gaps (for each gap: severity badge, description, affected items)
   - H2: Summary (stats table, overall assessment)

Use ANSI escape codes for terminal colors (green for info, yellow for warning, red for critical). No external dependency -- just string templates.
  </action>
  <verify>
    <automated>test -f /Users/bwb/src/riverline/tenor/examples/audit-agent/src/auditor.ts && test -f /Users/bwb/src/riverline/tenor/examples/audit-agent/src/report.ts && echo "Files exist"</automated>
    <manual>Review auditor.ts for correct provenance chain walking and gap detection logic</manual>
  </verify>
  <done>Audit engine traces provenance chains, builds fact coverage matrix, detects compliance gaps, and report formatter produces both terminal and markdown output.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI entry point and README</name>
  <files>
    examples/audit-agent/src/cli.ts
    examples/audit-agent/README.md
  </files>
  <action>
**cli.ts:**
Create a CLI that runs the audit agent:

1. Parse command-line arguments (no external arg parser -- use `process.argv`):
   - `--contract <id>` (required): Contract ID to audit
   - `--facts <path>` (required): Path to JSON file with fact values
   - `--format <terminal|markdown>` (default: terminal): Output format
   - `--output <path>` (optional): Write report to file instead of stdout
   - `--url <url>` (default: http://localhost:8080): Tenor evaluator URL
   - `--help`: Show usage

2. Read and parse the facts JSON file.
3. Call `runAudit(url, contractId, facts)`.
4. Format with the selected formatter.
5. Output to stdout or file.
6. Exit with code 1 if any critical gaps found, 0 otherwise.

Example usage:
```bash
node --experimental-strip-types src/cli.ts \
  --contract saas_subscription \
  --facts ../../domains/saas/test-facts.json \
  --format markdown \
  --output audit-report.md
```

Also create a sample facts file at `examples/audit-agent/sample-facts/saas.json` with the SaaS subscription facts from the existing agent-basics.ts example:
```json
{
  "current_seat_count": 5,
  "subscription_plan": "professional",
  "plan_features": {
    "max_seats": 50,
    "api_access": true,
    "sso_enabled": true,
    "custom_branding": false
  },
  "payment_ok": true,
  "account_age_days": 365,
  "cancellation_requested": false
}
```

**README.md:**
Write a README covering:

1. **Overview**: What the audit agent does -- generates compliance reports from contract evaluations by tracing provenance chains
2. **Why This Matters**: Regulatory auditors need to know WHY a decision was made, not just WHAT the decision was. Provenance chains provide this.
3. **Architecture**: CLI -> Auditor (provenance walker) -> TenorClient SDK -> tenor serve -> Contract evaluation with provenance
4. **Prerequisites**: Node.js 22+, running `tenor serve` with contracts loaded
5. **Quick Start**: Step-by-step with the sample SaaS facts
6. **Report Sections Explained**:
   - Verdict Audit Trail: what it shows, how to read dependency chains
   - Fact Coverage Matrix: how to identify which facts drive which decisions
   - Compliance Gaps: what each gap type means, when to worry
7. **Example Output**: Show a snippet of both terminal and markdown format
8. **Use Cases**: Insurance claim adjudication audit, healthcare decision tracing, trade finance compliance
  </action>
  <verify>
    <automated>test -f /Users/bwb/src/riverline/tenor/examples/audit-agent/src/cli.ts && test -f /Users/bwb/src/riverline/tenor/examples/audit-agent/README.md && test -f /Users/bwb/src/riverline/tenor/examples/audit-agent/sample-facts/saas.json && echo "Files exist"</automated>
  </verify>
  <done>CLI parses args, loads facts from file, runs audit, outputs formatted report. README explains report interpretation and use cases. Sample facts file provided for quick start.</done>
</task>

</tasks>

<verification>
1. All files exist in `examples/audit-agent/`
2. `cli.ts` parses arguments and orchestrates the audit
3. `auditor.ts` traces provenance and detects gaps
4. `report.ts` produces both terminal and markdown formats
5. Sample facts file works with the SaaS contract
</verification>

<success_criteria>
- Audit agent generates compliance reports from provenance chains
- Reports include: verdict audit trail, fact coverage matrix, compliance gaps
- Both terminal and markdown output formats work
- Sample facts file enables immediate demo with SaaS contract
- README explains how to interpret each report section
</success_criteria>

<output>
After completion, create `.planning/phases/01-agent-skill-examples/01-04-SUMMARY.md`
</output>
