---
phase: 01-agent-skill-examples
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/cli/src/main.rs
  - crates/cli/src/agent.rs
autonomous: true
requirements:
  - SKEX-01

must_haves:
  truths:
    - "Running `tenor agent <file.tenor>` starts an interactive REPL session"
    - "The REPL discovers the contract's facts, operations, and flows automatically"
    - "User can evaluate the contract by providing fact values at the prompt"
    - "User can run flow evaluation by selecting a flow and persona"
    - "User can get a plain-language explanation of the contract"
    - "The REPL prints verdicts with provenance after evaluation"
  artifacts:
    - path: "crates/cli/src/agent.rs"
      provides: "Interactive agent REPL module"
      min_lines: 150
    - path: "crates/cli/src/main.rs"
      provides: "Agent subcommand wired into CLI dispatch"
      contains: "Commands::Agent"
  key_links:
    - from: "crates/cli/src/agent.rs"
      to: "tenor_core::elaborate::elaborate"
      via: "elaborates .tenor file to get interchange bundle"
      pattern: "elaborate"
    - from: "crates/cli/src/agent.rs"
      to: "tenor_eval::evaluate"
      via: "evaluates contract against user-provided facts"
      pattern: "evaluate"
    - from: "crates/cli/src/main.rs"
      to: "crates/cli/src/agent.rs"
      via: "Commands::Agent dispatch"
      pattern: "agent::"
---

<objective>
Build `tenor agent` CLI subcommand that turns any contract into an interactive shell.

Purpose: Show that a single `.tenor` file is enough to spin up a fully interactive agent session -- no server needed, no code generation needed. The contract IS the specification AND the runtime.

Output: Working `tenor agent <file.tenor>` command with interactive REPL.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/cli/src/main.rs
@crates/cli/src/serve.rs
@crates/core/src/elaborate.rs
@crates/eval/src/lib.rs
@crates/eval/src/types.rs
@crates/cli/src/explain.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tenor agent REPL module</name>
  <files>crates/cli/src/agent.rs</files>
  <action>
Create a new module `crates/cli/src/agent.rs` that implements an interactive REPL for any Tenor contract.

The REPL flow:
1. Accept a `.tenor` file path. Elaborate it using `tenor_core::elaborate::elaborate()` to get the interchange bundle.
2. Deserialize the bundle to extract contract metadata: facts (with types and defaults), operations, flows, entities, and personas. Use `serde_json` to walk the interchange JSON -- do NOT import from `tenor-eval` types (maintain the interchange boundary).
3. Print a welcome banner showing: contract ID, number of facts/operations/flows/entities, and a help summary.
4. Enter a read-eval-print loop using `std::io::stdin()` line reading. Commands:
   - `help` -- show available commands
   - `facts` -- list all facts with their types and current values (if set)
   - `set <fact_id> <value>` -- set a fact value (parse JSON value from the rest of the line)
   - `unset <fact_id>` -- remove a fact value
   - `eval` -- evaluate the contract with current facts using `tenor_eval::evaluate()`. Print each verdict with type, payload, and provenance (rule, stratum, facts_used).
   - `flow <flow_id> <persona>` -- evaluate a flow using `tenor_eval::evaluate_flow()`. Print outcome, entity state changes, and steps executed.
   - `operations` -- list all operations with personas and effects
   - `explain` -- run `explain::explain()` on the bundle and print the summary
   - `reset` -- clear all fact values
   - `quit` / `exit` / Ctrl-D -- exit the REPL

Key implementation details:
- Store current facts in a `serde_json::Map<String, Value>` that accumulates across `set` commands.
- For `set`, parse the value as JSON. If it fails as JSON, treat it as a bare string (for Enum values like `set subscription_plan professional`). Support `true`/`false` as booleans, integers as numbers.
- For `eval`, construct the facts JSON object from the accumulated facts map and call `tenor_eval::evaluate(&bundle, &facts_json)`.
- For `flow`, call `tenor_eval::evaluate_flow(&bundle, &facts_json, flow_id, persona)`.
- Print errors inline (do not crash the REPL). Use `eprintln!` for errors, `println!` for results.
- The REPL prompt should be `tenor> `.
- Use `OutputFormat` from main.rs if passed through, but default to `Text` for the interactive session.

Do NOT add any external dependencies. Use only `std::io`, `serde_json`, and the existing `tenor_core`, `tenor_eval` crate deps.
  </action>
  <verify>
    <automated>cargo build --workspace 2>&1 | tail -5</automated>
    <manual>Run `cargo run -p tenor-cli -- agent domains/saas/saas_subscription.tenor` and verify it starts a REPL, responds to `help`, `facts`, `set`, `eval` commands</manual>
  </verify>
  <done>The agent module compiles, implements all REPL commands, and handles errors gracefully without panicking.</done>
</task>

<task type="auto">
  <name>Task 2: Wire agent subcommand into CLI and verify</name>
  <files>crates/cli/src/main.rs</files>
  <action>
Wire the agent module into the CLI:

1. Add `mod agent;` declaration at the top of `main.rs` (alongside `mod serve;`, etc.).
2. Add an `Agent` variant to the `Commands` enum:
   ```rust
   /// Start an interactive agent shell for a contract
   Agent {
       /// Path to the .tenor source file
       file: PathBuf,
   },
   ```
3. Add the match arm in `main()`:
   ```rust
   Commands::Agent { file } => {
       agent::run_agent(&file);
   }
   ```
4. Run the full pre-commit quality gate:
   - `cargo fmt --all`
   - `cargo build --workspace`
   - `cargo test --workspace`
   - `cargo run -p tenor-cli -- test conformance`
   - `cargo clippy --workspace -- -D warnings`

Fix any issues that arise. All five checks must pass.
  </action>
  <verify>
    <automated>cargo fmt --all && cargo build --workspace && cargo test --workspace && cargo run -p tenor-cli -- test conformance && cargo clippy --workspace -- -D warnings</automated>
  </verify>
  <done>`tenor agent` subcommand appears in `tenor --help`, all five quality gates pass, running `tenor agent domains/saas/saas_subscription.tenor` enters an interactive REPL.</done>
</task>

</tasks>

<verification>
1. `cargo run -p tenor-cli -- --help` shows `agent` subcommand
2. `cargo run -p tenor-cli -- agent domains/saas/saas_subscription.tenor` starts REPL
3. All pre-commit quality gates pass (fmt, build, test, conformance, clippy)
</verification>

<success_criteria>
- `tenor agent <file.tenor>` turns any contract into an interactive shell
- User can set facts, evaluate, run flows, list operations, and get explanations
- No external dependencies added
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-agent-skill-examples/01-01-SUMMARY.md`
</output>
