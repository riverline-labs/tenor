---
phase: 01-agent-skill-examples
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/slack-bot/package.json
  - examples/slack-bot/src/app.ts
  - examples/slack-bot/src/handlers.ts
  - examples/slack-bot/README.md
  - examples/slack-bot/tsconfig.json
autonomous: true
requirements:
  - SKEX-03

must_haves:
  truths:
    - "The Slack bot responds to slash commands for contract interaction"
    - "/tenor-list shows available contracts"
    - "/tenor-eval <contract> triggers a modal dialog to input facts and see verdicts"
    - "/tenor-explain <contract> returns a plain-language contract explanation"
    - "The bot uses the TenorClient SDK to communicate with tenor serve"
    - "Error messages are user-friendly Slack block messages, not raw errors"
  artifacts:
    - path: "examples/slack-bot/src/app.ts"
      provides: "Slack Bolt app entry point"
      min_lines: 30
    - path: "examples/slack-bot/src/handlers.ts"
      provides: "Slash command and interaction handlers"
      min_lines: 100
    - path: "examples/slack-bot/package.json"
      provides: "npm package with @slack/bolt and SDK dependencies"
      contains: "@slack/bolt"
    - path: "examples/slack-bot/README.md"
      provides: "Setup and usage instructions"
      min_lines: 40
  key_links:
    - from: "examples/slack-bot/src/handlers.ts"
      to: "@tenor-lang/sdk"
      via: "TenorClient for evaluator communication"
      pattern: "TenorClient"
    - from: "examples/slack-bot/src/app.ts"
      to: "examples/slack-bot/src/handlers.ts"
      via: "handler registration"
      pattern: "register"
---

<objective>
Build a Slack bot reference implementation for contract interaction via chat.

Purpose: Show how agents in a team communication tool can interact with contracts -- list, evaluate, and explain -- using natural slash command UX. Demonstrates the SDK in an event-driven, async context.

Output: Working Slack bot in `examples/slack-bot/` with slash commands and interactive modals.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@sdk/typescript/src/client.ts
@sdk/typescript/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Slack bot with slash command handlers</name>
  <files>
    examples/slack-bot/package.json
    examples/slack-bot/tsconfig.json
    examples/slack-bot/src/app.ts
    examples/slack-bot/src/handlers.ts
  </files>
  <action>
Create `examples/slack-bot/` directory structure.

**package.json:**
```json
{
  "name": "@tenor-examples/slack-bot",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node --experimental-strip-types src/app.ts",
    "dev": "node --experimental-strip-types --watch src/app.ts"
  },
  "dependencies": {
    "@slack/bolt": "^4.1.0"
  },
  "devDependencies": {
    "typescript": "~5.7.0"
  }
}
```

**tsconfig.json:** Target ES2022, module NodeNext, strict mode.

**handlers.ts:**
Create handler functions using the TenorClient SDK (imported via relative path `../../../sdk/typescript/src/index.ts`):

1. `handleList(client, say)` -- Slash command `/tenor-list`:
   - Calls `client.listContracts()`
   - Formats response as Slack Block Kit message with a section for each contract showing ID, fact count, operation count, flow count
   - If no contracts loaded, shows an info message

2. `handleEval(client, command, ack, respond)` -- Slash command `/tenor-eval <contract_id>`:
   - Parse contract_id from command text
   - If no contract_id provided, respond with usage hint
   - Call `client.getOperations(contractId)` to get the contract's operations (validates contract exists)
   - Call `client.listContracts()` to get fact names
   - Open a Slack modal (`views.open`) with:
     - Text inputs for each fact (use the facts list from the contract summary)
     - A submit button labeled "Evaluate"
   - Store contract_id in modal private_metadata for the submission handler

3. `handleEvalSubmission(client, tenorClient, view)` -- Modal submission:
   - Extract fact values from modal state
   - Parse each value as JSON (fall back to string)
   - Call `tenorClient.invoke(contractId, facts)`
   - Respond with verdict results formatted as Slack blocks:
     - Each verdict as a section: type, payload, rule, stratum
     - Provenance details in a context block

4. `handleExplain(client, command, respond)` -- Slash command `/tenor-explain <contract_id>`:
   - Parse contract_id from command text
   - Call `tenorClient.explain(contractId)`
   - Format the summary as a Slack markdown message (Slack uses mrkdwn, not standard markdown)
   - Truncate if over 3000 chars (Slack block limit)

5. Error handling for all handlers:
   - `ContractNotFoundError` -> "Contract not found" ephemeral message
   - `ConnectionError` -> "Cannot reach Tenor evaluator" ephemeral message
   - `EvaluationError` -> Show error details in a warning block
   - Generic errors -> "Something went wrong" with error message

6. Export a `registerHandlers(app, tenorClient)` function that wires all handlers to the Bolt app.

**app.ts:**
1. Import Bolt `App` from `@slack/bolt`
2. Import `TenorClient` from SDK
3. Import `registerHandlers` from `./handlers.ts`
4. Read config from env vars: `SLACK_BOT_TOKEN`, `SLACK_SIGNING_SECRET`, `SLACK_APP_TOKEN` (for socket mode), `TENOR_URL` (default `http://localhost:8080`)
5. Create Bolt app in socket mode (simplest for development -- no public URL needed)
6. Create TenorClient with the tenor URL
7. Call `registerHandlers(app, tenorClient)`
8. Start the app, print startup message

Socket mode is the right choice for a reference implementation because it works locally without ngrok or a public URL.
  </action>
  <verify>
    <automated>test -f /Users/bwb/src/riverline/tenor/examples/slack-bot/src/app.ts && test -f /Users/bwb/src/riverline/tenor/examples/slack-bot/src/handlers.ts && echo "Files exist"</automated>
    <manual>Review handlers.ts for correct Slack Block Kit usage and SDK integration</manual>
  </verify>
  <done>Slack bot handles /tenor-list, /tenor-eval (with modal), and /tenor-explain slash commands using the TenorClient SDK.</done>
</task>

<task type="auto">
  <name>Task 2: Create README with setup instructions</name>
  <files>examples/slack-bot/README.md</files>
  <action>
Write a README covering:

1. **Overview**: What the bot does -- contract interaction via Slack slash commands
2. **Architecture**: Slack App (Socket Mode) -> Bolt handlers -> TenorClient SDK -> tenor serve -> Contract
3. **Slack App Setup** (step-by-step):
   - Go to api.slack.com/apps, create new app from manifest (include a sample manifest YAML)
   - The manifest should define: slash commands (/tenor-list, /tenor-eval, /tenor-explain), bot token scopes (commands, chat:write), socket mode enabled, interactivity enabled
   - Install to workspace, copy Bot Token and App Token
4. **Environment Variables**:
   - `SLACK_BOT_TOKEN` -- Bot User OAuth Token (xoxb-...)
   - `SLACK_SIGNING_SECRET` -- App Signing Secret
   - `SLACK_APP_TOKEN` -- App-Level Token with connections:write scope (xapp-...)
   - `TENOR_URL` -- URL of running tenor serve (default: http://localhost:8080)
5. **Quick Start**:
   - Start tenor serve: `tenor serve --port 8080 domains/saas/saas_subscription.tenor`
   - Set env vars
   - Run: `node --experimental-strip-types src/app.ts`
6. **Usage Examples** with screenshots/descriptions of:
   - `/tenor-list` showing available contracts
   - `/tenor-eval saas_subscription` opening the modal
   - `/tenor-explain saas_subscription` showing the explanation
7. **Extending**: How to add new commands, customize formatting, add approval workflows

Include the Slack app manifest YAML inline so users can paste it directly.
  </action>
  <verify>
    <automated>test -f /Users/bwb/src/riverline/tenor/examples/slack-bot/README.md && echo "README exists"</automated>
  </verify>
  <done>README provides complete setup instructions including Slack app manifest, env vars, and usage examples for all three slash commands.</done>
</task>

</tasks>

<verification>
1. All files exist in `examples/slack-bot/`
2. `app.ts` creates Bolt app in socket mode
3. `handlers.ts` implements all three slash commands with proper error handling
4. README includes Slack app manifest and working setup instructions
</verification>

<success_criteria>
- Slack bot responds to /tenor-list, /tenor-eval, /tenor-explain commands
- /tenor-eval uses a modal for fact input
- Results are formatted as Slack Block Kit messages
- Error handling is user-friendly (no raw stack traces in Slack)
- README has complete setup guide including app manifest
</success_criteria>

<output>
After completion, create `.planning/phases/01-agent-skill-examples/01-03-SUMMARY.md`
</output>
