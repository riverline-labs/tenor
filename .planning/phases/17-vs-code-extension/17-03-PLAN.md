---
phase: 17-vs-code-extension
plan: 03
type: execute
wave: 3
depends_on: ["17-02"]
files_modified:
  - crates/lsp/src/navigation.rs
  - crates/lsp/src/completion.rs
  - crates/lsp/src/hover.rs
  - crates/lsp/src/server.rs
  - crates/lsp/src/lib.rs
autonomous: true
requirements: [DEVX-02]

must_haves:
  truths:
    - "Ctrl+clicking a construct reference (fact ref, entity ref, operation ref) jumps to its declaration"
    - "Hovering over a construct reference shows its type and a brief summary"
    - "Typing inside a construct body triggers completions for field names, construct references, and type references"
    - "Find All References on a construct declaration lists all references to it across the project"
  artifacts:
    - path: "crates/lsp/src/navigation.rs"
      provides: "Go-to-definition, find-all-references, and document symbol support"
      min_lines: 80
    - path: "crates/lsp/src/completion.rs"
      provides: "Context-aware completions for fields, references, and types"
      min_lines: 60
    - path: "crates/lsp/src/hover.rs"
      provides: "Hover information with type and construct summary"
      min_lines: 40
  key_links:
    - from: "crates/lsp/src/navigation.rs"
      to: "crates/core/src/pass2_index.rs"
      via: "construct index for definition lookup"
      pattern: "build_index"
    - from: "crates/lsp/src/server.rs"
      to: "crates/lsp/src/navigation.rs"
      via: "request dispatch for goto/references"
      pattern: "textDocument/definition"
    - from: "crates/lsp/src/completion.rs"
      to: "crates/core/src/pass3_types.rs"
      via: "type environment for type completions"
      pattern: "build_type_env"
---

<objective>
Implement LSP navigation features: go-to-definition, find-all-references, hover information, and context-aware completions.

Purpose: These features make Tenor contracts navigable and discoverable — authors can explore construct relationships, understand types at a glance, and write faster with auto-completions. This transforms the editor from a syntax checker to an intelligent authoring environment.

Output: Full LSP navigation support including go-to-definition, find-all-references, hover, completions, and document symbols.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-vs-code-extension/17-02-SUMMARY.md
@crates/core/src/ast.rs
@crates/core/src/pass2_index.rs
@crates/core/src/pass3_types.rs
@crates/lsp/src/server.rs
@crates/lsp/src/document.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement go-to-definition and find-all-references</name>
  <files>
    crates/lsp/src/navigation.rs
    crates/lsp/src/server.rs
    crates/lsp/src/lib.rs
  </files>
  <action>
**crates/lsp/src/navigation.rs:**

Create a `ProjectIndex` struct that caches construct locations across the workspace:
- `declarations: HashMap<(ConstructKind, String), Location>` — maps (kind, id) to file:line of declaration
- `references: HashMap<(ConstructKind, String), Vec<Location>>` — maps (kind, id) to all reference locations
- `symbols: HashMap<Url, Vec<DocumentSymbol>>` — per-file document symbols

`build_project_index(root_path: &Path) -> ProjectIndex`:
1. Find all .tenor files under the root path
2. For each file, call `tenor_core::lexer::lex()` and `tenor_core::parser::parse()` (swallow errors — best-effort)
3. Walk the parsed constructs:
   - Record each construct's declaration location (kind, id, file, line)
   - Walk expression trees in rules, operations, flows to find references:
     - `fact_ref` → reference to a Fact
     - Entity names in effects → reference to an Entity
     - Operation names in flow steps → reference to an Operation
     - Flow names in sub-flow steps → reference to a Flow
     - Persona names in allowed_personas → reference to a Persona
     - Type names in declarations → reference to a TypeDecl
4. Build DocumentSymbol trees for each file (construct declarations with nested field symbols)

`goto_definition(index: &ProjectIndex, uri: &Url, position: Position) -> Option<Location>`:
1. Get the word at position in the source text
2. Look up in declarations by trying each ConstructKind (Fact, Entity, Operation, Flow, Persona, TypeDecl)
3. Return the declaration Location if found

`find_references(index: &ProjectIndex, uri: &Url, position: Position) -> Vec<Location>`:
1. Get the word at position
2. Determine which construct it refers to (check declarations first to identify the kind)
3. Return all reference locations plus the declaration itself

`document_symbols(index: &ProjectIndex, uri: &Url) -> Vec<DocumentSymbol>`:
1. Return cached symbols for the file

**crates/lsp/src/server.rs** updates:
- Add to ServerCapabilities:
  - `definition_provider`: Some(OneOf::Left(true))
  - `references_provider`: Some(OneOf::Left(true))
  - `document_symbol_provider`: Some(OneOf::Left(true))
- Maintain a `ProjectIndex` in the server state, rebuild on file save (debounce by only rebuilding changed file)
- Handle requests:
  - `textDocument/definition` → call goto_definition
  - `textDocument/references` → call find_references
  - `textDocument/documentSymbol` → call document_symbols
- On initialize: determine workspace root from rootUri or rootPath in InitializeParams, build initial ProjectIndex

Run `cargo build --workspace && cargo clippy --workspace -- -D warnings`.
  </action>
  <verify>
`cargo build --workspace` succeeds.
`cargo clippy --workspace -- -D warnings` passes.
`cargo test --workspace` passes.
  </verify>
  <done>Go-to-definition jumps to construct declarations. Find-all-references lists all usages. Document symbols appear in the outline view. Navigation works across imported files.</done>
</task>

<task type="auto">
  <name>Task 2: Implement hover and completions</name>
  <files>
    crates/lsp/src/hover.rs
    crates/lsp/src/completion.rs
    crates/lsp/src/server.rs
    crates/lsp/src/lib.rs
  </files>
  <action>
**crates/lsp/src/hover.rs:**
- `compute_hover(index: &ProjectIndex, uri: &Url, position: Position, content: &str) -> Option<Hover>`:
  1. Get word at position from the source text
  2. Look up in project index to determine construct kind and id
  3. Build hover content (MarkupContent, kind: Markdown):
     - **Fact**: show `fact fact_name : Type` with default value if present
     - **Entity**: show `entity EntityName` with states list
     - **Operation**: show `operation op_name` with allowed_personas, precondition summary, effects summary, outcomes
     - **Flow**: show `flow flow_name` with entry_point and step count
     - **Persona**: show `persona persona_name`
     - **Rule**: show `rule rule_name` with verdict type
     - **Type**: show `type TypeName` with field definitions for Record types, variants for Enum/TaggedUnion
  4. Return Hover with contents and range (word boundaries)

**crates/lsp/src/completion.rs:**
- `compute_completions(index: &ProjectIndex, uri: &Url, position: Position, content: &str) -> Vec<CompletionItem>`:
  1. Analyze context at position — what kind of construct body are we in?
     - Detect by scanning backwards for the nearest construct keyword
  2. Build completion list based on context:
     - **Top level** (not inside any construct): offer construct keywords (entity, fact, rule, operation, flow, persona, type, system, import)
     - **Inside entity body**: offer field keywords (states, initial_state)
     - **Inside operation body**: offer field keywords (allowed_personas, precondition, effects, outcomes, error_contract, postcondition)
     - **Inside rule body**: offer field keywords (when, then)
     - **Inside flow body**: offer field keywords (entry_point, steps)
     - **Inside when/precondition block**: offer fact names from index (CompletionItemKind::Variable), verdict_present(), comparison operators
     - **Inside effects block**: offer entity names from index (CompletionItemKind::Class), state names
     - **Inside allowed_personas**: offer persona names from index (CompletionItemKind::Module)
     - **After a type position** (e.g., `fact name :`): offer built-in types (Int, Decimal, Money, Bool, String, Date, DateTime, Duration) + declared types from index
     - **Inside flow step operations**: offer operation names from index (CompletionItemKind::Function)
     - **Inside transition arrows**: offer entity state names
  3. Each CompletionItem includes: label, kind, detail (short type info), documentation (longer description)

**crates/lsp/src/server.rs** updates:
- Add to ServerCapabilities:
  - `hover_provider`: Some(HoverProviderCapability::Simple(true))
  - `completion_provider`: Some(CompletionOptions { trigger_characters: Some(vec![":".into(), " ".into()]), resolve_provider: Some(false), ..Default::default() })
- Handle requests:
  - `textDocument/hover` → call compute_hover
  - `textDocument/completion` → call compute_completions, wrap in CompletionResponse::Array

**crates/lsp/src/lib.rs:** Add `pub mod navigation;`, `pub mod hover;`, `pub mod completion;`

Run the full pre-commit quality gate:
```
cargo fmt --all
cargo build --workspace
cargo test --workspace
cargo run -p tenor-cli -- test conformance
cargo clippy --workspace -- -D warnings
```
  </action>
  <verify>
All Rust quality gates pass (fmt, build, test, conformance, clippy).
`cargo test --workspace` includes no regressions.
  </verify>
  <done>Hovering over construct references shows type and summary. Completions offer context-aware suggestions for field names, construct references, built-in types, and declared types. All LSP navigation features working: goto-definition, find-all-references, hover, completions, document symbols.</done>
</task>

</tasks>

<verification>
1. All Rust quality gates pass: `cargo fmt --all && cargo build --workspace && cargo test --workspace && cargo run -p tenor-cli -- test conformance && cargo clippy --workspace -- -D warnings`
2. Go-to-definition on a fact_ref in a rule jumps to the fact declaration
3. Hover on an operation name shows its allowed_personas and effects
4. Completions inside a rule's when block offer fact names
5. Find-all-references on an entity shows all operations that reference it
6. Document symbols appear in VS Code's outline/breadcrumb view
</verification>

<success_criteria>
- Go-to-definition works for all construct reference types (facts, entities, operations, flows, personas, types)
- Find-all-references lists all usages across the project
- Hover shows construct type, fields, and summary
- Completions are context-aware based on position within construct body
- Document symbols enable outline and breadcrumb navigation
- All existing tests and conformance suite continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/17-vs-code-extension/17-03-SUMMARY.md`
</output>
