---
phase: 17-vs-code-extension
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - crates/lsp/Cargo.toml
  - crates/lsp/src/lib.rs
  - crates/lsp/src/server.rs
  - crates/lsp/src/diagnostics.rs
  - crates/lsp/src/semantic_tokens.rs
  - crates/lsp/src/document.rs
  - crates/cli/src/main.rs
  - crates/cli/Cargo.toml
  - Cargo.toml
  - editors/vscode/package.json
  - editors/vscode/src/extension.ts
autonomous: true
requirements: [DEVX-01, DEVX-02, DEVX-03]

must_haves:
  truths:
    - "Saving a .tenor file shows inline error diagnostics in VS Code (red squiggles at the correct line)"
    - "Errors stop at first failing pass — no cascading downstream errors shown"
    - "Valid .tenor files show no diagnostics after save"
    - "Semantic tokens provide construct-aware coloring on top of TextMate grammar"
    - "Import resolution works — cross-file errors from imported files show correctly"
    - "The LSP server starts via 'tenor lsp' CLI subcommand over stdio"
  artifacts:
    - path: "crates/lsp/src/server.rs"
      provides: "LSP server main loop with request/notification dispatch"
      min_lines: 100
    - path: "crates/lsp/src/diagnostics.rs"
      provides: "Elaboration-to-diagnostic conversion with first-failing-pass stop"
      min_lines: 30
    - path: "crates/lsp/src/semantic_tokens.rs"
      provides: "Semantic token provider for construct-aware highlighting"
      min_lines: 80
    - path: "crates/lsp/src/document.rs"
      provides: "Document state management for open files"
      min_lines: 30
    - path: "editors/vscode/src/extension.ts"
      provides: "Language client connecting to tenor lsp server"
  key_links:
    - from: "crates/lsp/src/diagnostics.rs"
      to: "crates/core/src/elaborate.rs"
      via: "elaborate() call"
      pattern: "tenor_core::elaborate"
    - from: "crates/lsp/src/server.rs"
      to: "crates/lsp/src/diagnostics.rs"
      via: "diagnostic computation on textDocument/didSave"
      pattern: "compute_diagnostics"
    - from: "editors/vscode/src/extension.ts"
      to: "crates/cli/src/main.rs"
      via: "spawn tenor lsp process over stdio"
      pattern: "ServerOptions"
    - from: "crates/lsp/src/semantic_tokens.rs"
      to: "crates/core/src/parser.rs"
      via: "parse tree to semantic token mapping"
      pattern: "load_bundle\\|parse"
---

<objective>
Implement the LSP server in the tenor-lsp crate and wire it to the VS Code extension for diagnostics and semantic tokens.

Purpose: This is the core developer experience — authors get immediate feedback on errors when they save, plus richer syntax highlighting through semantic tokens that distinguish fact refs from entity refs from type refs. The `tenor lsp` subcommand makes the LSP available to any editor.

Output: Working LSP server providing check-on-save diagnostics and semantic token highlighting, connected to VS Code via the language client.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-vs-code-extension/17-01-SUMMARY.md
@crates/core/src/elaborate.rs
@crates/core/src/error.rs
@crates/core/src/parser.rs
@crates/core/src/ast.rs
@crates/core/src/lexer.rs
@crates/core/src/pass1_bundle.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LSP server core with diagnostics</name>
  <files>
    crates/lsp/Cargo.toml
    crates/lsp/src/lib.rs
    crates/lsp/src/server.rs
    crates/lsp/src/diagnostics.rs
    crates/lsp/src/document.rs
    Cargo.toml
  </files>
  <action>
**Cargo.toml (workspace):** Add `lsp-server` and `lsp-types` as workspace dependencies:
- `lsp-server = "0.7"` (synchronous LSP scaffolding — same approach as rust-analyzer, NO async runtime needed)
- `lsp-types = "0.97"` (LSP type definitions)

**crates/lsp/Cargo.toml:** Add dependencies:
- `tenor-core = { path = "../core" }`
- `tenor-analyze = { path = "../analyze" }`
- `lsp-server.workspace = true`
- `lsp-types.workspace = true`
- `serde_json.workspace = true`
- `serde.workspace = true`

**crates/lsp/src/lib.rs:** Re-export `server::run` as the public API entry point.

**crates/lsp/src/document.rs:**
- `DocumentState` struct: HashMap<Url, DocumentInfo> where DocumentInfo holds file path, version, and optional cached parse result
- Methods: `open(url, text)`, `change(url, text)`, `close(url)`, `get(url) -> Option<&DocumentInfo>`
- Tracks which documents are open in the editor

**crates/lsp/src/diagnostics.rs:**
- `compute_diagnostics(file_path: &Path) -> Vec<lsp_types::Diagnostic>`:
  1. Call `tenor_core::elaborate::elaborate(file_path)`
  2. On success: return empty vec (no diagnostics)
  3. On error: convert `ElabError` to a single `lsp_types::Diagnostic`:
     - Map `line` to 0-indexed LSP position (ElabError line is 1-indexed)
     - Set severity to `DiagnosticSeverity::ERROR`
     - Set message to the ElabError message
     - Set source to "tenor"
     - This naturally stops at first failing pass since `elaborate()` returns the first error
  4. On any other error (file not found, etc.): return a single diagnostic at line 0

**crates/lsp/src/server.rs:**
- `pub fn run() -> Result<(), Box<dyn std::error::Error>>`:
  1. Create `lsp_server::Connection::stdio()` for stdio transport
  2. Build `ServerCapabilities`:
     - `text_document_sync`: Some(TextDocumentSyncOptions) with save: Some(SaveOptions with include_text: false), open_close: true, change: TextDocumentSyncKind::FULL
     - `semantic_tokens_provider`: (see Task 2 for full setup, stub with None initially)
  3. Send `InitializeResult` with capabilities and server_info (name: "tenor-lsp", version: TENOR_VERSION)
  4. Main loop: match on `msg` from `connection.receiver`:
     - `Message::Request(req)`: handle shutdown request, respond to others with method-not-found
     - `Message::Notification(not)`: dispatch:
       - `textDocument/didOpen`: update document state, compute and publish diagnostics
       - `textDocument/didSave`: compute and publish diagnostics
       - `textDocument/didClose`: clear diagnostics for the file, remove from document state
       - `textDocument/didChange`: update document state (store content for semantic tokens)
     - `Message::Response(_)`: ignore
  5. `publish_diagnostics(connection, uri, diagnostics)`: send `textDocument/publishDiagnostics` notification

The server is synchronous — no tokio, no async. Uses crossbeam channels under the hood via lsp-server. This matches the project's synchronous architecture exactly.

Run `cargo build --workspace` and `cargo clippy --workspace -- -D warnings` to verify.
  </action>
  <verify>
`cargo build --workspace` succeeds.
`cargo clippy --workspace -- -D warnings` passes.
`cargo test --workspace` passes.
  </verify>
  <done>LSP server starts over stdio, responds to initialize, publishes diagnostics on save and open, and stops at first failing elaboration pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add semantic tokens and wire VS Code language client</name>
  <files>
    crates/lsp/src/semantic_tokens.rs
    crates/lsp/src/server.rs
    crates/cli/src/main.rs
    crates/cli/Cargo.toml
    editors/vscode/package.json
    editors/vscode/src/extension.ts
  </files>
  <action>
**crates/lsp/src/semantic_tokens.rs:**
- Define semantic token types for Tenor constructs:
  - `KEYWORD` (construct keywords: entity, rule, operation, flow, etc.)
  - `TYPE` (type references: Int, Decimal, Money, Bool, String, etc.)
  - `VARIABLE` (fact references in expressions)
  - `PROPERTY` (field names within construct bodies: states, allowed_personas, effects, etc.)
  - `ENUM_MEMBER` (state names in entity state lists, enum variants)
  - `FUNCTION` (operation references in flow steps)
  - `CLASS` (entity references)
  - `NAMESPACE` (persona references)
  - `STRING`, `NUMBER`, `COMMENT`
- `TOKEN_TYPES`: static array of `SemanticTokenType` values
- `TOKEN_MODIFIERS`: `declaration`, `definition`, `readonly`
- `compute_semantic_tokens(file_path: &Path, content: &str) -> Option<Vec<SemanticToken>>`:
  1. Call `tenor_core::lexer::lex(content)` to get tokens (this is fast and doesn't fail on incomplete files)
  2. Call `tenor_core::pass1_bundle::load_bundle(file_path)` to get parsed constructs (swallow errors — semantic tokens are best-effort)
  3. Walk through the token stream and parsed constructs:
     - Tag construct declaration keywords with KEYWORD + declaration modifier
     - Tag construct name identifiers with their construct type (CLASS for entities, FUNCTION for operations, etc.)
     - Tag field labels (word followed by `:`) with PROPERTY
     - Tag type names with TYPE
     - Tag fact references in when/precondition blocks with VARIABLE
     - Tag entity references in effects blocks with CLASS
     - Tag persona references in allowed_personas with NAMESPACE
     - Tag state names with ENUM_MEMBER
  4. Convert to LSP relative-position encoded SemanticTokens
  5. Sort tokens by position before encoding

**crates/lsp/src/server.rs** updates:
- Add `semantic_tokens_provider` to ServerCapabilities:
  - SemanticTokensOptions with full: Some(SemanticTokensFullOptions::Bool(true))
  - legend: SemanticTokensLegend with token_types from TOKEN_TYPES, token_modifiers from TOKEN_MODIFIERS
- Handle `textDocument/semanticTokens/full` request:
  1. Get document content from DocumentState
  2. Call `compute_semantic_tokens()`
  3. Return SemanticTokensResult

**crates/cli/Cargo.toml:** Add `tenor-lsp = { path = "../lsp" }` dependency.

**crates/cli/src/main.rs:**
- Add `Lsp` variant to the Cli enum (subcommand `lsp` with no arguments)
- Handler: call `tenor_lsp::run()` and handle errors
- This is similar to how `tenor serve` was added in Phase 15

**editors/vscode/package.json** updates:
- Add `vscode-languageclient` to dependencies: `"vscode-languageclient": "^9.0.0"`
- Add `semanticTokenScopes` contribution to map semantic token types to TextMate scopes:
  - "keyword" -> ["keyword.declaration.tenor"]
  - "type" -> ["support.type.tenor"]
  - "variable" -> ["variable.other.readwrite.tenor"]
  - "property" -> ["variable.other.property.tenor"]
  - "enumMember" -> ["variable.other.enummember.tenor"]
  - "function" -> ["entity.name.function.tenor"]
  - "class" -> ["entity.name.type.class.tenor"]
  - "namespace" -> ["entity.name.type.namespace.tenor"]
- Add `tenor.checkOnType` configuration contribution (boolean, default false, description: "Check Tenor files on every keystroke (debounced). Default is check on save only.")

**editors/vscode/src/extension.ts:**
- Import `LanguageClient`, `ServerOptions`, `LanguageClientOptions` from `vscode-languageclient/node`
- In `activate()`:
  1. Find the `tenor` binary — check settings for custom path, fall back to `tenor` on PATH
  2. Create `ServerOptions`: command = tenor binary path, args = ["lsp"], transport = stdio
  3. Create `LanguageClientOptions`: documentSelector = [{scheme: "file", language: "tenor"}]
  4. Create and start `LanguageClient`
  5. Store client reference for deactivation
- In `deactivate()`: stop the language client if running
- Run `cd editors/vscode && npm install && npm run compile`

Run the full pre-commit quality gate:
```
cargo fmt --all
cargo build --workspace
cargo test --workspace
cargo run -p tenor-cli -- test conformance
cargo clippy --workspace -- -D warnings
```

Also verify: `cd editors/vscode && npm run compile`
  </action>
  <verify>
All Rust quality gates pass (fmt, build, test, conformance, clippy).
`cd editors/vscode && npm run compile` succeeds.
`cargo run -p tenor-cli -- lsp` starts and accepts stdio input (send initialize request, verify response).
  </verify>
  <done>LSP server provides semantic tokens with construct-aware highlighting. VS Code extension connects to `tenor lsp` server over stdio. Saving a .tenor file shows diagnostics. Semantic tokens enhance TextMate grammar with context-aware coloring of fact refs, entity refs, type refs, and persona refs.</done>
</task>

</tasks>

<verification>
1. All Rust quality gates pass: `cargo fmt --all && cargo build --workspace && cargo test --workspace && cargo run -p tenor-cli -- test conformance && cargo clippy --workspace -- -D warnings`
2. VS Code extension compiles: `cd editors/vscode && npm run compile`
3. `tenor lsp` subcommand starts and responds to LSP initialize handshake
4. Opening a valid .tenor file shows no error diagnostics
5. Opening an invalid .tenor file shows error diagnostic at the correct line
6. Semantic tokens provide enhanced coloring beyond TextMate grammar
</verification>

<success_criteria>
- LSP server implemented in tenor-lsp crate using synchronous lsp-server + lsp-types
- `tenor lsp` CLI subcommand starts the server over stdio
- Diagnostics published on save with first-failing-pass behavior
- Semantic tokens provide construct-aware coloring (fact refs, entity refs, types, personas distinct)
- VS Code extension connects to LSP via vscode-languageclient
- All existing tests and conformance suite continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/17-vs-code-extension/17-02-SUMMARY.md`
</output>
