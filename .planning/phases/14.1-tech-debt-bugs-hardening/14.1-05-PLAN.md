---
phase: 14.1-tech-debt-bugs-hardening
plan: 05
type: execute
wave: 3
depends_on: ["14.1-03", "14.1-04"]
files_modified:
  - crates/eval/src/flow.rs
  - crates/eval/src/lib.rs
  - crates/analyze/src/s6_flow_paths.rs
  - crates/cli/src/main.rs
  - crates/cli/src/ambiguity/api.rs
  - crates/cli/src/ambiguity/mod.rs
autonomous: true
requirements: []

must_haves:
  truths:
    - "Operation lookup in flow execution is O(1) via HashMap, not O(n) linear scan"
    - "Flow step limit is configurable via execute_flow parameter (default 1000)"
    - "S6 path enumeration limits are configurable via analysis API"
    - "tenor generate prints a clear not-yet-implemented message with exit code 2"
    - "Ambiguity module uses a non-dated model alias as default"
    - "AmbiguityRunResult summary stats are printed to stderr"
    - "All existing tests pass"
  artifacts:
    - path: "crates/eval/src/flow.rs"
      provides: "O(1) operation lookup and configurable step limit"
      contains: "HashMap"
    - path: "crates/analyze/src/s6_flow_paths.rs"
      provides: "Configurable MAX_PATHS and MAX_DEPTH"
      contains: "max_paths"
  key_links:
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/lib.rs"
      via: "configurable max_steps parameter threaded through"
      pattern: "max_steps"
    - from: "crates/cli/src/main.rs"
      to: "crates/cli/src/ambiguity/mod.rs"
      via: "AmbiguityRunResult fields used for summary"
      pattern: "total|matches|mismatches"
---

<objective>
Fix performance bottlenecks in flow execution, make limits configurable, and clean up miscellaneous tech debt items (generate stub, model alias, dead code stats).

Purpose: Address the remaining "fix before Phase 15/19 ships" items: O(n) operation lookup per flow step (perf), unconfigurable flow step limit (fragile), unconfigurable S6 limits (scaling). Also clean up the "address but not blocking" items: generate stub messaging, hardcoded ambiguity model name, and dead code stats. Per CONTEXT.md implementation order, this is the final plan.

Output: Performant flow execution, configurable limits, clean CLI surface.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/phases/14.1-tech-debt-bugs-hardening/14.1-01-SUMMARY.md
@.planning/phases/14.1-tech-debt-bugs-hardening/14.1-03-SUMMARY.md

Key references:
- O(n) operation lookup: crates/eval/src/flow.rs:258-264, flow.rs:111-113
- Hardcoded step limit: crates/eval/src/flow.rs:228
- S6 limits: crates/analyze/src/s6_flow_paths.rs:15-17
- Generate stub: crates/cli/src/main.rs:177-178
- Model alias: crates/cli/src/ambiguity/api.rs:12
- Dead code stats: crates/cli/src/ambiguity/mod.rs:43-51
</context>

<tasks>

<task type="auto">
  <name>Task 1: O(1) operation lookup and configurable flow step limit</name>
  <files>
    crates/eval/src/flow.rs
    crates/eval/src/lib.rs
  </files>
  <action>
    1. **Operation index**: In `execute_flow()`, after building `step_index` (~line 218-222), build an operation index using the same pattern:
       ```rust
       use std::collections::HashMap;

       let op_index: HashMap<&str, &Operation> = contract
           .operations
           .iter()
           .map(|o| (o.id.as_str(), o))
           .collect();
       ```
       Replace the two `contract.operations.iter().find(|o| o.id == *op)` calls (~lines 258-264) with `op_index.get(op.as_str())`. The error message on not-found should remain the same.

    2. **Compensation operation lookup**: The `handle_failure` function (~line 110-113) also does a linear scan. Pass the `op_index` reference into `handle_failure` as a parameter so it can use O(1) lookup too. Update the function signature and all call sites.

    3. **Configurable step limit**: Change `execute_flow` signature to accept an optional max steps parameter:
       ```rust
       pub fn execute_flow(
           flow: &Flow,
           contract: &Contract,
           snapshot: &Snapshot,
           entity_states: &mut EntityStateMap,
           max_steps: Option<usize>,
       ) -> Result<FlowResult, EvalError> {
           // ...
           let max_steps = max_steps.unwrap_or(1000);
       ```
       Update all callers of `execute_flow` (in lib.rs `evaluate_flow` and anywhere else) to pass `None` for the default behavior. This preserves backward compatibility.

    4. Add a unit test that:
       - Calls `execute_flow` with `max_steps: Some(5)` on a flow that would take more than 5 steps
       - Verifies it returns `FlowError` with the step limit message
       - Calls `execute_flow` with `None` to verify default 1000 is used
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass. The operation index doesn't change behavior, only performance.
  </verify>
  <done>Operation lookup is O(1) in both the main step loop and compensation handler. Flow step limit is configurable via `max_steps` parameter with 1000 default. Unit test verifies configurable limit.</done>
</task>

<task type="auto">
  <name>Task 2: Configurable S6 limits + generate stub + model alias + dead code cleanup</name>
  <files>
    crates/analyze/src/s6_flow_paths.rs
    crates/cli/src/main.rs
    crates/cli/src/ambiguity/api.rs
    crates/cli/src/ambiguity/mod.rs
  </files>
  <action>
    **S6 configurable limits:**

    1. In `crates/analyze/src/s6_flow_paths.rs`, change `MAX_PATHS` and `MAX_DEPTH` from `const` to parameters:
       - Add a `FlowPathConfig` struct: `pub struct FlowPathConfig { pub max_paths: usize, pub max_depth: usize }`
       - Add `impl Default for FlowPathConfig` with max_paths=10_000, max_depth=1_000
       - Update the path enumeration function to accept `&FlowPathConfig` (or `Option<FlowPathConfig>`)
       - Update all callers to pass `FlowPathConfig::default()` or `None`
       This doesn't change behavior but makes the limits configurable for Phase 19 (embedded evaluator with different resource constraints).

    **Generate stub:**

    2. In `crates/cli/src/main.rs`, find the `generate` subcommand handler (currently calls `stub_not_implemented`). Update the message to be more informative:
       ```rust
       eprintln!("tenor generate: code generation is not yet implemented.");
       eprintln!("This feature is planned for Phase 16 (TypeScript Code Generation).");
       eprintln!("See: https://github.com/your-repo/issues or docs/TENOR.md Section 16");
       std::process::exit(2);
       ```
       The exit code 2 convention is correct per the CLI design. The improvement is the human-readable message explaining WHAT and WHEN.

    **Model alias:**

    3. In `crates/cli/src/ambiguity/api.rs`, change:
       ```rust
       const DEFAULT_MODEL: &str = "claude-sonnet-4-5-20250514";
       ```
       to:
       ```rust
       const DEFAULT_MODEL: &str = "claude-sonnet-4-5";
       ```
       The non-dated alias always points to the latest version. This prevents breakage when Anthropic deprecates dated model snapshots.

    **AmbiguityRunResult summary:**

    4. In `crates/cli/src/main.rs` where `cmd_ambiguity` handles the `AmbiguityRunResult`, after checking `hard_errors`, print a summary:
       ```rust
       eprintln!("\nAmbiguity test summary: {} total, {} matches, {} mismatches, {} hard errors",
           result.total, result.matches, result.mismatches, result.hard_errors);
       ```
       Remove the `#[allow(dead_code)]` annotations from the `total`, `matches`, and `mismatches` fields in `crates/cli/src/ambiguity/mod.rs` since they are now consumed.
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    cargo clippy --workspace -- -D warnings
    ```
    All pass. Verify no dead_code warnings for AmbiguityRunResult fields:
    ```bash
    cargo clippy --workspace -- -D warnings 2>&1 | grep -i "ambiguity\|dead_code" || echo "Clean"
    ```
  </verify>
  <done>S6 limits configurable via FlowPathConfig. Generate stub prints informative message. Ambiguity model uses non-dated alias. AmbiguityRunResult stats printed and dead_code allows removed. All quality gates pass.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- clean formatting
2. `cargo build --workspace` -- compiles without errors
3. `cargo test --workspace` -- all tests pass
4. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings (especially: no dead_code warnings for AmbiguityRunResult)
</verification>

<success_criteria>
- Operation lookup is O(1) via HashMap in flow execution
- Flow step limit configurable, defaults to 1000
- S6 path limits configurable via FlowPathConfig struct
- `tenor generate` prints helpful not-implemented message
- Ambiguity default model uses non-dated alias
- AmbiguityRunResult stats surfaced in CLI output
- All five quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-tech-debt-bugs-hardening/14.1-05-SUMMARY.md`
</output>
