---
phase: 14.1-tech-debt-bugs-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/pass5_validate.rs
  - crates/core/src/pass3_types.rs
  - crates/core/src/pass4_typecheck.rs
autonomous: true
requirements: []

must_haves:
  truths:
    - "The elaborator never panics on any user input -- all unwrap sites return ElabError or use expect with invariant text"
    - "Existing conformance tests (positive and negative) all still pass"
    - "Each converted unwrap site has a targeted unit test proving the error path works"
  artifacts:
    - path: "crates/core/src/pass5_validate.rs"
      provides: "Unwrap-free graph traversal in trigger acyclicity and flow reference cycle detection"
      contains: "ElabError"
    - path: "crates/core/src/pass3_types.rs"
      provides: "Unwrap-free type cycle detection"
      contains: "ElabError"
    - path: "crates/core/src/pass4_typecheck.rs"
      provides: "Expect-annotated min/max on known-non-empty array"
      contains: "expect("
  key_links:
    - from: "crates/core/src/pass5_validate.rs"
      to: "crates/core/src/error.rs"
      via: "ElabError return"
      pattern: "ElabError"
    - from: "crates/core/src/pass3_types.rs"
      to: "crates/core/src/error.rs"
      via: "ElabError return"
      pattern: "ElabError"
---

<objective>
Convert all fragile `unwrap()` calls in tenor-core elaboration passes to proper error handling.

Purpose: Prevent the elaborator from panicking on user input. The current unwrap sites in pass3, pass4, and pass5 depend on caller-maintained invariants; if those invariants shift during future refactoring, the elaborator crashes instead of producing an error message. Per CONTEXT.md decision #4: targeted tests for the specific unwrap sites being fixed.

Output: Zero panic-on-user-input paths in the elaboration pipeline, with unit tests proving each converted site.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

Key unwrap sites:
- pass5_validate.rs:716 -- in_degree.get_mut(neighbor).unwrap() in trigger acyclicity
- pass5_validate.rs:828 -- path.iter().position().unwrap() in flow reference cycle detection
- pass5_validate.rs:1326 -- path.iter().position().unwrap() in trigger graph cycle detection
- pass3_types.rs:47,52,54,56,84,120 -- 6 unwrap sites in type cycle detection DFS
- pass4_typecheck.rs:177-178 -- products.iter().min/max().unwrap() on 4-element array
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert pass5_validate.rs unwrap sites to proper error handling</name>
  <files>
    crates/core/src/pass5_validate.rs
  </files>
  <action>
    Convert three `unwrap()` calls to proper error returns:

    1. **Line ~716**: `in_degree.get_mut(neighbor).unwrap()` in the trigger acyclicity check (Kahn's algorithm). Replace with:
       ```rust
       let deg = in_degree.get_mut(neighbor).ok_or_else(|| ElabError {
           pass: 5,
           construct_kind: "System".to_string(),
           construct_id: system_id.to_string(),
           field: "triggers".to_string(),
           file: file.to_string(),
           line,
           message: format!("internal error: trigger neighbor '{}' not found in in_degree map", neighbor),
       })?;
       ```
       This requires the enclosing function to return `Result<_, ElabError>` -- check that it already does (it should, since it's a validation function). If the function returns `Vec<ElabError>`, push the error instead.

    2. **Line ~828**: `path.iter().position(|&s| s == ref_flow).unwrap()` in flow reference cycle detection. Replace with `.expect("ref_flow must be in path when cycle detected")` -- this is an algorithmic invariant (the DFS only detects a cycle when the node IS in path), so `expect` with explanation is the right fix. Alternatively, use `ok_or_else` returning an ElabError if you prefer consistency.

    3. **Line ~1326**: `path.iter().position(|&n| n == neighbor).unwrap()` in trigger graph cycle detection. Same pattern as #2 -- replace with `expect("neighbor must be in path when back-edge detected")` or `ok_or_else` with ElabError.

    For each converted site, add a `#[cfg(test)]` unit test in the same file that exercises the error path. The test should construct minimal input that would trigger the error condition (e.g., a deliberately inconsistent in_degree map).

    **Important**: Read the surrounding code carefully before editing. The validation functions may collect errors in a `Vec<ElabError>` rather than returning `Result`. Match the existing error-handling pattern of each function.
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass. Verify no unwrap() calls remain on these specific lines:
    ```bash
    grep -n '\.unwrap()' crates/core/src/pass5_validate.rs
    ```
    Should show zero matches (or only matches inside #[test] functions).
  </verify>
  <done>All three unwrap sites in pass5_validate.rs converted to proper error handling. Each has a unit test exercising the error path. Zero panics possible on user input in Pass 5.</done>
</task>

<task type="auto">
  <name>Task 2: Convert pass3_types.rs and pass4_typecheck.rs unwrap sites</name>
  <files>
    crates/core/src/pass3_types.rs
    crates/core/src/pass4_typecheck.rs
  </files>
  <action>
    **pass3_types.rs** -- 6 unwrap sites in the type cycle detection DFS:

    1. **Line ~47**: `in_stack.iter().position(|x| x == name).unwrap()` -- this is called only when `in_stack.contains(name)` was already checked (it's inside the cycle-detected branch). Replace with `.expect("name must be in in_stack when cycle detected")`.

    2. **Line ~52**: `in_stack.last().unwrap()` -- called only when in_stack is non-empty (we just found a cycle, meaning at least one element). Replace with `.expect("in_stack is non-empty during cycle detection")`.

    3. **Line ~54**: `decls.get(back_edge_name.as_str()).unwrap()` -- assumes the back-edge name exists in decls. This COULD fail if decls is inconsistent. Replace with:
       ```rust
       decls.get(back_edge_name.as_str()).ok_or_else(|| ElabError {
           pass: 3,
           construct_kind: "TypeDecl".to_string(),
           construct_id: back_edge_name.to_string(),
           field: String::new(),
           file: String::new(),
           line: 0,
           message: format!("internal error: type '{}' referenced in cycle but not found in declarations", back_edge_name),
       })?
       ```
       Check if the function returns `Result` -- if it returns `Vec<ElabError>`, adapt accordingly.

    4. **Line ~56**: Same pattern as #3 -- second `decls.get(back_edge_name.as_str()).unwrap()`. Convert identically.

    5. **Line ~84**: `decls.get(name).unwrap().clone()` -- called during recursive resolution. Replace with proper error return.

    6. **Line ~120**: `decls.get(name).unwrap()` -- same pattern. Replace with proper error return.

    For pass3_types.rs, add 1-2 targeted unit tests in a `#[cfg(test)]` module that verify the error paths work (e.g., call resolve with a name not in decls).

    **pass4_typecheck.rs** -- 2 unwrap sites (lines 177-178):

    Replace:
    ```rust
    let prod_min = *products.iter().min().unwrap();
    let prod_max = *products.iter().max().unwrap();
    ```
    with:
    ```rust
    let prod_min = *products.iter().min().expect("products array has exactly 4 elements");
    let prod_max = *products.iter().max().expect("products array has exactly 4 elements");
    ```
    This is a compile-time-visible invariant (the array literal is 2 lines above), so `expect` is appropriate. No unit test needed for this specific case since the invariant is trivially verifiable by inspection.
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass. Verify:
    ```bash
    grep -n '\.unwrap()' crates/core/src/pass3_types.rs  # Should be 0 in non-test code
    grep -n '\.unwrap()' crates/core/src/pass4_typecheck.rs  # Should be 0 in non-test code
    ```
  </verify>
  <done>All unwrap sites in pass3_types.rs (6 sites) and pass4_typecheck.rs (2 sites) converted. pass3 has targeted unit tests. Zero panic-on-user-input paths in passes 3, 4, and 5.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- clean formatting
2. `cargo build --workspace` -- compiles without errors
3. `cargo test --workspace` -- all tests pass, including new unit tests
4. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. `grep -c '\.unwrap()' crates/core/src/pass5_validate.rs crates/core/src/pass3_types.rs crates/core/src/pass4_typecheck.rs` -- only matches in test code
</verification>

<success_criteria>
- 11 unwrap sites across pass3/pass4/pass5 converted to expect or error returns
- New unit tests exercise error paths for the riskiest conversions (pass3 and pass5)
- All existing conformance tests (positive and negative) still pass
- All five quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-tech-debt-bugs-hardening/14.1-02-SUMMARY.md`
</output>
