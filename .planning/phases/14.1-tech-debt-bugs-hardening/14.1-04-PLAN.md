---
phase: 14.1-tech-debt-bugs-hardening
plan: 04
type: execute
wave: 2
depends_on: ["14.1-01"]
files_modified:
  - crates/cli/src/explain.rs
  - crates/cli/src/main.rs
  - crates/cli/tests/cli_integration.rs
autonomous: true
requirements: []

must_haves:
  truths:
    - "explain.rs consumes a typed ExplainBundle struct, not raw serde_json::Value traversal"
    - "If the interchange format changes a key name, deserialization fails loudly instead of silently dropping sections"
    - "All existing explain CLI integration tests still pass"
    - "Explain output for all 5 domain contracts is unchanged"
  artifacts:
    - path: "crates/cli/src/explain.rs"
      provides: "ExplainBundle struct and typed deserialization for explain output"
      contains: "struct ExplainBundle"
  key_links:
    - from: "crates/cli/src/explain.rs"
      to: "serde_json"
      via: "serde::Deserialize on ExplainBundle"
      pattern: "#\\[derive.*Deserialize"
    - from: "crates/cli/src/main.rs"
      to: "crates/cli/src/explain.rs"
      via: "cmd_explain call"
      pattern: "explain::"
---

<objective>
Replace untyped JSON traversal in explain.rs with a dedicated ExplainBundle struct that fails loudly on interchange format changes.

Purpose: explain.rs currently uses 75+ `.as_str()`, `.as_array()`, `.as_object()` calls with silent `.unwrap_or` fallbacks. If the interchange format changes a key name or type, entire explain sections silently disappear. Per CONTEXT.md decision #1: use a dedicated `ExplainBundle` struct covering exactly what explain.rs needs -- NOT full `Contract` deserialization from tenor-eval (wrong dependency direction). Per decision #5: tests are part of the work.

Output: Typed deserialization in explain.rs that catches interchange format drift at parse time.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/phases/14.1-tech-debt-bugs-hardening/14.1-01-SUMMARY.md

Key references:
- explain.rs: 1181 lines, 75+ untyped JSON traversals
- Interchange format defined by docs/interchange-schema.json
- explain.rs reads: facts, entities (with states), operations (with preconditions, effects, outcomes, allowed_personas), rules (with when/then, stratum), flows (with steps, entry), personas, type_decls, systems
- ExplainFormat enum: Terminal (ANSI) and Markdown
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define ExplainBundle struct and migrate explain.rs to typed deserialization</name>
  <files>
    crates/cli/src/explain.rs
  </files>
  <action>
    1. At the top of explain.rs (or in a submodule if the file is cleaner that way), define an `ExplainBundle` struct and supporting types using `#[derive(Deserialize)]`:

       ```rust
       use serde::Deserialize;

       #[derive(Deserialize)]
       struct ExplainBundle {
           #[serde(default)]
           facts: Vec<ExplainFact>,
           #[serde(default)]
           entities: Vec<ExplainEntity>,
           #[serde(default)]
           operations: Vec<ExplainOperation>,
           #[serde(default)]
           rules: Vec<ExplainRule>,
           #[serde(default)]
           flows: Vec<ExplainFlow>,
           #[serde(default)]
           personas: Vec<ExplainPersona>,
           #[serde(default)]
           type_decls: Vec<ExplainTypeDecl>,
           #[serde(default)]
           systems: Vec<ExplainSystem>,
       }
       ```

       Define sub-structs for each construct kind containing ONLY the fields that explain.rs actually reads. Use `serde_json::Value` for deeply nested or rarely-accessed fields that don't warrant their own struct (like precondition expressions). Use `#[serde(default)]` on optional fields.

       Key sub-structs needed (derive from what explain.rs currently accesses):
       - `ExplainFact` { id, type (as serde_json::Value for flexibility), default_value }
       - `ExplainEntity` { id, states }
       - `ExplainOperation` { id, precondition (Value), effects (Vec<Value>), outcomes (Vec<String>), allowed_personas (Vec<String>), error_contract (Option<String>) }
       - `ExplainRule` { id, when (Value), then (Vec<Value>), stratum }
       - `ExplainFlow` { id, entry, steps (Vec<Value>), personas (Vec<String>) }
       - `ExplainPersona` { id }
       - `ExplainTypeDecl` { id, fields (Option<Value>) }
       - `ExplainSystem` { id, members (Vec<Value>) }

       Use `#[serde(rename = "...")]` where the JSON key differs from the Rust field name.

    2. Change the main explain function signature to accept `&serde_json::Value` (as it does now), but immediately deserialize into `ExplainBundle`:
       ```rust
       let bundle: ExplainBundle = serde_json::from_value(raw_bundle.clone())
           .map_err(|e| format!("failed to parse interchange bundle: {}", e))?;
       ```
       If the current function signature doesn't return Result, change it to do so. Propagate the error up to cmd_explain in main.rs. Specifically: update `cmd_explain` in `crates/cli/src/main.rs` (around line 1001) to handle the `Result<String, String>` returned by `explain()`, converting the error case into a user-facing error message and non-zero exit code.

    3. Rewrite all the body functions (contract summary, fact inventory, entity/operation/rule/flow descriptions) to use the typed struct fields instead of `.as_str().unwrap_or("")` chains. This is the bulk of the work.

       For each section of explain output:
       - Replace `bundle["facts"].as_array().unwrap_or(&vec![])` with `&bundle.facts`
       - Replace `fact["id"].as_str().unwrap_or("?")` with `&fact.id`
       - Replace deep Value traversals with struct field access
       - Keep `serde_json::Value` fields where the structure is complex and only needs `.to_string()` or simple extraction

    4. Ensure the output is byte-for-byte identical to the current output for all domain contracts. The refactor should change the code structure, not the output.

    5. Add a unit test that deserializes a minimal interchange bundle into ExplainBundle and verifies all fields are populated. This ensures future interchange changes break the test, not silently drop output.
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass. Then verify explain output hasn't changed:
    ```bash
    # Test against a domain contract
    cargo run -p tenor-cli -- explain conformance/domains/saas_subscription/saas_subscription.tenor 2>&1 | head -50
    # Should produce the same output as before
    ```
  </verify>
  <done>explain.rs uses ExplainBundle struct with serde::Deserialize. All 75+ untyped JSON traversals replaced with typed field access. Interchange format changes cause deserialization errors instead of silent output drops. Output is unchanged for all contracts.</done>
</task>

<task type="auto">
  <name>Task 2: Add explain integration test for format drift detection</name>
  <files>
    crates/cli/tests/cli_integration.rs
  </files>
  <action>
    1. Add an integration test to `crates/cli/tests/cli_integration.rs` that runs `tenor explain` against a conformance fixture and asserts that:
       - The exit code is 0
       - The output contains expected section headers (e.g., "Contract Summary", "Fact Inventory", "Operations", "Rules", "Flows")
       - The output is non-empty for each section

    2. Add a second integration test that runs `tenor explain --output markdown` and verifies:
       - Exit code is 0
       - Output contains markdown headers (`#`, `##`)
       - Output is non-empty

    These tests complement the existing CLI integration tests and specifically target the concern that explain output sections could silently disappear.
  </action>
  <verify>
    ```bash
    cargo test -p tenor-cli -- explain
    ```
    New tests pass.
  </verify>
  <done>Integration tests verify explain output contains all expected sections in both terminal and markdown formats. Silent section drops will be caught.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- clean formatting
2. `cargo build --workspace` -- compiles without errors
3. `cargo test --workspace` -- all tests pass
4. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass
5. `cargo clippy --workspace -- -D warnings` -- no warnings
6. `cargo run -p tenor-cli -- explain conformance/domains/saas_subscription/saas_subscription.tenor` -- output matches pre-refactor
</verification>

<success_criteria>
- ExplainBundle struct with Deserialize covers all fields explain.rs accesses
- Zero raw `.as_str()`, `.as_array()`, `.as_object()` calls remain on the bundle root or construct-level fields (deep Value access within preconditions/effects is acceptable)
- Interchange format changes cause deserialization errors, not silent drops
- Explain output unchanged for all domain contracts
- Integration tests verify section presence in both terminal and markdown formats
- All five quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-tech-debt-bugs-hardening/14.1-04-SUMMARY.md`
</output>
