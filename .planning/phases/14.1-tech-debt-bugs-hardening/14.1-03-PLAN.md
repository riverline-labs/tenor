---
phase: 14.1-tech-debt-bugs-hardening
plan: 03
type: execute
wave: 2
depends_on: ["14.1-01"]
files_modified:
  - crates/core/src/pass1_bundle.rs
  - crates/eval/src/assemble.rs
  - Cargo.toml
  - crates/eval/Cargo.toml
autonomous: true
requirements: []

must_haves:
  truths:
    - "Import paths cannot escape the root contract's directory via ../ traversal"
    - "If canonicalize() fails, the import is rejected with an ElabError (fail closed)"
    - "Date facts like 2024-13-45 are rejected as invalid"
    - "DateTime facts like 2024-01-15Tgarbage are rejected as invalid"
    - "Valid dates (including leap year Feb 29) are accepted"
    - "All existing conformance tests still pass"
  artifacts:
    - path: "crates/core/src/pass1_bundle.rs"
      provides: "Sandboxed import path resolution"
      contains: "canonicalize"
    - path: "crates/eval/src/assemble.rs"
      provides: "Calendar-correct date and datetime validation"
      contains: "time::"
  key_links:
    - from: "crates/core/src/pass1_bundle.rs"
      to: "filesystem"
      via: "canonicalize + starts_with check"
      pattern: "starts_with.*root"
    - from: "crates/eval/src/assemble.rs"
      to: "time crate"
      via: "date parsing dependency"
      pattern: "time::Date"
---

<objective>
Add import path sandboxing to prevent directory traversal attacks and fix date/datetime validation to reject semantically invalid dates.

Purpose: Two "fix before Phase 15 ships" items. Import sandboxing is critical if tenor-core gets embedded in a server (catastrophic path traversal). Date validation currently accepts garbage like "2024-99-99" because it only checks digit positions. Per CONTEXT.md decision #2: use a minimal date parsing dependency (the `time` crate). Per decision #3: fail closed on canonicalize failure. Per decision #5: tests are part of the work.

Output: Secure import resolution, calendar-correct date validation, tests for both.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/phases/14.1-tech-debt-bugs-hardening/14.1-01-SUMMARY.md

Key references:
- Import path resolution: crates/core/src/pass1_bundle.rs:167 (base_dir.join(import_path) with no prefix check)
- Date validation: crates/eval/src/assemble.rs:71-81 (format-only check)
- DateTime validation: crates/eval/src/assemble.rs:87-91 (date prefix + T, no time validation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sandbox import path resolution in pass1_bundle.rs</name>
  <files>
    crates/core/src/pass1_bundle.rs
  </files>
  <action>
    Add a security boundary to import path resolution. The current code at ~line 167 does `base_dir.join(import_path)` with no restriction on where the resolved path ends up.

    1. Determine the "root directory" -- this is the directory of the originally-invoked .tenor file (the entry point, not any intermediate import). The root must be computed once and threaded through the recursive import resolution. Check how `load_bundle` receives its arguments to determine the best place to establish the root.

    2. After `base_dir.join(import_path)`, attempt `canonicalize()` on the resolved path:
       - If `canonicalize()` fails (file doesn't exist, permission denied, etc.), return an `ElabError` with pass 1, explaining the import path could not be resolved. Per CONTEXT.md decision #3: **fail closed**.
       - If `canonicalize()` succeeds, check that the canonical path `starts_with()` the canonical root directory. If not, return an `ElabError` explaining the import attempts to escape the contract root directory.

    3. Also canonicalize the root directory itself (once, at the start of load_bundle) so the comparison is against real paths, not symlink-dependent relative paths.

    4. Add a negative conformance test in `conformance/negative/pass1/` that attempts `import "../escape.tenor"` and expects an error about escaping the contract directory. The test fixture needs:
       - A `.tenor` file with the malicious import
       - A `.expected-error.json` with pass 1, appropriate message

    5. Add a unit test in pass1_bundle.rs (or a Rust test in the core crate) that verifies:
       - Normal relative imports within the same directory work
       - `../` traversal outside root is rejected
       - Nonexistent import paths are rejected (canonicalize failure)
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass, including the new negative conformance test. Then manually verify:
    ```bash
    # Create a temp .tenor file that tries to escape
    echo 'import "../Cargo.toml"' > /tmp/test_escape.tenor
    cargo run -p tenor-cli -- elaborate /tmp/test_escape.tenor 2>&1 | grep -i "escape\|sandbox\|outside"
    # Should show an error, not attempt to parse Cargo.toml
    ```
  </verify>
  <done>Import paths are sandboxed to the root contract's directory. Canonicalize failures reject the import (fail closed). Negative conformance test and unit tests verify both the escape and nonexistent-path cases.</done>
</task>

<task type="auto">
  <name>Task 2: Fix date/datetime validation with the time crate</name>
  <files>
    crates/eval/src/assemble.rs
    Cargo.toml
    crates/eval/Cargo.toml
  </files>
  <action>
    1. Add the `time` crate as a dependency:
       - In workspace `Cargo.toml` under `[workspace.dependencies]`: `time = "0.3"`
       - In `crates/eval/Cargo.toml`: `time = { workspace = true }`
       The `time` crate is lightweight, well-maintained, and handles calendar correctness (leap years, month bounds). Per CONTEXT.md decision #2: use a proven library, not hand-rolled calendar logic.

    2. Replace `validate_date_format` in `crates/eval/src/assemble.rs`:
       ```rust
       pub fn validate_date_format(s: &str) -> bool {
           use time::Date;
           use time::macros::format_description;
           let format = format_description!("[year]-[month]-[day]");
           Date::parse(s, &format).is_ok()
       }
       ```
       This validates both format AND calendar correctness. "2024-02-29" passes (leap year), "2024-02-30" fails, "2024-13-01" fails.

    3. Replace `validate_datetime_format` in `crates/eval/src/assemble.rs`:
       ```rust
       pub fn validate_datetime_format(s: &str) -> bool {
           use time::PrimitiveDateTime;
           use time::macros::format_description;
           // Accept ISO 8601: YYYY-MM-DDThh:mm:ss with optional fractional seconds and timezone
           // For simplicity, validate at least YYYY-MM-DDThh:mm:ss
           if s.len() < 19 {
               return false;
           }
           let format = format_description!("[year]-[month]-[day]T[hour]:[minute]:[second]");
           PrimitiveDateTime::parse(&s[..19], &format).is_ok()
       }
       ```
       This validates the date portion for calendar correctness AND the time portion for valid hours/minutes/seconds. Timezone suffixes (Z, +00:00) are accepted by checking only the first 19 characters.

    4. Add unit tests in assemble.rs (in a `#[cfg(test)]` module) covering:
       - Valid dates: "2024-01-15", "2024-02-29" (leap), "2023-12-31"
       - Invalid dates: "2024-13-01", "2024-02-30", "2023-02-29" (not leap), "2024-99-99"
       - Valid datetimes: "2024-01-15T10:30:00", "2024-01-15T10:30:00Z", "2024-01-15T10:30:00+05:00"
       - Invalid datetimes: "2024-01-15Tgarbage", "2024-13-01T10:30:00", "2024-01-15T25:00:00"

    5. Run the full test suite to ensure no existing eval tests break. Some eval fixtures may use date values -- they should all be valid dates and continue to pass.
  </action>
  <verify>
    ```bash
    cargo build --workspace
    cargo test --workspace
    cargo run -p tenor-cli -- test conformance
    ```
    All pass. Specifically check the new date validation tests:
    ```bash
    cargo test -p tenor-eval -- validate_date
    ```
  </verify>
  <done>Date validation rejects "2024-13-45" and "2024-02-30" while accepting valid dates including leap years. DateTime validation rejects "2024-01-15Tgarbage" while accepting valid ISO 8601 timestamps. Unit tests cover all edge cases.</done>
</task>

</tasks>

<verification>
1. `cargo fmt --all` -- clean formatting
2. `cargo build --workspace` -- compiles without errors
3. `cargo test --workspace` -- all tests pass, including new security and date tests
4. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass (including new negative test)
5. `cargo clippy --workspace -- -D warnings` -- no warnings
</verification>

<success_criteria>
- Import paths sandboxed: traversal outside root rejected, canonicalize failure rejects import
- Date validation calendar-correct via `time` crate
- DateTime validation checks both date and time portions
- Negative conformance test for import escape
- Unit tests for date/datetime edge cases
- All five quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-tech-debt-bugs-hardening/14.1-03-SUMMARY.md`
</output>
