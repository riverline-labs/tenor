---
phase: 01-spec-completion
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - docs/cffp/p5-shared-types.json
  - docs/TENOR.md
autonomous: true
requirements:
  - SPEC-03
  - SPEC-05

must_haves:
  truths:
    - "Shared type library has import semantics for cross-contract Record and TaggedUnion reuse"
    - "Type resolution terminates — no circular type imports"
    - "Imported types compose with local types without ambiguity"
    - "P5 CFFP artifact exists and conforms to docs/cffp.cue schema"
    - "P5 spec section in docs/TENOR.md defines syntax, semantics, elaboration rules, interchange representation"
  artifacts:
    - path: "docs/cffp/p5-shared-types.json"
      provides: "Complete CFFP instance for P5 Shared type library"
      contains: "phase6"
    - path: "docs/TENOR.md"
      provides: "Shared type library section with import semantics, type identity rules, and cross-contract elaboration"
      contains: "import"
  key_links:
    - from: "docs/cffp/p5-shared-types.json"
      to: "docs/TENOR.md"
      via: "CFFP canonical form translated to spec section"
      pattern: "canonical.*formal_statement"
    - from: "docs/TENOR.md (shared types section)"
      to: "docs/TENOR.md (Section 4 BaseType)"
      via: "Shared types extend the TypeDecl mechanism with cross-contract imports"
      pattern: "import|TypeDecl"
---

<objective>
Execute CFFP run for P5 Shared type library and translate the canonical form into a formal spec section in docs/TENOR.md.

Purpose: Record and TaggedUnion types are currently per-contract only (spec Section 4.5). P5 introduces cross-contract type reuse with import semantics. This is the hardest construct — the user explicitly flagged it as potentially producing a scoped-down canonical form with acknowledged limitations, which is a valid CFFP outcome. This is the third and final CFFP run; it depends on both Persona and P7 canonical forms.

Output: `docs/cffp/p5-shared-types.json` (complete CFFP instance), updated `docs/TENOR.md` with shared type library section.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-spec-completion/01-CONTEXT.md
@.planning/phases/01-spec-completion/01-RESEARCH.md
@.planning/phases/01-spec-completion/01-01-SUMMARY.md
@.planning/phases/01-spec-completion/01-02-SUMMARY.md
@docs/cffp.cue
@docs/cffp/persona.json
@docs/cffp/p7-outcome-typing.json
@docs/TENOR.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execute full CFFP run for P5 Shared type library</name>
  <files>docs/cffp/p5-shared-types.json</files>
  <action>
Produce `docs/cffp/p5-shared-types.json` — a complete CFFP instance conforming to `docs/cffp.cue#CFFPInstance`.

**IMPORTANT: This is the hardest CFFP run.** The user acknowledged P5 "may produce a scoped-down canonical form with acknowledged limitations, which is a valid CFFP outcome." Embrace this. Do not force a maximalist design. P5 module federation (inter-org type sharing) is explicitly deferred to v2 (SPEC-06). Generic type parameters for Records are v2 (SPEC-07). The scope is: within a single organization's contracts, how can Record and TaggedUnion types be shared?

**Consider sub-phasing:** Per Claude's discretion, P5 may warrant sub-phases within the CFFP run — type identity (structural vs nominal) is a hard subproblem that should be settled before import semantics. If sub-phasing, the CFFP instance should still be a single document but the phase notes should explain the decomposition.

**Phase 1 — Invariant Declaration:**
Starting invariants from CONTEXT.md:
- I1: Type resolution terminates — no circular type imports (class: termination)
- I2: Imported types compose with local types without ambiguity — a type reference resolves to exactly one concrete type (class: determinism)
- I3: Circular type imports are detected and rejected at elaboration time (class: soundness)

Derive additional invariants from design constraints (C1-C7):
- I4: Cross-contract type resolution is decidable (class: decidability) — C1
- I5: Closed-world semantics preserved — imported types do not introduce external references that affect evaluation (class: soundness) — C5
- I6: Type identity is deterministic — two agents given the same contract set must agree on whether types are identical (class: determinism) — C3
- I7: The set of imported types is statically determinable — no runtime type resolution (class: analyzability) — C4
- I8: All type imports are explicit — no implicit type propagation across contract boundaries (class: composability) — C6

**Phase 2 — Candidate Formalisms:**
Generate at least 2 candidates addressing the core design questions:

**Type Identity subproblem:**
Current Tenor uses structural typing (TypeDecl inlines to BaseType; two Records with identical fields are the same type). For cross-contract sharing, the choice is:
- Structural: `Contract_A.LineItem` = `Contract_B.LineItem` if fields match
- Nominal: `Contract_A.LineItem` != `Contract_B.LineItem` regardless of fields (different origin = different type)
- Nominal-with-source: Types are identified by their declaring contract + name

**Import mechanism subproblem:**
How does one contract reference types from another?
- New `import type` syntax
- Contract-qualified type references (`@other_contract.TypeName`)
- Shared type library files (`.tenor-types` or similar)

Candidate formalisms should combine choices from both subproblems:

- Candidate A: Structural + Import — Types remain structurally typed. `import type LineItem from "shared_types.tenor"` brings the type into scope. At elaboration time, the imported TypeDecl is inlined just like local TypeDecls. Cross-contract, two Records with identical fields are the same type regardless of origin. Simple, minimal change to existing semantics.

- Candidate B: Nominal-with-source + Qualified References — Types gain nominal identity tied to their declaring file. `use @"types.tenor"` imports a type library, references are `types.LineItem`. Two types with identical fields but different sources are different types. Requires type compatibility rules for cross-contract operation.

- Candidate C: Scoped-down minimal — Shared type libraries are plain `.tenor` files containing only `type` declarations. They are imported with existing `import` syntax. Imported types are structurally inlined during elaboration (same as current TypeDecl). No new type identity semantics. This is the minimal-change candidate.

Each candidate must include proof sketches for ALL invariants, complexity bounds, and failure modes. Pay special attention to how each handles C5 (closed-world) — imported types must not introduce external evaluation dependencies.

**Phase 3 — Pressure:**
Generate counterexamples targeting each candidate. Key pressure points:
- Test: Diamond import — Contract A imports Type T from Library L. Contract B also imports Type T from Library L. Are they the same type? (Structural: yes. Nominal: depends.)
- Test: Shadowing — Contract declares local type `LineItem` and also imports `LineItem` from a library. Which wins?
- Test: Recursive cross-contract types — Library L1 has Record with field of type from L2, L2 has Record with field of type from L1. Cycle?
- Test: Import chain depth — A imports from B imports from C. Is there a depth limit? Does C5 survive?
- Test: Version mismatch — Library was authored against spec v1.0 but contract is v1.1. Does structural typing make this safe?

Composition test against ALL depends_on constructs: Fact, Entity, Rule, Operation, Flow, TypeDecl, Persona, AND P7 outcomes.
Key composition tests:
- TypeDecl (Section 4.5): How do imported types interact with local TypeDecl? Can a local TypeDecl reference an imported type?
- Fact: Facts with imported types — type is resolved from import, not local.
- Entity: Entity fields using imported types.
- Rule: Rules producing verdicts with imported types.
- Operation: Operation effects referencing entities with imported types.
- Flow: Flow steps with operations using imported types.

**Survivor Derivation:** Populate `derived`. If all candidates are eliminated, diagnose per Phase 3b — invariants too strong, candidates too weak, or construct incoherent. A scoped-down reframe is valid.

**Phase 4 — Collapse Test:** Only if multiple survivors.

**Phase 5 — Static Analysis Obligations:** Prove:
- Type resolution across contract boundaries terminates
- Cross-contract type graph is acyclic (or prove cycle detection)
- All S1-S7 analyses still work correctly when types are imported

**Phase 6 — Canonicalization:** Produce formal statement defining: shared type import syntax, type identity semantics, elaboration rules for cross-contract type resolution, interchange representation for shared types (do they appear in interchange or remain inlined?), validation rules.

A canonical form with acknowledged limitations (e.g., "module federation deferred", "no generic parameters", "import depth bounded") is fully acceptable and expected.
  </action>
  <verify>
Validate the CFFP artifact:
- JSON parses without error
- Contains all required top-level fields per #CFFPInstance
- construct.depends_on includes ["Fact", "Entity", "Rule", "Operation", "Flow", "TypeDecl", "Persona", "P7 Operation Outcome Typing"] (or equivalent names matching prior CFFP artifacts)
- phase1.invariants is non-empty (at least 3)
- phase2.candidates is non-empty (at least 2)
- phase3.counterexamples is non-empty
- phase3.composition_failures tests cover all depends_on constructs
- derived is populated (survivors or Phase 3b triggered)
- If outcome is "canonical" or "collapse": phase6.canonical exists
- If outcome is "open": phase3b exists with diagnosis
- Acknowledged limitations include "module federation deferred" or similar scoping note
  </verify>
  <done>
Complete CFFP instance for P5 at docs/cffp/p5-shared-types.json. Outcome is "canonical", "collapse", or "open" (all are valid per CFFP protocol). At least 2 candidates pressure-tested. Type identity question resolved. Import semantics defined. Acknowledged limitations documented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write shared type library spec section in docs/TENOR.md</name>
  <files>docs/TENOR.md</files>
  <action>
Translate the P5 CFFP canonical form into spec content in `docs/TENOR.md`.

**If outcome is "canonical" or "collapse"** (a canonical form was produced):

1. **Add shared type library section or subsection.** P5 extends the existing TypeDecl mechanism (Section 4.5) with cross-contract import semantics. This could be:
   - A new subsection under Section 4 (BaseType) — e.g., Section 4.6 "Shared Type Library"
   - OR a standalone section if the canonical form is substantial enough to warrant it
   Choose placement that respects the dependency order and keeps related content together.

2. **Write the section** following existing patterns:
   - Definition — formal definition of shared type import mechanism
   - Semantics — how imported types are resolved during elaboration
   - Type Identity — structural vs nominal (per canonical form decision)
   - Import Syntax — the DSL syntax for importing types from other files/contracts
   - Constraints — cycle detection, shadowing rules, depth limits if any
   - Elaboration Rules — which passes handle import resolution (likely Pass 1 for file loading, Pass 3 for type resolution)
   - Interchange Representation — how shared types appear (or don't appear) in the interchange JSON

3. **Update Section 4.5 (TypeDecl)** — note how local TypeDecl interacts with imported types.

4. **Update Section 12 (ElaboratorSpec)** — if import resolution affects pass behavior, update the pass descriptions.

5. **Update Section 16 (Pending Work)** — update P5 entry from "Deferred to v2" to "Resolved in v1.0" with acknowledgment of scoped-down scope if applicable.

6. **Update Appendix A (Acknowledged Limitations)** — add all acknowledged limitations from the CFFP canonical form. This is expected to have more entries than Persona or P7 given P5's complexity.

**If outcome is "open"** (no canonical form produced):

1. Write a brief spec section noting that shared type library semantics were investigated via CFFP, the outcome was "open" (no canonical form), and the specific reasons (from phase3b diagnosis).
2. Update Section 16 to note P5 status: "Investigated in v1.0 via CFFP; outcome open. See docs/cffp/p5-shared-types.json for analysis."
3. Document what WAS learned — even an "open" outcome produces useful constraints and eliminated approaches.
4. Identify what must change for a future CFFP run to succeed (from phase3b notes).

In either case, do NOT change existing construct definitions unless directly required by the canonical form. P5 changes should be confined to TypeDecl and import mechanisms.
  </action>
  <verify>
- If canonical/collapse outcome: docs/TENOR.md contains shared type library section with import syntax, type identity, elaboration rules, interchange representation
- If open outcome: docs/TENOR.md documents the open result and what was learned
- Section 4.5 (TypeDecl) updated to reference shared types
- Section 16 P5 entry updated from "Deferred to v2"
- Acknowledged limitations from CFFP canonical form appear in Appendix A
- Existing construct semantics preserved
  </verify>
  <done>
docs/TENOR.md contains shared type library specification content appropriate to the CFFP outcome. Section 16 P5 entry updated. Acknowledged limitations documented. If canonical: full spec section with import semantics, type identity, elaboration rules. If open: documented analysis with reasons and path forward.
  </done>
</task>

</tasks>

<verification>
1. `docs/cffp/p5-shared-types.json` exists, parses as valid JSON, and structurally matches `docs/cffp.cue#CFFPInstance`
2. P5 CFFP artifact has composition tests against ALL prior constructs including Persona and P7
3. Type identity question (structural vs nominal) is resolved in the canonical form
4. docs/TENOR.md contains appropriate spec content for the CFFP outcome
5. Section 16 P5 entry updated
6. Acknowledged limitations documented (expected to be non-trivial)
7. No breaking changes to existing construct semantics
</verification>

<success_criteria>
- P5 CFFP run completed with a valid CFFP outcome (canonical, collapse, or open)
- If canonical/collapse: shared type import semantics, type identity, and elaboration rules are formally defined in the spec
- If open: analysis is documented with clear reasons and path forward
- P5 module federation (inter-org sharing) is explicitly out of scope — acknowledged limitation
- Cross-contract type reuse for Record and TaggedUnion has defined (or documented-as-blocked) import semantics
</success_criteria>

<output>
After completion, create `.planning/phases/01-spec-completion/01-03-SUMMARY.md`
</output>
