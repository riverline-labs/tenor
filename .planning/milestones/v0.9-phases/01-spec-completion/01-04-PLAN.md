---
phase: 01-spec-completion
plan: 04
type: execute
wave: 4
depends_on:
  - 01-01
  - 01-02
  - 01-03
files_modified:
  - docs/interchange-schema.json
  - docs/TENOR.md
autonomous: true
requirements:
  - SPEC-04

must_haves:
  truths:
    - "Interchange JSON includes tenor_version field at the bundle level"
    - "A formal JSON Schema at docs/interchange-schema.json validates all interchange output"
    - "Every existing conformance test expected output is valid against the schema (modulo new v1.0 fields)"
    - "The schema covers all construct kinds including Persona and P7 outcome typing additions"
  artifacts:
    - path: "docs/interchange-schema.json"
      provides: "JSON Schema Draft 2020-12 validating the complete TenorInterchange format"
      contains: "$schema"
    - path: "docs/TENOR.md"
      provides: "Updated spec with tenor_version field definition and interchange versioning semantics"
      contains: "tenor_version"
  key_links:
    - from: "docs/interchange-schema.json"
      to: "docs/TENOR.md"
      via: "Schema structure derived from spec definitions"
      pattern: "\\$ref|\\$defs"
    - from: "docs/interchange-schema.json"
      to: "conformance/"
      via: "Schema validates all conformance test expected outputs"
      pattern: "constructs"
---

<objective>
Define interchange format versioning semantics and create a formal JSON Schema for the TenorInterchange format.

Purpose: The interchange format needs a version field for tooling compatibility detection and a formal schema for validation. The schema captures the v1.0 interchange format including all constructs formalized in plans 01-01 through 01-03. Per user decision, the schema is authored from the spec (not reverse-engineered from elaborator output) and uses JSON Schema Draft 2020-12.

Output: `docs/interchange-schema.json` (formal JSON Schema), updated `docs/TENOR.md` with versioning section.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-spec-completion/01-CONTEXT.md
@.planning/phases/01-spec-completion/01-RESEARCH.md
@.planning/phases/01-spec-completion/01-01-SUMMARY.md
@.planning/phases/01-spec-completion/01-02-SUMMARY.md
@.planning/phases/01-spec-completion/01-03-SUMMARY.md
@docs/TENOR.md
@conformance/positive/operation_basic.expected.json
@conformance/positive/flow_basic.expected.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define interchange versioning in docs/TENOR.md</name>
  <files>docs/TENOR.md</files>
  <action>
Add interchange format versioning semantics to `docs/TENOR.md`.

1. **Update the interchange format section** (currently part of Section 12 ElaboratorSpec, specifically Pass 6 description). Add a subsection or update existing content to define:

   - `tenor_version` field: Added at the bundle top level. String type. Semver format (e.g., "1.0.0").
   - Semantics: Major version = breaking structural changes to the interchange format. Minor version = additive fields/constructs. Patch version = fixes to serialization behavior.
   - The v0.3 to v1.0 transition is a major version bump — v1.0 interchange is not backward compatible with v0.3.
   - The existing per-construct `"tenor": "0.3"` field: Decide whether to keep, update to match tenor_version, or remove. Per research open question #5, the decision says "v0.3 → v1.0 is a major version bump" (clean break). Recommendation: update per-construct `"tenor"` field to "1.0" and add bundle-level `"tenor_version": "1.0.0"`. The per-construct field provides a quick version check; the bundle-level field is the canonical semver.

2. **Update the interchange format description** in the spec to reference the JSON Schema: "The canonical structure of TenorInterchange output is defined by the JSON Schema at `docs/interchange-schema.json`."

3. **Document the versioning contract:**
   - Conforming implementations MUST include `tenor_version` in bundle output
   - Conforming consumers MUST check `tenor_version` for compatibility
   - A consumer receiving a bundle with a higher major version than it supports MUST reject it
   - Minor version differences are forward-compatible (older consumers can read newer minor versions)
  </action>
  <verify>
- docs/TENOR.md contains `tenor_version` field definition with semver format
- Versioning semantics (major/minor/patch) documented
- Interchange format description references the JSON Schema
- Versioning contract for producers and consumers defined
  </verify>
  <done>
docs/TENOR.md defines interchange versioning: `tenor_version` field at bundle level (semver string), version compatibility rules for producers and consumers, and reference to the formal JSON Schema.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create formal JSON Schema for interchange format</name>
  <files>docs/interchange-schema.json</files>
  <action>
Author `docs/interchange-schema.json` — a JSON Schema Draft 2020-12 document that validates the complete TenorInterchange format.

**Schema structure:**
Use a single schema file with `$defs` for each construct kind. The top-level schema validates the Bundle; construct-level schemas are referenceable sub-schemas. This is the standard JSON Schema pattern per research recommendation.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://tenor-lang.org/schemas/interchange/v1.0.0",
  "title": "TenorInterchange v1.0",
  "description": "JSON Schema for the Tenor interchange format",
  "type": "object",
  ...
  "$defs": {
    "Fact": { ... },
    "Entity": { ... },
    "Rule": { ... },
    "Operation": { ... },
    "Flow": { ... },
    "Persona": { ... },
    ...
  }
}
```

**Top-level Bundle schema:**
Based on observed conformance test outputs and spec Section 12:
- `id` (string, required) — bundle identifier
- `kind` (const: "Bundle", required)
- `tenor` (string) — version field (updated to "1.0")
- `tenor_version` (string, pattern: semver, required) — canonical version
- `constructs` (array of construct documents, required)

**Construct document schemas (in $defs):**
For each construct kind, define the schema from the spec definition. Reference the spec sections:

- **Fact** (Section 5): id, kind="Fact", tenor, provenance, type (BaseType schema), default (optional)
- **Entity** (Section 6): id, kind="Entity", tenor, provenance, states (array), initial_state, transitions
- **Rule** (Section 7): id, kind="Rule", tenor, provenance, given, when, produce, stratum
- **Operation** (Section 8): id, kind="Operation", tenor, provenance, allowed_personas, precondition, effects, error_contract, PLUS outcome declarations from P7
- **Flow** (Section 10): id, kind="Flow", tenor, provenance, steps, initial_step
- **Persona** (new from plan 01-01): id, kind="Persona", tenor, provenance, plus fields from CFFP canonical form

**Supporting type schemas (in $defs):**
- `BaseType` — the twelve base types plus Duration, with recursive List/Record/TaggedUnion
- `PredicateExpression` — Compare, VerdictPresent, And, Or, Not, Forall
- `Provenance` — { file: string, line: integer }
- `DecimalValue` — { kind: "decimal_value", precision: integer, scale: integer, value: string }
- `Step` schemas — OperationStep, BranchStep, ParallelStep, HandoffStep, TerminalStep

**Key serialization rules to encode in schema:**
- All JSON keys sorted lexicographically within each object (note: JSON Schema cannot enforce key ordering, but document this constraint)
- Decimal/Money defaults use structured `decimal_value` objects
- `comparison_type` field conditional on Compare node context

**Validation approach:**
Read several conformance test expected outputs to verify the schema structure matches actual elaborator output:
- `conformance/positive/fact_basic.expected.json`
- `conformance/positive/entity_basic.expected.json`
- `conformance/positive/rule_basic.expected.json`
- `conformance/positive/operation_basic.expected.json`
- `conformance/positive/flow_basic.expected.json`
- At least 2 numeric test expected outputs for decimal value structure

Use these as the validation corpus — every existing expected output should be valid against the schema (with adjustments for v1.0 version field changes).

**What NOT to include:**
- Do not include P5 shared type constructs in the schema if the P5 CFFP outcome was "open" — only include what was canonicalized
- Do not include v2 constructs or speculative features
- Do not generate the schema from Rust types — author it from the spec
  </action>
  <verify>
- docs/interchange-schema.json parses as valid JSON
- Contains `$schema` field referencing JSON Schema Draft 2020-12
- Contains `$defs` for each construct kind: Fact, Entity, Rule, Operation, Flow, Persona
- Top-level Bundle schema requires: id, kind, tenor_version, constructs
- BaseType schema covers all twelve base types plus Duration
- PredicateExpression schema covers Compare, VerdictPresent, And, Or, Not, Forall
- Provenance schema defined
- DecimalValue schema matches the structured numeric format
- Schema structure is consistent with conformance test expected outputs
  </verify>
  <done>
docs/interchange-schema.json is a complete JSON Schema Draft 2020-12 document covering the full TenorInterchange v1.0 format. Bundle, all construct kinds, BaseType, PredicateExpression, Provenance, and DecimalValue are defined. The schema is authored from the spec and validated against conformance test expected outputs.
  </done>
</task>

</tasks>

<verification>
1. `docs/interchange-schema.json` exists and is valid JSON Schema Draft 2020-12
2. Schema covers all v1.0 construct kinds including Persona and P7 additions
3. `tenor_version` field is required in the Bundle schema
4. docs/TENOR.md contains versioning semantics and references the schema
5. Schema structure is consistent with existing conformance test expected outputs (modulo version field updates)
6. No construct kinds are missing from the schema
</verification>

<success_criteria>
- JSON Schema validates the complete v1.0 interchange format
- Versioning semantics (semver, major/minor/patch, compatibility rules) formally defined in spec
- Schema is authored from the spec, not reverse-engineered from implementation
- Every construct kind has a schema definition with all required fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-spec-completion/01-04-SUMMARY.md`
</output>
