---
phase: 03.4-contract-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
autonomous: true
requirements:
  - SPEC-08
  - CLI-10

must_haves:
  truths:
    - "`tenor elaborate --manifest <file.tenor>` produces a TenorManifest JSON envelope with bundle, etag, and tenor fields"
    - "Etag is the lowercase hex SHA-256 of the compact canonical JSON bytes of the bundle"
    - "`tenor validate` auto-detects manifest documents (via etag field presence) and validates against manifest schema with $ref resolution"
    - "Manifest output has lexicographically sorted top-level keys (bundle, etag, tenor)"
  artifacts:
    - path: "crates/cli/src/main.rs"
      provides: "--manifest flag on Elaborate subcommand, compute_etag, build_manifest, manifest-aware validate"
      contains: "fn compute_etag"
    - path: "Cargo.toml"
      provides: "sha2 workspace dependency"
      contains: "sha2"
    - path: "crates/cli/Cargo.toml"
      provides: "sha2 dependency reference"
      contains: "sha2"
  key_links:
    - from: "crates/cli/src/main.rs"
      to: "sha2::Sha256"
      via: "compute_etag function"
      pattern: "Sha256::digest"
    - from: "crates/cli/src/main.rs"
      to: "docs/manifest-schema.json"
      via: "include_str! embed"
      pattern: "include_str.*manifest-schema"
    - from: "crates/cli/src/main.rs"
      to: "docs/interchange-schema.json"
      via: "with_resource for $ref resolution"
      pattern: "with_resource"
---

<objective>
Add `--manifest` flag to `tenor elaborate`, SHA-256 etag computation, manifest envelope construction, and manifest-aware `tenor validate`.

Purpose: Implements the tooling side of Section 18 Contract Discovery -- agents and executors can request a TenorManifest with an inlined interchange bundle and a content-based etag for cold-start and change detection.

Output: Working `tenor elaborate --manifest` producing valid TenorManifest JSON, and `tenor validate` able to validate both interchange bundles and manifest documents.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.4-contract-discovery/3.4-RESEARCH.md

@crates/cli/src/main.rs
@Cargo.toml
@crates/cli/Cargo.toml
@docs/manifest-schema.json
@docs/interchange-schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sha2 dependency and --manifest flag with etag computation and manifest envelope</name>
  <files>
    Cargo.toml
    crates/cli/Cargo.toml
    crates/cli/src/main.rs
  </files>
  <action>
1. Add `sha2 = "0.10"` to `[workspace.dependencies]` in root `Cargo.toml`.
2. Add `sha2 = { workspace = true }` to `[dependencies]` in `crates/cli/Cargo.toml`.
3. In `crates/cli/src/main.rs`:
   a. Add `use sha2::{Sha256, Digest};` import.
   b. Add `#[arg(long)] manifest: bool` field to the `Commands::Elaborate` variant (alongside existing `file` field). Doc comment: "Produce a TenorManifest instead of a bare interchange bundle".
   c. Update the match arm for `Commands::Elaborate` to destructure the new `manifest` field and pass it to `cmd_elaborate`.
   d. Update `cmd_elaborate` signature to accept `manifest: bool` parameter.
   e. Add `compute_etag(bundle: &serde_json::Value) -> String` function:
      - Serialize bundle with `serde_json::to_string(bundle)` (compact, NOT pretty).
      - Hash with `Sha256::digest(canonical.as_bytes())`.
      - Return `format!("{:x}", hash)` for lowercase hex (64 chars).
   f. Add `build_manifest(bundle: serde_json::Value) -> serde_json::Value` function:
      - Create `serde_json::Map::new()`.
      - Insert "bundle" (the bundle value), "etag" (from compute_etag), "tenor" (string "1.1").
      - Return `Value::Object(map)`. Keys sort automatically because Map is BTreeMap-backed.
   g. In `cmd_elaborate`, after successful elaboration: if `manifest` is true, call `build_manifest(bundle)` and pretty-print that; otherwise, pretty-print the bare bundle as before.
  </action>
  <verify>
    Run `cargo build --workspace` -- must compile without errors.
    Run `cargo run -p tenor-cli -- elaborate --manifest conformance/positive/entity_basic.tenor` -- must produce JSON with "bundle", "etag", "tenor" keys at top level, etag must be exactly 64 hex chars matching `[0-9a-f]{64}`.
    Run `cargo run -p tenor-cli -- elaborate conformance/positive/entity_basic.tenor` -- must produce bare interchange JSON (unchanged behavior without flag).
  </verify>
  <done>
    `tenor elaborate --manifest` produces a valid TenorManifest envelope with correct etag (SHA-256 of compact bundle JSON), and bare `tenor elaborate` behavior is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend cmd_validate for manifest auto-detection and $ref resolution</name>
  <files>
    crates/cli/src/main.rs
  </files>
  <action>
1. In `crates/cli/src/main.rs`:
   a. Add a second `include_str!` for the manifest schema: `static MANIFEST_SCHEMA_STR: &str = include_str!("../../../docs/manifest-schema.json");` alongside the existing interchange schema embed. Move the existing interchange schema embed from inside `cmd_validate` to a module-level static alongside the manifest one (both need to be accessible).
   b. In `cmd_validate`, after parsing the JSON document, detect whether it's a manifest by checking `doc.get("etag").is_some()`. This is unambiguous because interchange bundles never have an "etag" field.
   c. If manifest detected:
      - Parse both `MANIFEST_SCHEMA_STR` and the interchange schema into `serde_json::Value`.
      - Build the validator using `jsonschema::options().with_resource("interchange-schema.json", Resource::from_contents(interchange_schema).expect("valid schema")).build(&manifest_schema)` to register the interchange schema for `$ref` resolution. Note: the `with_resource` method requires a `url` and a `Resource`. Check the actual jsonschema 0.42 API -- it may use `jsonschema::Resource::from_contents()` or similar. If the API is different, use whatever mechanism jsonschema 0.42 provides for external schema registration. The key requirement is that `"$ref": "interchange-schema.json"` in the manifest schema resolves correctly.
      - Validate `doc` against the manifest schema.
   d. If not manifest (existing behavior): validate against interchange schema as before.
   e. Update the text output for manifest validation: print "valid manifest" (text) or `{"valid": true, "type": "manifest"}` (json) so users know which schema was used.
   f. For non-manifest, keep existing output unchanged ("valid" / `{"valid": true}`).
  </action>
  <verify>
    Run `cargo build --workspace` -- must compile.
    Generate a manifest: `cargo run -p tenor-cli -- elaborate --manifest conformance/positive/entity_basic.tenor > /tmp/test-manifest.json`.
    Validate the manifest: `cargo run -p tenor-cli -- validate /tmp/test-manifest.json` -- must print "valid manifest" and exit 0.
    Validate a bare bundle: `cargo run -p tenor-cli -- validate conformance/positive/entity_basic.expected.json` -- must still print "valid" and exit 0 (existing behavior preserved).
    Run `cargo test --workspace` -- all existing tests must pass.
  </verify>
  <done>
    `tenor validate` auto-detects manifests (via etag field) and validates them against the manifest schema with proper `$ref` resolution to the interchange schema. Existing interchange bundle validation is unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `cargo test --workspace` -- all existing tests pass (no regressions)
3. `tenor elaborate --manifest <file>` produces valid manifest JSON with correct etag
4. `tenor elaborate <file>` produces bare interchange JSON (unchanged)
5. `tenor validate <manifest.json>` validates manifest documents correctly
6. `tenor validate <bundle.json>` validates interchange bundles as before
</verification>

<success_criteria>
- `--manifest` flag works on `elaborate` subcommand
- Etag is computed as lowercase hex SHA-256 of compact canonical JSON bytes
- Manifest envelope has sorted keys (bundle, etag, tenor) with tenor="1.1"
- `validate` auto-detects manifests and validates against manifest schema
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/03.4-contract-discovery/03.4-01-SUMMARY.md`
</output>
