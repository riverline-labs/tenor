# Phase 3.4: Contract Discovery - Research

**Researched:** 2026-02-22
**Domain:** CLI tooling, JSON Schema, cryptographic hashing (SHA-256), Rust
**Confidence:** HIGH

## Summary

Phase 3.4 implements the tooling side of the Section 18 Contract Discovery spec: a `--manifest` flag on the `elaborate` subcommand that wraps the interchange bundle in a TenorManifest envelope with an SHA-256 etag, plus manifest schema validation in the `validate` subcommand. The manifest JSON Schema (`docs/manifest-schema.json`) already exists and is complete at interchange v1.1.0.

The remaining work is narrowly scoped: (1) add a `--manifest` flag to the CLI `Elaborate` subcommand, (2) compute `lowercase_hex(SHA-256(canonical_json_bytes(bundle)))` using the `sha2` crate, (3) wrap the bundle in a manifest envelope with sorted keys, (4) extend `cmd_validate` to auto-detect or accept manifest documents and validate against the manifest schema, and (5) add conformance tests. All building blocks exist -- the elaborator already produces deterministic JSON with sorted keys, the manifest schema already references the interchange schema, and `jsonschema 0.42` already has `resolve-file` enabled for `$ref` resolution.

**Primary recommendation:** Add `sha2` to workspace dependencies, add a `--manifest` flag to the `Elaborate` clap variant, compute the etag from `serde_json::to_string(&bundle)` bytes (NOT `to_string_pretty`), and embed the manifest schema via `include_str!` alongside the existing interchange schema embed.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| SPEC-08 | Contract manifest JSON Schema (`docs/manifest-schema.json`) per Section 18 -- validates TenorManifest documents, references interchange schema for `bundle` field | Schema already exists at `docs/manifest-schema.json` with `$ref: "interchange-schema.json"` for bundle and `$defs/ExecutorCapabilities` for capabilities. No schema authoring needed -- this requirement is satisfied. Validation tooling support is the remaining work. |
| CLI-10 | `tenor elaborate --manifest <file.tenor>` produces TenorManifest JSON with inlined interchange bundle and SHA-256 etag per Section 18 | Requires: (1) `--manifest` flag on Elaborate subcommand via clap, (2) `sha2` crate for SHA-256, (3) manifest envelope construction with sorted keys, (4) `tenor validate` manifest support. All patterns exist in codebase. |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| sha2 | 0.10 | SHA-256 digest computation for etag | RustCrypto standard; pure Rust; no_std compatible; the canonical Rust SHA-2 implementation |
| serde_json | 1 (already in workspace) | JSON serialization for manifest envelope | Already used throughout; `Map` backed by BTreeMap gives sorted keys without `preserve_order` feature |
| jsonschema | 0.42 (already in workspace) | Schema validation for manifest documents | Already used by `cmd_validate`; has `resolve-file` feature enabled for `$ref` resolution |
| clap | 4.5 (already in workspace) | `--manifest` flag on elaborate subcommand | Already used for CLI; derive API for flag addition |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| base16ct | 0.2 | Hex encoding of SHA-256 digest | Alternative to manual `format!("{:x}", hash)` -- not strictly needed since `Sha256::digest` output supports `{:x}` formatting via `digest` crate's fmt impl |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| sha2 | ring | ring is faster but heavier, C bindings, overkill for single-hash-per-invocation |
| sha2 | sha256 (convenience crate) | Wrapper crate; sha2 is the canonical RustCrypto implementation, more widely used |
| base16ct | format!("{:x}") | Built-in formatting via `digest` crate is sufficient; no extra dependency needed |

**Installation:**
```toml
# In workspace Cargo.toml [workspace.dependencies]
sha2 = "0.10"
# In crates/cli/Cargo.toml [dependencies]
sha2 = { workspace = true }
```

## Architecture Patterns

### Recommended Change Structure
```
crates/cli/src/main.rs     -- Add --manifest flag to Elaborate variant, manifest construction logic
docs/manifest-schema.json  -- Already exists (no changes needed)
conformance/manifest/      -- New directory for manifest conformance tests
  manifest_basic.tenor
  manifest_basic.expected-manifest.json
```

### Pattern 1: Flag Extension on Existing Subcommand
**What:** Add a `--manifest` boolean flag to the existing `Elaborate` subcommand rather than creating a new subcommand.
**When to use:** When the new behavior is a transformation of existing output (manifest wraps the bundle).
**Example:**
```rust
// In Commands::Elaborate
Elaborate {
    /// Path to the .tenor source file
    file: PathBuf,
    /// Produce a TenorManifest instead of a bare interchange bundle
    #[arg(long)]
    manifest: bool,
},
```

### Pattern 2: Etag Computation from Canonical Bytes
**What:** Hash the compact (non-pretty) JSON bytes of the bundle for the etag. The spec says "canonical_json_bytes(bundle)" which means the deterministic Pass 6 output serialized without extra whitespace.
**When to use:** Always when computing etag.
**Critical detail:** Use `serde_json::to_string(&bundle)` (compact), NOT `serde_json::to_string_pretty(&bundle)`. The compact form is the canonical byte representation. The pretty-printed output displayed to the user is a presentation concern.
**Example:**
```rust
use sha2::{Sha256, Digest};

fn compute_etag(bundle: &serde_json::Value) -> String {
    // Canonical JSON bytes: compact serialization with sorted keys
    // serde_json::Map is BTreeMap-backed (preserve_order not enabled),
    // so keys are already sorted lexicographically.
    let canonical_bytes = serde_json::to_string(bundle)
        .expect("bundle serialization cannot fail");
    let hash = Sha256::digest(canonical_bytes.as_bytes());
    format!("{:x}", hash) // lowercase hex, 64 chars
}
```

### Pattern 3: Manifest Envelope Construction with Sorted Keys
**What:** Build the TenorManifest JSON object with keys in lexicographic order using `serde_json::Map`.
**When to use:** For manifest output construction.
**Example:**
```rust
fn build_manifest(bundle: serde_json::Value) -> serde_json::Value {
    let etag = compute_etag(&bundle);
    let mut manifest = serde_json::Map::new();
    // Keys inserted in any order -- Map is BTreeMap, so they sort automatically
    manifest.insert("bundle".to_owned(), bundle);
    manifest.insert("etag".to_owned(), serde_json::Value::String(etag));
    manifest.insert("tenor".to_owned(), serde_json::Value::String("1.1".to_owned()));
    serde_json::Value::Object(manifest)
}
```

### Pattern 4: Schema Auto-Detection in Validate
**What:** The `validate` subcommand currently only validates interchange bundles. Extend it to also validate manifests, either by auto-detecting (check for `etag` key) or by adding a `--manifest` flag.
**When to use:** When `tenor validate` receives a manifest JSON document.
**Recommended approach:** Auto-detect. If the JSON document has an `etag` field, validate against the manifest schema. Otherwise, validate against the interchange schema. This is unambiguous because interchange bundles never have an `etag` field.
**Example:**
```rust
fn is_manifest(doc: &serde_json::Value) -> bool {
    doc.get("etag").is_some()
}
```

### Pattern 5: Embed Manifest Schema via include_str!
**What:** Embed `docs/manifest-schema.json` at compile time, just like the interchange schema.
**Example:**
```rust
static MANIFEST_SCHEMA_STR: &str = include_str!("../../../docs/manifest-schema.json");
static INTERCHANGE_SCHEMA_STR: &str = include_str!("../../../docs/interchange-schema.json");
```

### Anti-Patterns to Avoid
- **Pretty-printing for etag input:** Never use `to_string_pretty` for the canonical bytes. The etag must be computed from compact JSON. Pretty-printed output is for human display only.
- **Capabilities field in etag:** The spec explicitly excludes `capabilities` from etag computation. Since `tenor elaborate --manifest` does not produce a `capabilities` field (that's an executor concern), this is naturally handled. But do not add capabilities to the manifest output.
- **New subcommand for manifest:** The constraint says `--manifest` extends `elaborate`, not a new subcommand.
- **Generating the manifest in tenor-core:** The manifest is a CLI presentation concern. Pass 6 produces the bundle; the CLI wraps it in a manifest envelope. Keep the core library focused on elaboration.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| SHA-256 | Custom hash implementation | `sha2` crate | Cryptographic correctness; audited RustCrypto implementation |
| Hex encoding | Manual byte-to-hex loop | `format!("{:x}", digest)` | `digest` crate's Display/LowerHex impl handles this correctly |
| JSON key sorting | Custom key-sorting pass | `serde_json::Map` (BTreeMap-backed) | Already sorted; no `preserve_order` feature means lexicographic order guaranteed |
| Schema cross-reference | Inlining interchange schema into manifest schema | `jsonschema` `resolve-file` feature | Already enabled; handles `$ref: "interchange-schema.json"` natively |

**Key insight:** The elaborator already produces deterministic, sorted-key JSON. The etag computation is literally "hash the serialized bytes" with no additional canonicalization needed. The main risk is accidentally using pretty-printed output instead of compact output for the hash input.

## Common Pitfalls

### Pitfall 1: Pretty vs Compact JSON for Etag
**What goes wrong:** Using `serde_json::to_string_pretty` for the etag input produces different bytes than `serde_json::to_string`. If different tools use different formatting, etags won't match across implementations.
**Why it happens:** The CLI currently uses `to_string_pretty` for display output. It's easy to accidentally use the same function for etag computation.
**How to avoid:** Compute etag from `serde_json::to_string(&bundle)` (compact). Display the manifest with `serde_json::to_string_pretty(&manifest)` (pretty). These are two separate operations.
**Warning signs:** Etag is longer than 64 hex characters, or doesn't match expected values in conformance tests.

### Pitfall 2: $ref Resolution in Manifest Schema Validation
**What goes wrong:** The manifest schema has `"$ref": "interchange-schema.json"` for the `bundle` field. If `jsonschema` can't resolve this relative reference, validation fails with a schema compilation error rather than a validation error.
**Why it happens:** `include_str!` loads the schema as a string without filesystem context. The validator doesn't know the schema's base URI or file location, so it can't resolve relative `$ref` paths.
**How to avoid:** Use `jsonschema::options().with_resource("interchange-schema.json", interchange_schema).build(&manifest_schema)` to pre-register the interchange schema as a resolvable resource. Alternatively, set the base URI to match the schema's `$id` field.
**Warning signs:** Validation error mentioning "failed to resolve" or "unknown reference".

### Pitfall 3: Manifest Schema Version String
**What goes wrong:** Confusing the manifest's `tenor` field (manifest schema version "1.1") with the bundle's `tenor` field (interchange format version "1.0") or the bundle's `tenor_version` field (semver "1.1.0").
**Why it happens:** Three independent version axes sharing similar field names.
**How to avoid:** The manifest's `tenor` is "1.1" (per the schema which includes the capabilities field definition). The bundle's `tenor` remains "1.0". These are different values with different meanings.
**Warning signs:** Conformance test failing because `tenor` has wrong value at manifest vs bundle level.

### Pitfall 4: Conformance Test Structure
**What goes wrong:** Trying to fit manifest tests into the existing positive/negative test convention which expects `.expected.json` files containing interchange bundles.
**Why it happens:** Manifest tests need a different expected format (manifest JSON, not bundle JSON).
**How to avoid:** Create a separate `conformance/manifest/` directory. Tests in this directory elaborate a `.tenor` file with `--manifest`, compare against `.expected-manifest.json`. The conformance runner needs a new test category.
**Warning signs:** Manifest tests mixed into positive tests, causing the existing runner to fail.

### Pitfall 5: Etag Determinism Across Platforms
**What goes wrong:** If the JSON serialization produces different byte sequences on different platforms (e.g., different floating-point formatting), the etag will differ.
**Why it happens:** Floating-point serialization can vary by platform.
**How to avoid:** This is already handled by Tenor's design: all numeric values in interchange JSON are either integers or structured decimal objects (strings). There are no bare floating-point values in the interchange format. `serde_json::to_string` is deterministic for these types.
**Warning signs:** CI test failures on specific platforms that don't reproduce locally.

## Code Examples

### Complete Manifest Generation Flow
```rust
use sha2::{Sha256, Digest};
use serde_json::{Map, Value};

fn compute_etag(bundle: &Value) -> String {
    let canonical = serde_json::to_string(bundle)
        .expect("bundle serialization cannot fail");
    let hash = Sha256::digest(canonical.as_bytes());
    format!("{:x}", hash)
}

fn build_manifest(bundle: Value) -> Value {
    let etag = compute_etag(&bundle);
    let mut m = Map::new();
    m.insert("bundle".to_owned(), bundle);
    m.insert("etag".to_owned(), Value::String(etag));
    m.insert("tenor".to_owned(), Value::String("1.1".to_owned()));
    Value::Object(m)
}
```

### Extended cmd_elaborate with --manifest
```rust
fn cmd_elaborate(file: &Path, manifest: bool, output: OutputFormat, quiet: bool) {
    match tenor_core::elaborate::elaborate(file) {
        Ok(bundle) => {
            let result = if manifest {
                build_manifest(bundle)
            } else {
                bundle
            };
            let pretty = serde_json::to_string_pretty(&result)
                .unwrap_or_else(|e| format!("serialization error: {}", e));
            println!("{}", pretty);
        }
        Err(e) => {
            // ... existing error handling unchanged ...
        }
    }
}
```

### Validate Command with Manifest Auto-Detection
```rust
fn cmd_validate(bundle_path: &Path, output: OutputFormat, quiet: bool) {
    static INTERCHANGE_SCHEMA_STR: &str = include_str!("../../../docs/interchange-schema.json");
    static MANIFEST_SCHEMA_STR: &str = include_str!("../../../docs/manifest-schema.json");

    let doc_str = std::fs::read_to_string(bundle_path).unwrap_or_else(/* ... */);
    let doc: Value = serde_json::from_str(&doc_str).unwrap_or_else(/* ... */);

    let is_manifest = doc.get("etag").is_some();

    let validator = if is_manifest {
        let manifest_schema: Value = serde_json::from_str(MANIFEST_SCHEMA_STR).unwrap();
        let interchange_schema: Value = serde_json::from_str(INTERCHANGE_SCHEMA_STR).unwrap();
        // Register interchange schema for $ref resolution
        jsonschema::options()
            .with_resource("interchange-schema.json", interchange_schema)
            .build(&manifest_schema)
            .unwrap()
    } else {
        let schema: Value = serde_json::from_str(INTERCHANGE_SCHEMA_STR).unwrap();
        jsonschema::validator_for(&schema).unwrap()
    };

    // ... validation logic same as current ...
}
```

### Conformance Test for Manifest
```rust
// In runner.rs, new function:
fn run_manifest_tests(suite_dir: &Path, tap: &mut Tap) {
    let dir = suite_dir.join("manifest");
    if !dir.exists() {
        return;
    }
    let mut entries = glob_tenor_files(&dir);
    entries.sort();
    for tenor_path in &entries {
        let stem = stem(&tenor_path);
        let expected_path = dir.join(format!("{}.expected-manifest.json", stem));
        if !expected_path.exists() {
            tap.not_ok(
                format!("manifest/{}", stem),
                format!("missing expected file: {}", expected_path.display()),
            );
            continue;
        }
        run_manifest_test(&tenor_path, &expected_path, &stem, tap);
    }
}

fn run_manifest_test(
    tenor_path: &Path,
    expected_path: &Path,
    name: &str,
    tap: &mut Tap,
) {
    let expected_json = match read_json(expected_path) {
        Ok(v) => v,
        Err(e) => {
            tap.not_ok(&format!("manifest/{}", name), format!("failed to read: {}", e));
            return;
        }
    };
    match elaborate::elaborate(tenor_path) {
        Ok(bundle) => {
            let manifest = build_manifest(bundle);  // reuse the same function
            if json_equal(&manifest, &expected_json) {
                tap.ok(&format!("manifest/{}", name));
            } else {
                let diff = json_diff(&expected_json, &manifest);
                tap.not_ok(&format!("manifest/{}", name), format!("output mismatch:\n{}", diff));
            }
        }
        Err(e) => {
            tap.not_ok(
                &format!("manifest/{}", name),
                format!("unexpected elaboration error: {}", e.message),
            );
        }
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No manifest | TenorManifest with etag | Tenor v1.0 Section 18 | Enables agent cold-start and change detection |
| Separate bundle endpoint | Inlined bundle in manifest | Tenor v1.0 design decision | Single-fetch cold-start; no separate bundle URL needed |

**Already complete:**
- `docs/manifest-schema.json` -- authored as part of Phase 3.3 spec completion
- Section 18 in TENOR.md -- full specification of E10-E14 executor obligations
- Interchange schema -- stable at v1.1.0

## Open Questions

1. **Canonical JSON for etag: `to_string` vs `to_vec`?**
   - What we know: Both produce identical bytes for our use case (ASCII JSON with no BOM). `to_string` returns `String`, `to_vec` returns `Vec<u8>`. Either works for SHA-256 input.
   - What's unclear: Whether there's a performance difference worth caring about (single invocation, not in a hot loop).
   - Recommendation: Use `to_string` + `.as_bytes()` for clarity. Performance is irrelevant at this call frequency.

2. **`jsonschema::options().with_resource()` API for $ref resolution?**
   - What we know: The `jsonschema` 0.42 crate has `with_resource` on `ValidationOptions`. The manifest schema references `interchange-schema.json` via relative `$ref`. The `resolve-file` feature is enabled.
   - What's unclear: Whether `resolve-file` alone is sufficient when schemas are loaded via `include_str!` (no filesystem context), or whether explicit `with_resource` registration is required.
   - Recommendation: Use `with_resource` to explicitly register the interchange schema. This is more robust than relying on filesystem-relative resolution from embedded strings.

3. **Manifest conformance test fixture naming convention?**
   - What we know: Existing conventions use `.expected.json` for positive tests. Manifest tests need a different expected format.
   - What's unclear: Whether to use `.expected-manifest.json` or `.manifest.expected.json` or another convention.
   - Recommendation: Use `.expected-manifest.json` to parallel the existing `.expected-error.json` convention (suffix describes the expected output type).

## Sources

### Primary (HIGH confidence)
- `/Users/bwb/src/rll/tenor/docs/TENOR.md` lines 1796-2061 -- Section 18 Contract Discovery & Agent Orientation (full spec)
- `/Users/bwb/src/rll/tenor/docs/manifest-schema.json` -- existing manifest JSON Schema (complete)
- `/Users/bwb/src/rll/tenor/docs/interchange-schema.json` -- existing interchange JSON Schema (stable)
- `/Users/bwb/src/rll/tenor/crates/cli/src/main.rs` -- current CLI structure (Elaborate subcommand, cmd_validate pattern)
- `/Users/bwb/src/rll/tenor/crates/core/src/pass6_serialize.rs` -- Pass 6 serialization (deterministic output, Map-based sorted keys)
- `/Users/bwb/src/rll/tenor/crates/core/src/elaborate.rs` -- elaboration orchestrator (returns `Value`)
- `/Users/bwb/src/rll/tenor/Cargo.toml` -- workspace dependencies (serde_json 1, jsonschema 0.42, no sha2 yet)
- `cargo tree` verification: `serde_json` has no `preserve_order` feature, `jsonschema` has `resolve-file` enabled

### Secondary (MEDIUM confidence)
- [jsonschema docs.rs](https://docs.rs/jsonschema) -- `with_resource` API for external `$ref` resolution
- [sha2 docs.rs](https://docs.rs/sha2) -- `Sha256::digest` API, `{:x}` formatting for lowercase hex output
- [RustCrypto hashes](https://github.com/RustCrypto/hashes) -- sha2 0.10 is current stable

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- All libraries are already in the workspace except sha2, which is the canonical Rust SHA-2 implementation
- Architecture: HIGH -- The pattern is straightforward: wrap existing elaborator output in a manifest envelope, hash it. All building blocks exist and are well-understood.
- Pitfalls: HIGH -- Identified from direct code reading. The $ref resolution pitfall is the highest-risk item but has a clear mitigation (with_resource API).

**Research date:** 2026-02-22
**Valid until:** 2026-03-22 (stable domain; no fast-moving dependencies)
