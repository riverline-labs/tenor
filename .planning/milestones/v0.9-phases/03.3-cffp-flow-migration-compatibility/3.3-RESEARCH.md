# Phase 3.3: CFFP -- Flow Migration Compatibility - Research

**Researched:** 2026-02-21
**Domain:** Flow-level migration compatibility, force-migrate safety conditions, directional asymmetry in stateful workflow versioning, coexistence layer patterns
**Confidence:** HIGH

## Summary

Phase 3.3 is a **spec prose and CFFP formalization** phase -- no code implementation. It extends the migration semantics from Phase 3.1 by answering a more granular question: when can an *in-flight flow* be force-migrated from contract v1 to contract v2, and when must it remain on v1 (coexistence) or be aborted? Phase 3.1 defined three migration policies (blue-green, force-migrate, abort) as executor obligations, but left force-migrate deliberately imprecise -- this phase makes it precise.

The deliverables are: (1) a CFFP-derived formal definition of flow-level force-migration compatibility with three conditions (forward path existence, backward data dependency satisfaction, entity state equivalence), (2) documentation of the directional asymmetry problem (v2 steps may require state that v1 never established), (3) a formal description of the coexistence layer pattern (v1.5) as an executor implementation strategy, (4) pressure testing through concrete flow scenarios (escrow, multi-week approval, subscription lifecycle), and (5) extension of TENOR.md Section 17 with a flow compatibility subsection.

The core insight driving this phase is that flows are long-lived stateful processes that outlive deployment cycles. A subscription lifecycle flow may span weeks or months. When a contract version change is deployed with force-migrate policy, the executor must determine *per-flow-instance* whether migration is safe. This requires analyzing the flow's current position, the reachable future paths from that position, and whether the data/state assumptions of v2's steps are satisfiable given what v1's execution has established so far.

**Primary recommendation:** Execute a single CFFP run formalizing "Flow Migration Compatibility" as a construct-level definition. The three compatibility conditions (forward path, data dependency, entity state) become invariants. Candidate formalisms should explore graph-theoretic approaches to defining "position equivalence" and "reachable path compatibility." The CFFP artifact and spec prose are the outputs -- no tooling implementation.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| MIGR-02 | Breaking change taxonomy -- CFFP-derived classification rules for what constitutes breaking vs non-breaking changes | Phase 3.1 completed the construct-level taxonomy (Section 17.2). Phase 3.3 extends this to flow-level granularity: the taxonomy entry for Flow.steps "change step" is currently BREAKING, but force-migration analysis can refine this to "BREAKING unless compatibility conditions hold at the specific flow position." This phase provides the flow-level refinement referenced by MIGR-02. |
| MIGR-04 | Spec section on Versioning & Migration defining executor obligations for contract version transitions, including mandatory in-flight flow migration policy declaration | Phase 3.1 completed Section 17 with M1-M8 obligations and three migration policies. Phase 3.3 extends Section 17 by defining the formal conditions under which force-migrate is safe (making M5 precise) and documenting the coexistence layer as an executor implementation strategy for cases where force-migrate is unsafe. |
</phase_requirements>

## Standard Stack

This phase produces spec prose and a CFFP JSON artifact, not code. There is no library stack.

### Core Deliverables
| Artifact | Format | Purpose | Why This Format |
|----------|--------|---------|-----------------|
| CFFP JSON | `docs/cffp/flow-migration-compatibility.json` | CFFP run record for flow compatibility conditions | Matches existing CFFP provenance pattern (`docs/cffp/migration-semantics.json`, `persona.json`, etc.) |
| TENOR.md extension | Markdown in `docs/TENOR.md` | New subsection under Section 17 defining flow-level compatibility | Extends the existing Versioning & Migration section with flow-specific analysis |
| Acknowledged Limitations | AL entries in Appendix A | Flow migration-specific limitations discovered during CFFP | Standard pattern for CFFP scope narrowings |

### Supporting Artifacts
| Artifact | Format | Purpose | When to Create |
|----------|--------|---------|----------------|
| Pending Work updates | Section 19 updates | Track flow migration deferred items | If CFFP identifies v2 deferrals |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Extending Section 17 | New top-level section | Flow compatibility is a sub-topic of migration, not a separate concern. Subsection of Section 17 is cleaner. |
| Single CFFP run | Separate CFFP for each condition | The three conditions (forward path, data dependency, entity state) are interdependent -- a single run captures their interactions. |
| Formal mathematical notation | Natural language spec prose | TENOR.md uses semi-formal notation (function signatures, pseudocode) consistently. Match existing style. |

## Architecture Patterns

### Pattern 1: CFFP Run for Flow Migration Compatibility

**What:** A CFFP run formalizing the compatibility conditions under which an in-flight flow can be safely force-migrated from v1 to v2.

**When to use:** This IS the core deliverable.

**Construct definition:**
```json
{
  "name": "Flow Migration Compatibility",
  "description": "Formal conditions under which an in-flight flow at position p in contract v1 can be safely force-migrated to contract v2. Defines forward path existence, backward data dependency satisfaction, entity state equivalence, and the directional asymmetry problem.",
  "depends_on": ["Flow", "Operation", "Entity", "Rule", "Fact", "Migration Semantics"]
}
```

**Invariant candidates (from success criteria):**

- **FMC1 -- Forward path existence:** For every step in every reachable future path from position p in v1, there must exist a corresponding step in v2 with equivalent semantics (same operation, compatible routing).
- **FMC2 -- Backward data dependency satisfaction:** All data dependencies of v2 steps reachable from the migration point must be satisfiable from existing provenance (the frozen snapshot taken at v1 flow initiation), frozen entity state snapshot, or safe defaults declared in v2.
- **FMC3 -- Entity state equivalence:** Entity states at the current flow position must have v2 equivalents. Every entity in a state that exists in v1 must have that state available in v2's entity definition.
- **FMC4 -- Directional asymmetry recognition:** Forward path compatibility alone is insufficient. V2 steps may require state, knowledge, or precondition satisfaction that v1 never established. The compatibility definition must account for this asymmetry.
- **FMC5 -- Position-sensitive analysis:** Flow compatibility is a function of the current execution position, not just the overall flow structure. A flow may be compatible at position A but incompatible at position B.

### Pattern 2: Flow Position and Reachable Path Analysis

**What:** The formal definition of "position" in a flow and "reachable future paths" from that position. This connects to S6 (Flow path enumeration) from Section 15.

**Key concepts:**

```
Position(flow, step_id) = the current step where the flow instance is waiting/executing

ReachablePaths(flow, position) = set of all execution paths from position to Terminal
  -- For OperationStep: one path per declared outcome (exhaustive by Section 11.5)
  -- For BranchStep: two paths (if_true, if_false)
  -- For SubFlowStep: success path + failure handler path
  -- For ParallelStep: Cartesian product of branch outcomes

StepEquivalence(v1_step, v2_step) =
  v1_step.op == v2_step.op AND
  v1_step.persona == v2_step.persona AND
  outcome_routing is structurally compatible
```

**Connection to S6:** Flow path enumeration (S6 from Section 15) provides the mechanism to compute ReachablePaths. Phase 3.3 defines what "compatible" means; Phase 4 implements S6 to compute the paths.

### Pattern 3: The Directional Asymmetry Problem

**What:** The key insight that makes flow migration harder than construct-level migration. When v2 adds a new step between two existing steps (or changes a step's operation to one with a stronger precondition), the new step may require data/state that the v1 flow never established because v1 never executed the step that would have produced it.

**Concrete example (escrow):**

```
v1 Flow: step_confirm -> step_check_threshold -> step_auto_release -> Terminal(success)

v2 Flow: step_confirm -> step_compliance_check -> step_check_threshold -> step_auto_release -> Terminal(success)
  (new step_compliance_check added between step_confirm and step_check_threshold)

In-flight v1 flow at position step_check_threshold:
  - Forward path exists (step_check_threshold -> step_auto_release -> Terminal)
  - Entity states are compatible (same states in v1 and v2)
  - BUT: the flow has already passed the point where step_compliance_check
    would have executed. If step_auto_release in v2 has a new precondition
    requiring verdict_present(compliance_cleared), this verdict was never
    produced because the v1 flow never went through step_compliance_check.
  - This is directional asymmetry: the path looks compatible going forward,
    but v2's downstream steps may depend on side-effects of steps that
    v1 skipped.
```

### Pattern 4: Coexistence Layer (v1.5)

**What:** When force-migration is unsafe for some in-flight flows, the executor maintains both contract versions simultaneously:
- New flows start on v2
- Incompatible in-flight flows continue on v1 runtime
- Compatible in-flight flows may be force-migrated to v2
- On exit (flow reaches Terminal), results are translated to v2's output format if needed

**Key properties:**
- This is an **executor implementation strategy**, not a spec-level construct
- The spec does not prescribe v1.5 -- it defines the conditions under which force-migrate is safe
- The coexistence pattern is the natural consequence of per-flow-instance compatibility analysis
- It generalizes blue-green (all flows on v1) and force-migrate (all flows on v2) by allowing mixed assignment

### Anti-Patterns to Avoid
- **Defining compatibility at the flow-type level only:** Compatibility must be position-sensitive. A flow type may be compatible at some positions and incompatible at others. The formal definition must take position as input.
- **Ignoring the frozen snapshot interaction:** The frozen verdict snapshot provides natural isolation for verdict-layer changes, but NOT for entity state or operation definition changes. The compatibility analysis must distinguish which layers are affected.
- **Prescribing a specific coexistence implementation:** The spec defines conditions; executors choose implementation. The coexistence pattern is documented as one strategy, not the only strategy.
- **Treating flow steps as independently migratable:** Steps in a flow are connected by data dependencies (provenance chain from earlier steps feeds into later steps). Migration compatibility is a property of the **remaining path**, not individual steps.
- **Conflating step identity with step position:** A step with the same `step_id` in v1 and v2 may have different semantics (different operation, different routing). Step equivalence must be checked semantically, not just by id.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Flow path enumeration formalism | Custom graph traversal notation | Reference S6 from Section 15 | S6 is already defined as a static analysis obligation; the compatibility definition should reference it, not reinvent it |
| CFFP process structure | New protocol structure | Follow exact structure from `docs/cffp.cue` and `docs/cffp/migration-semantics.json` | Four prior CFFP runs establish the process; consistency matters for provenance |
| Breaking change taxonomy extension | Separate taxonomy for flow compatibility | Extend Section 17.2.6 (Flow Changes) | The flow compatibility conditions refine existing taxonomy entries, not replace them |
| Coexistence pattern | Novel deployment architecture | Adapt Camunda/Flowable process instance migration patterns | Industry-standard BPM engines have solved this problem operationally |

**Key insight:** The novelty of this phase is not inventing flow migration (BPM engines do this routinely) but formalizing the *conditions* under which Tenor's specific construct model (frozen verdicts, exhaustive outcome handling, entity state machines, persona authority) permits safe force-migration. The formal definition must account for Tenor's unique properties.

## Common Pitfalls

### Pitfall 1: Ignoring Frozen Verdict Isolation During Compatibility Analysis
**What goes wrong:** The compatibility analysis treats all in-flight flow state as equally vulnerable to contract changes, when frozen verdict semantics actually isolate the verdict layer completely.
**Why it happens:** The frozen snapshot is a subtle property of Tenor's evaluation model (Section 11.4) that does not exist in most BPM engines.
**How to avoid:** For each compatibility condition, explicitly state which layers are affected: (a) frozen verdict snapshot -- ISOLATED, changes to Rules/Facts do NOT affect in-flight flow verdicts, (b) entity state -- NOT ISOLATED, entity state is live and affected by entity definition changes, (c) operation definitions -- NOT ISOLATED, operation preconditions and effects are evaluated against v2 definitions when the flow reaches an OperationStep.
**Warning signs:** If the compatibility definition does not distinguish between verdict-layer and entity/operation-layer changes, it is over-conservative (treating isolated changes as breaking) or under-conservative (treating non-isolated changes as safe).

### Pitfall 2: Under-Specifying "Data Dependency Satisfaction" (FMC2)
**What goes wrong:** The backward data dependency condition is stated abstractly ("dependencies must be satisfiable") without defining what "satisfiable" means in terms of Tenor's specific evaluation model.
**Why it happens:** "Data dependency" is a general concept that needs Tenor-specific grounding.
**How to avoid:** In Tenor, data dependencies for a step are: (a) the step's operation precondition references specific facts and verdicts from the snapshot, (b) the step's operation effects target specific entity states (the entity must be in the expected source state), (c) the step's persona must be authorized. For each v2 step in the remaining path, enumerate these dependencies and check: are the required facts present in the existing snapshot? Are the required verdicts present? Are entity states reachable? Is the persona authorized?
**Warning signs:** If the compatibility definition uses "data dependency" without decomposing it into Tenor's specific dependency types (fact references, verdict references, entity state preconditions, persona authorization), it is under-specified.

### Pitfall 3: Forgetting SubFlowStep and ParallelStep Interactions
**What goes wrong:** The compatibility definition only considers linear step sequences (OperationStep -> OperationStep) and misses the complexity of SubFlowStep (recursive flow invocation) and ParallelStep (branching execution).
**Why it happens:** Linear paths are the simplest case; sub-flows and parallel steps add significant complexity.
**How to avoid:** The formal definition must handle: (a) SubFlowStep: if a sub-flow is invoked and the sub-flow's definition changed in v2, the sub-flow itself must be compatibility-checked recursively, (b) ParallelStep: all branches must be independently compatible, AND the join policy must be equivalent, (c) Nested sub-flows: compatibility checking is transitive through the flow reference DAG.
**Warning signs:** If the CFFP pressure testing does not include a scenario with SubFlowStep or ParallelStep, the compatibility definition has not been tested against the full step type vocabulary.

### Pitfall 4: Making the Coexistence Layer a Spec Obligation Rather Than an Executor Strategy
**What goes wrong:** The spec defines the coexistence layer as a mandatory migration mechanism, constraining executor implementation choices.
**Why it happens:** The coexistence pattern is elegant and seems like "the right way" to handle mixed-version flows.
**How to avoid:** The spec should define the COMPATIBILITY CONDITIONS (when force-migrate is safe). How the executor handles flows that fail the compatibility check is an executor implementation choice -- they might use blue-green, abort, or a coexistence layer. The coexistence pattern should be DESCRIBED (as one valid approach) but not PRESCRIBED.
**Warning signs:** If the spec prose uses "MUST use coexistence layer" rather than "MAY implement coexistence" or "the coexistence layer is one strategy that satisfies M5."

### Pitfall 5: Defining Compatibility Without Concrete Pressure Testing
**What goes wrong:** The formal definition sounds correct in the abstract but breaks on concrete scenarios.
**Why it happens:** Abstract definitions often miss edge cases that concrete scenarios expose.
**How to avoid:** The success criteria explicitly require pressure testing with three concrete scenarios: (a) escrow (from Appendix C -- multi-step with compensation, handoff, branching), (b) multi-week approval (long-running with potential for many concurrent position states), (c) subscription lifecycle (recurring operations, entity state cycling). Each scenario should have at least one case where force-migration is safe and one where it is not.
**Warning signs:** If the CFFP counterexamples are all abstract ("consider a flow with steps A, B, C") rather than grounded in Tenor's concrete constructs (using real Operations, Entities, Personas from the examples).

## Code Examples

This phase produces no code. However, the following examples illustrate the compatibility conditions:

### Example 1: Safe Force-Migration (Escrow at step_check_threshold)

```
v1 Contract:
  flow standard_release {
    entry: step_confirm
    steps: {
      step_confirm -> step_check_threshold -> step_auto_release -> Terminal(success)
      step_check_threshold if_false -> step_handoff_compliance -> step_compliance_release -> Terminal(success)
    }
  }

v2 Contract (only change: compliance_threshold fact type widened):
  -- Same flow structure, same steps, same operations
  -- fact compliance_threshold { type: Money(precision: 12, scale: 2) }
  -- (was precision: 10, scale: 2 in v1)

In-flight flow at step_check_threshold:
  FMC1 (forward path): All future steps exist in v2 with same operations and routing -> PASS
  FMC2 (data dependency): Frozen snapshot has all facts needed by remaining steps.
    compliance_threshold value is in the snapshot (frozen at initiation).
    The widened type does not affect the snapshot value. -> PASS
  FMC3 (entity state): EscrowAccount.held and DeliveryRecord.confirmed both
    exist in v2 -> PASS
  FMC4 (directional asymmetry): No new steps with new data requirements -> PASS

Result: Force-migration is SAFE at this position.
```

### Example 2: Unsafe Force-Migration (Escrow with New Compliance Step)

```
v2 Contract (added mandatory compliance step):
  flow standard_release {
    entry: step_confirm
    steps: {
      step_confirm -> step_new_compliance_check -> step_check_threshold
        -> step_auto_release -> Terminal(success)
    }
  }
  operation new_compliance_check {
    precondition: verdict_present(compliance_cleared)
    ...
  }

In-flight v1 flow at step_check_threshold:
  FMC1 (forward path): step_check_threshold exists in v2 with same routing -> PASS
  FMC2 (data dependency): step_auto_release in v2 now has precondition
    requiring verdict_present(compliance_cleared). This verdict does not exist
    in the frozen snapshot because v1 never executed step_new_compliance_check. -> FAIL
  FMC4 (directional asymmetry): The flow has already passed the point where
    the new step would have executed. The missing verdict is a direct consequence
    of the asymmetry between v1 and v2's execution history.

Result: Force-migration is UNSAFE at this position.
Executor options: blue-green (let flow complete on v1), abort, or coexistence layer.
```

### Example 3: Position-Sensitive Compatibility (Same Flow, Different Positions)

```
v2 Contract (removed entity state "cancelled" from Order):
  entity Order { states: [draft, submitted, approved] ... }
  -- v1 had: states: [draft, submitted, approved, cancelled]

In-flight v1 flow at step_submit_order:
  -- Order is in state "draft", which exists in v2
  -- No future step transitions to/from "cancelled"
  FMC3 (entity state): "draft" exists in v2 -> PASS
  Result: SAFE

In-flight v1 flow at step_cancel_order:
  -- Order is in state "submitted", which exists in v2
  -- But this step transitions Order to "cancelled", which does NOT exist in v2
  FMC3 (entity state): target state "cancelled" does not exist in v2 -> FAIL
  Result: UNSAFE
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Phase 3.1 defines three policies (blue-green, force-migrate, abort) | Phase 3.3 makes force-migrate precise with formal conditions | This phase | Enables Phase 4 `tenor diff --breaking` to report flow-level compatibility per position |
| Flow changes classified as BREAKING/NON_BREAKING at construct level | Flow changes refined to position-sensitive compatibility analysis | This phase | More nuanced migration guidance for executors |
| Force-migrate is "executor handles consequences" (Section 17.4) | Force-migrate has testable safety conditions per flow instance | This phase | Executor can mechanically determine which flows are safe to migrate |

**Prior art in BPM process instance migration:**

- **Camunda Platform:** Migration plans with explicit activity mapping. Validates hierarchy preservation, activity type compatibility, and completeness (every active leaf activity mapped). Does NOT validate data dependencies -- documents note "validation cannot ensure that such data is useful in the context of the target process definition." Tenor's approach is stronger because the closed-world model makes data dependencies statically enumerable.
- **Flowable:** Process migration with `addActivityMigrationMapping()` for explicit step mapping. Validation via `ProcessInstanceMigrationValidationResult`. Supports automatic migration for same-id activities. Manual mapping required for structural changes.
- **AWS Step Functions:** Blue-green via versions and aliases. In-flight executions continue on old version; new executions route to new version. No force-migration capability -- purely blue-green with optional canary/linear rollout for new executions.
- **XState (xstate-migrate):** JSON Patch operations on persisted snapshots. Generates migration patches to update persisted state to match new machine configuration. Closest to Tenor's force-migrate model but operates on snapshots rather than running processes.
- **Academic (Rinderle et al., 2004; BPMN Migratability, Springer 2012):** Formal framework for migrating BPMN process instances. Defines "region" concept (the set of activities between two sync points) and proves that migration within a completed region is safe. Tenor's position-sensitive analysis is analogous but uses flow's acyclic graph structure rather than BPMN's more general graph model.

**Tenor-specific considerations that differentiate from prior art:**

1. **Frozen verdict semantics** provide stronger isolation than any BPM engine offers. Verdict-layer changes are completely invisible to in-flight flows. This makes more migrations safe than in general BPM.
2. **Exhaustive outcome handling** (Section 11.5) means that operation outcome changes are always flow-level breaking -- there is no "default handler" to absorb new outcomes.
3. **Closed-world semantics** (C5) mean data dependencies are statically enumerable -- unlike BPM engines where variable dependencies are often implicit in code.
4. **Persona authority** at each step adds a dependency dimension that BPM engines typically handle through external authorization systems.
5. **Entity state machines** with explicit transition declarations make state compatibility mechanically checkable -- unlike BPM where "variables" have no declared domain.

## CFFP Invariant Candidates for Flow Migration Compatibility

Based on the analysis above, the following invariants should be declared:

### Compatibility Conditions
- **FMC1 -- Forward path existence:** For every step in every reachable future path from position p in v1, there must exist a step in v2 with equivalent semantics (same operation reference, compatible persona, compatible routing to downstream steps).
- **FMC2 -- Backward data dependency satisfaction:** All data dependencies of v2 steps in reachable future paths from the migration point must be satisfiable. Dependencies are: (a) facts in the frozen snapshot, (b) verdicts in the frozen snapshot, (c) entity states reachable from current entity state via v2 transitions, (d) persona authorization under v2 definitions.
- **FMC3 -- Entity state equivalence:** Every entity whose state was established by the v1 flow execution must have that state available in v2's entity definition. No entity may be in a state that v2's entity construct does not declare.

### Structural Properties
- **FMC4 -- Directional asymmetry:** The compatibility function must account for asymmetry: v2 steps may require state/verdicts/facts that v1 never established because v1's execution path never included the steps that would produce them. Forward path existence alone is insufficient.
- **FMC5 -- Position sensitivity:** Flow compatibility is a function of (flow_definition_v1, flow_definition_v2, current_position, current_entity_states, frozen_snapshot). It is NOT a static property of two flow definitions alone.

### Scope
- **FMC6 -- Recursive sub-flow compatibility:** If the reachable future path includes a SubFlowStep, the referenced sub-flow must itself be compatible at its entry point under the same conditions.
- **FMC7 -- Compatibility does not affect contract semantics:** The compatibility analysis is a deployment-time check. It does not change how flows execute under either v1 or v2. A flow that passes the compatibility check executes under v2 semantics; a flow that fails continues under v1 (or is aborted).

## Concrete Pressure Testing Scenarios

### Scenario 1: Escrow Release (from Appendix C)
- v1 has `standard_release` flow with 5 steps
- v2 adds a new `step_kyc_verification` between `step_confirm` and `step_check_threshold`
- Test positions: at entry (trivially compatible), at step_confirm (may be compatible), at step_check_threshold (asymmetry -- missed KYC step)
- Also test: v2 removes entity state `disputed` from EscrowAccount -- flows at position involving dispute path are incompatible

### Scenario 2: Multi-Week Approval Chain
- A procurement approval flow: step_submit -> step_manager_approve -> step_director_approve -> step_vp_approve -> step_execute -> Terminal
- v2 changes the approval threshold (removes step_vp_approve for amounts under $50k)
- In-flight flow at step_director_approve: forward path includes step_vp_approve which no longer exists in v2 -> INCOMPATIBLE
- In-flight flow at step_execute (already past all approvals): forward path is just Terminal -> COMPATIBLE

### Scenario 3: Subscription Lifecycle
- A subscription flow with recurring billing cycle: step_create -> step_activate -> step_bill_cycle -> step_renew_check -> step_bill_cycle (wait, this is cyclic -- Tenor flows are acyclic!)
- Correct modeling: subscription lifecycle is multiple flow invocations, not a single long-running flow
- Each billing cycle is a separate flow invocation
- v2 changes the billing operation to add a new "prorated" outcome
- In-flight flows at any position: step_bill_cycle references the billing operation which now has a new outcome. Since outcome handling must be exhaustive (Section 11.5), flows that don't handle "prorated" are INCOMPATIBLE

## Open Questions

1. **How fine-grained should step equivalence be?**
   - What we know: FMC1 requires "equivalent semantics" for steps. The strictest definition is byte-for-byte identical step definitions. The loosest is "same operation id."
   - What's unclear: Should routing compatibility allow reordering of outcome targets? Should persona changes be considered breaking for compatibility?
   - Recommendation: The CFFP run should explore candidates with different equivalence granularity. A reasonable starting point: step equivalence = same operation id + same persona + outcome routing targets all exist in v2 (possibly at different step ids but with equivalent semantics transitively).

2. **Should the compatibility definition reference S6 directly or be self-contained?**
   - What we know: S6 (flow path enumeration) provides the mechanism to compute reachable paths. The compatibility definition needs reachable paths.
   - What's unclear: Should the spec define path computation in Section 17 or reference S6?
   - Recommendation: Cross-reference S6. The compatibility definition should say "for every step in every reachable future path (as defined by S6)" rather than re-specifying path enumeration. This keeps Section 17 focused on migration semantics and avoids duplicating S6.

3. **How should the coexistence layer interact with per-flow-type policy declaration?**
   - What we know: Section 17.4 already permits per-flow-type policies. The coexistence layer is essentially per-flow-INSTANCE policy.
   - What's unclear: Does the spec need to acknowledge per-instance policy, or is per-flow-type sufficient?
   - Recommendation: The compatibility definition naturally produces per-instance results. The spec should acknowledge that the force-migrate policy's safety check is per-instance, which means an executor using force-migrate policy may need to fall back to blue-green or abort for specific instances that fail the check. This is the coexistence pattern -- it emerges from position-sensitive compatibility analysis, not from a separate policy declaration.

4. **What is "safe default" for FMC2 backward data dependency?**
   - What we know: FMC2 allows dependencies to be satisfiable from "safe defaults declared in v2" in addition to existing provenance/snapshot.
   - What's unclear: How to define "safe default" precisely. If v2 adds a new fact with a default value, and a v2 step's precondition references that fact, the default makes the dependency satisfiable.
   - Recommendation: A "safe default" is any fact default declared in the v2 contract. Since fact assembly uses declared defaults when external input is absent (Section 5.2), a v2 fact with a default can satisfy dependencies even if v1 never established a value for it. However, the snapshot is frozen at v1 initiation and does NOT include v2 defaults. The executor must determine whether to enrich the frozen snapshot with v2 defaults -- this is an executor implementation concern, not a spec concern. The spec should note this as an executor obligation.

5. **Should TypeDecl changes (shared types) affect flow compatibility?**
   - What we know: TypeDecl changes affect fact types, which affect preconditions, which affect flow steps.
   - What's unclear: Whether TypeDecl changes should be analyzed transitively through to flow compatibility.
   - Recommendation: TypeDecl changes are already classified in Section 17.2. If a TypeDecl change narrows a fact type, and that fact is referenced in a flow step's operation precondition, the transitive impact is captured by FMC2 (data dependency satisfaction). The compatibility definition does not need a separate TypeDecl condition -- it is subsumed by the data dependency check.

## Sources

### Primary (HIGH confidence)
- `docs/TENOR.md` Section 11 (Flow) -- complete flow construct definition including step types, frozen verdict semantics, evaluation model, constraints, and provenance
- `docs/TENOR.md` Section 14 (Complete Evaluation Model) -- flow initiation, per-evaluation sequence, frozen snapshot creation
- `docs/TENOR.md` Section 15 (Static Analysis Obligations) -- S6 flow path enumeration definition
- `docs/TENOR.md` Section 17 (Versioning & Migration) -- existing breaking change taxonomy, migration policies, executor obligations M1-M8
- `docs/cffp/migration-semantics.json` -- Phase 3.1 CFFP artifact with invariants MI1-MI7, three migration policy definitions, breaking change taxonomy canonical form
- `docs/TENOR.md` Appendix C (Worked Example) -- escrow release contract with concrete flow definitions suitable for pressure testing
- `crates/eval/src/flow.rs` -- flow executor implementation showing Snapshot structure, step execution loop, frozen verdict handling

### Secondary (MEDIUM confidence)
- [Camunda Process Instance Migration](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-instance-migration/) -- migration plan validation, activity mapping, hierarchy preservation. Verified through official documentation.
- [Flowable Process Instance Migration](https://www.flowable.com/open-source/docs/bpmn/ch08-ProcessInstanceMigration) -- activity migration mappings, validation API. Verified through official documentation.
- [AWS Step Functions Versioning](https://aws.amazon.com/blogs/compute/deploying-state-machines-incrementally-with-versions-and-aliases-in-aws-step-functions/) -- blue-green deployment with versions and aliases. In-flight executions isolated on old version.
- [xstate-migrate](https://github.com/actor-kit/xstate-migrate) -- JSON Patch-based state machine snapshot migration. Generates migration patches from old/new machine configurations.
- [Migratability of BPMN 2.0 Process Instances (Springer, 2012)](https://link.springer.com/chapter/10.1007/978-3-642-31875-7_8) -- formal framework for process instance migration eligibility.

### Tertiary (LOW confidence)
- "Directional asymmetry" as a named concept in workflow migration appears to be novel to this project. No published literature uses this exact term. The concept itself (new version requires state that old version never established) is acknowledged in Camunda documentation as "validation cannot ensure that such data is useful in the context of the target process definition" and in Flowable as a gap requiring manual data transformation. The term and formal treatment are Tenor-specific contributions.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- This is a spec prose phase following the exact CFFP process pattern from four prior runs
- Architecture: HIGH -- Flow construct is fully specified in TENOR.md Section 11; evaluation model in Section 14; static analysis in Section 15. All needed concepts exist.
- Pitfalls: HIGH -- Frozen verdict semantics interaction is well-documented; the directional asymmetry problem is novel but clearly articulated with concrete examples; coexistence pattern precedent from BPM engines
- CFFP execution: HIGH -- The compatibility conditions are well-defined (three conditions from success criteria), the pressure testing scenarios are concrete (escrow from Appendix C), and the prior CFFP runs provide clear process precedent. The open questions are about refinement granularity, not fundamental feasibility.

**Research date:** 2026-02-21
**Valid until:** Indefinite (spec is frozen at v1.0; flow construct model is stable)
