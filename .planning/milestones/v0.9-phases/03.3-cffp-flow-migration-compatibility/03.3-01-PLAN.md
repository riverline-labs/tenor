---
phase: 03.3-cffp-flow-migration-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/cffp/flow-migration-compatibility.json
autonomous: true
requirements:
  - MIGR-02
must_haves:
  truths:
    - "Flow migration compatibility has a formal definition with three testable conditions (forward path, data dependency, entity state)"
    - "Directional asymmetry is documented as a named structural property with concrete counterexamples"
    - "Each compatibility condition has been pressure-tested against concrete flow scenarios (escrow, approval chain, subscription)"
    - "Position-sensitive analysis is an explicit property — compatibility depends on where the flow is, not just flow structure"
  artifacts:
    - path: "docs/cffp/flow-migration-compatibility.json"
      provides: "Complete CFFP run artifact for flow migration compatibility"
      contains: "FMC1"
  key_links:
    - from: "docs/cffp/flow-migration-compatibility.json"
      to: "docs/cffp/migration-semantics.json"
      via: "Extends Phase 3.1 migration taxonomy with flow-level compatibility refinement"
      pattern: "depends_on.*Migration Semantics"
---

<objective>
Run the CFFP protocol for Flow Migration Compatibility — declaring invariants (FMC1-FMC7), proposing candidate formalisms for position-sensitive compatibility analysis, pressure testing against concrete flow scenarios (escrow release, multi-week approval chain, subscription lifecycle), and producing a canonical form that formally defines when an in-flight flow can be safely force-migrated from v1 to v2.

Purpose: Make the "force-migrate" policy from Section 17.4 precise. Currently, force-migrate says "the executor MUST handle the consequences of breaking changes" — this CFFP run defines the formal conditions under which force-migration is safe vs. unsafe, enabling Phase 4's `tenor diff --breaking` to report flow-level compatibility per position.

Output: `docs/cffp/flow-migration-compatibility.json` — complete CFFP instance with invariants, candidates, counterexamples, collapse test, static obligations, and canonical form.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.3-cffp-flow-migration-compatibility/3.3-RESEARCH.md

# Prior CFFP run — follow the same structure exactly
@docs/cffp/migration-semantics.json

# Spec sections needed for CFFP content
@docs/TENOR.md (Section 11 — Flow construct, Section 14 — Evaluation Model, Section 15 — Static Analysis, Section 17 — Versioning & Migration, Appendix C — Worked Example)
</context>

<tasks>

<task type="auto">
  <name>Task 1: CFFP Phases 1-3 — Invariants, Candidates, and Pressure Testing</name>
  <files>docs/cffp/flow-migration-compatibility.json</files>
  <action>
Create `docs/cffp/flow-migration-compatibility.json` following the exact structure of `docs/cffp/migration-semantics.json`. The CFFP instance must have:

**Protocol and Construct metadata:**
- protocol: CFFP v0.2.1 (same as prior runs)
- construct: "Flow Migration Compatibility" with depends_on including Flow, Operation, Entity, Rule, Fact, Migration Semantics
- version: "1.0"

**Phase 1 — Invariants (FMC1-FMC7):**
Declare seven invariants from the research document:
- FMC1 (Forward path existence): For every step in every reachable future path from position p in v1, there must exist a step in v2 with equivalent semantics (same operation reference, compatible persona, compatible routing).
- FMC2 (Backward data dependency satisfaction): All data dependencies of v2 steps in reachable future paths must be satisfiable from: (a) facts in frozen snapshot, (b) verdicts in frozen snapshot, (c) entity states reachable from current state via v2 transitions, (d) persona authorization under v2 definitions.
- FMC3 (Entity state equivalence): Every entity whose state was established by v1 execution must have that state available in v2's entity definition.
- FMC4 (Directional asymmetry): The compatibility function must account for v2 steps requiring state/verdicts/facts that v1 never established because v1 never executed the steps that would produce them.
- FMC5 (Position sensitivity): Flow compatibility is a function of (flow_def_v1, flow_def_v2, current_position, current_entity_states, frozen_snapshot) — not a static property of two flow definitions alone.
- FMC6 (Recursive sub-flow compatibility): SubFlowStep references must be transitively compatibility-checked.
- FMC7 (No semantic side effects): Compatibility analysis is a deployment-time check — does not change flow execution semantics under either version.

Each invariant must have: id, description, testable (true), structural (true), class (one of: completeness, soundness, determinism).

**Phase 2 — Candidates (at least 2):**
Propose candidate formalisms for expressing the compatibility conditions:

- Candidate A (Graph-theoretic): Define compatibility as a graph morphism from v1's reachable subgraph at position p to v2's step graph. A flow is compatible iff for every path in the reachable subgraph of v1, there exists a corresponding path in v2 with step equivalence at each node and data dependency satisfaction at each edge. Formalize step equivalence as: same operation id + same persona + outcome routing targets all exist.

- Candidate B (Predicate-based): Define compatibility as a conjunction of three predicates: ForwardPathExists(v1, v2, p), DataDependencySatisfied(v1, v2, p, snapshot), EntityStateEquivalent(v1, v2, entity_states). Each predicate is specified with precise input/output types and evaluation rules grounded in Tenor constructs. The three predicates are evaluated independently; compatibility = conjunction of all three.

- Candidate C (Layered analysis): Separate the analysis into three layers corresponding to Tenor's isolation properties: (1) Verdict layer — always isolated by frozen snapshot, no compatibility check needed. (2) Entity state layer — check FMC3 for all entities referenced by remaining steps. (3) Operation/flow layer — check FMC1 + FMC2 for step structure and data dependencies. This candidate leverages the insight that frozen verdict semantics provide natural isolation for one entire layer.

Each candidate must have: id, description, formalism (structure, evaluation_rule, resolution_rule), claims (argument for each invariant).

**Phase 3 — Pressure Testing (8+ counterexamples):**
Test each candidate against concrete scenarios from the research. Each counterexample must name the candidate it targets, describe the scenario, provide the test, and state the result (survives/eliminated/narrowed with narrowing description).

Required scenarios:
1. Escrow release — safe migration at step_check_threshold when only fact type widened (all candidates should survive)
2. Escrow with new compliance step — unsafe migration at step_check_threshold due to directional asymmetry (test FMC4 handling)
3. Position-sensitive compatibility — same flow, different positions yield different results (test FMC5)
4. Multi-week approval chain — removed approval step, flow past vs. before the removed step (tests forward path FMC1)
5. Subscription lifecycle — new outcome on billing operation makes all positions incompatible (tests exhaustive outcome handling interaction with FMC1)
6. SubFlowStep with changed sub-flow — recursive compatibility (test FMC6)
7. ParallelStep with changed branch — both branches must be compatible (test FMC1 with branching)
8. Frozen verdict isolation — Rule changes do NOT break compatibility because verdicts are frozen (validates layer separation)

Each counterexample should test at least one candidate's handling of the scenario and either survive, be eliminated, or produce a scope narrowing.

Write Phases 1-3 to the JSON file. Phase 4-6 will be added in Task 2.
  </action>
  <verify>
- `python3 -m json.tool docs/cffp/flow-migration-compatibility.json` validates JSON syntax
- File has `phase1.invariants` with 7 entries (FMC1-FMC7)
- File has `phase2.candidates` with at least 2 entries
- File has `phase3.counterexamples` with at least 8 entries
- Each invariant has: id, description, testable, structural, class
- Each candidate has: id, description, formalism, claims
- Each counterexample has: id, targets, scenario, test, result
  </verify>
  <done>CFFP Phases 1-3 complete with 7 invariants covering all five compatibility conditions plus scope and semantic safety, at least 2 candidate formalisms with full claims, and 8+ concrete counterexamples testing escrow, approval chain, subscription, sub-flow, parallel step, and frozen verdict scenarios</done>
</task>

<task type="auto">
  <name>Task 2: CFFP Phases 4-6 — Collapse, Static Obligations, and Canonical Form</name>
  <files>docs/cffp/flow-migration-compatibility.json</files>
  <action>
Add Phases 4-6 to the existing `docs/cffp/flow-migration-compatibility.json`:

**Phase 4 — Collapse Test:**
Evaluate which candidates survived Phase 3. Determine if any candidate is a strict superset of others (like the Phase 3.1 hybrid collapse). If one candidate subsumes the others, collapse. If multiple survive independently, select the strongest. Record the collapse rationale.

Expected outcome: The layered analysis (Candidate C) likely subsumes the others by incorporating the graph-theoretic reachable path analysis AND the predicate-based decomposition while additionally leveraging the frozen verdict isolation insight. The collapse should produce a merged canonical candidate that:
1. Uses three-layer analysis (verdict: isolated, entity: FMC3, operation/flow: FMC1+FMC2)
2. Defines step equivalence graph-theoretically (from Candidate A)
3. Specifies each condition as a testable predicate with precise types (from Candidate B)

**Phase 5 — Static Obligations:**
Define what Phase 4 (`tenor diff --breaking`) must implement to support flow-level compatibility analysis. Static obligations should include:
- SO1: Flow path enumeration (reference S6 from Section 15) to compute reachable paths from any position
- SO2: Step equivalence checker comparing v1 steps to v2 steps by operation id, persona, and routing
- SO3: Data dependency enumerator for each v2 step (facts, verdicts, entity states, persona authorization)
- SO4: Position-sensitive compatibility function taking (v1_flow, v2_flow, position, entity_states, snapshot) and returning compatible/incompatible with reasons
- SO5: Per-flow-instance migration recommendation in diff output (compatible_positions, incompatible_positions)

**Phase 6 — Canonical Form:**
Produce the formal statement of flow migration compatibility. This is the authoritative definition that Section 17 will reference. It must include:
- The three-condition conjunction (FMC1 AND FMC2 AND FMC3)
- The step equivalence definition
- The data dependency enumeration
- The directional asymmetry caveat (FMC4)
- The position-sensitivity property (FMC5)
- The recursive sub-flow rule (FMC6)
- The frozen verdict layer isolation observation
- The coexistence layer pattern as an executor implementation strategy (not a spec obligation)
- Scope narrowings from pressure testing as acknowledged limitations

The canonical form's `formal_statement` should be a precise multi-paragraph definition suitable for direct translation into spec prose in Plan 02.
  </action>
  <verify>
- `python3 -m json.tool docs/cffp/flow-migration-compatibility.json` validates JSON syntax
- File has `phase4` with collapse_test and selected_candidate
- File has `phase5` with static_obligations array (5+ entries)
- File has `phase6` with canonical_form containing formal_statement
- The canonical form addresses all seven invariants (FMC1-FMC7)
- The canonical form includes the three-layer analysis structure
- The canonical form includes scope narrowings from pressure testing
  </verify>
  <done>Complete CFFP instance with all 6 phases, producing a canonical form that formally defines flow migration compatibility as a three-condition conjunction evaluated per-position using three-layer analysis (verdict isolated, entity state checked, operation/flow structure checked), with directional asymmetry documented and coexistence layer described as executor strategy</done>
</task>

</tasks>

<verification>
1. `python3 -m json.tool docs/cffp/flow-migration-compatibility.json` — valid JSON
2. The CFFP artifact follows the exact structure of `docs/cffp/migration-semantics.json` (protocol, construct, version, phase1-phase6)
3. All 7 invariants (FMC1-FMC7) are declared with testable=true
4. At least 2 candidates with full formalism and claims
5. At least 8 counterexamples covering all required scenarios
6. Canonical form produces a formal definition that Plan 02 can translate directly into spec prose
7. The definition is position-sensitive (not just flow-type-level)
8. Frozen verdict isolation is explicitly addressed (verdicts are NOT affected by rule/fact changes in-flight)
</verification>

<success_criteria>
- `docs/cffp/flow-migration-compatibility.json` exists and validates as JSON
- CFFP artifact has all 6 phases with complete content
- Canonical form defines force-migration compatibility as a three-condition conjunction: forward path existence (FMC1) AND data dependency satisfaction (FMC2) AND entity state equivalence (FMC3)
- Directional asymmetry (FMC4) and position sensitivity (FMC5) are structural properties of the definition, not separate conditions
- Pressure testing includes at least 3 concrete scenarios with both safe and unsafe migration cases
</success_criteria>

<output>
After completion, create `.planning/phases/03.3-cffp-flow-migration-compatibility/03.3-01-SUMMARY.md`
</output>
