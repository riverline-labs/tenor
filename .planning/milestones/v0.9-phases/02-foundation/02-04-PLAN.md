---
phase: 02-foundation
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - conformance/positive/persona_basic.tenor
  - conformance/positive/persona_basic.expected.json
  - conformance/positive/persona_multiple.tenor
  - conformance/positive/persona_multiple.expected.json
  - conformance/positive/operation_outcomes.tenor
  - conformance/positive/operation_outcomes.expected.json
  - conformance/positive/shared_types.tenor
  - conformance/positive/shared_types.expected.json
  - conformance/negative/pass2/duplicate_persona.tenor
  - conformance/negative/pass2/duplicate_persona.expected-error.json
  - conformance/negative/pass5/persona_undeclared.tenor
  - conformance/negative/pass5/persona_undeclared.expected-error.json
  - conformance/negative/pass5/outcomes_missing.tenor
  - conformance/negative/pass5/outcomes_missing.expected-error.json
  - crates/tenor-core/Cargo.toml
  - crates/tenor-core/tests/schema_validation.rs
  - .github/workflows/ci.yml
  - CLAUDE.md
autonomous: true
requirements:
  - TEST-01
  - TEST-02
  - TEST-08

must_haves:
  truths:
    - "New positive conformance tests for persona, outcomes, and shared types pass"
    - "New negative conformance tests for duplicate persona and undeclared persona produce correct errors"
    - "Every positive conformance test's expected JSON validates against docs/interchange-schema.json"
    - "CI pipeline runs workspace build and conformance suite on push and PR"
    - "Total conformance test count has increased beyond 47"
  artifacts:
    - path: "conformance/positive/persona_basic.tenor"
      provides: "Basic persona declaration test"
      contains: "persona"
    - path: "conformance/positive/operation_outcomes.tenor"
      provides: "Operation with outcomes field test"
      contains: "outcomes"
    - path: "conformance/negative/pass2/duplicate_persona.tenor"
      provides: "Duplicate persona detection test"
      contains: "persona"
    - path: "crates/tenor-core/tests/schema_validation.rs"
      provides: "JSON Schema validation test for all positive conformance outputs"
      contains: "jsonschema"
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
      contains: "cargo"
  key_links:
    - from: "crates/tenor-core/tests/schema_validation.rs"
      to: "docs/interchange-schema.json"
      via: "loads and compiles schema"
      pattern: "interchange-schema\\.json"
    - from: ".github/workflows/ci.yml"
      to: "conformance/"
      via: "runs conformance suite"
      pattern: "run conformance"
---

<objective>
Extend the conformance suite with tests for v1.0 spec constructs (persona, outcomes, shared types), add JSON Schema validation of all interchange outputs, and set up CI pipeline.

Purpose: The conformance suite currently validates v0.3 behavior. New tests prove persona, outcomes, and shared type support works correctly. Schema validation ensures every elaborator output conforms to the formal interchange schema. CI prevents regressions on every commit.

Output: Extended conformance suite (50+ tests), schema validation test, GitHub Actions CI pipeline.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-foundation/02-RESEARCH.md
@.planning/phases/02-foundation/02-01-SUMMARY.md
@.planning/phases/02-foundation/02-03-SUMMARY.md

@docs/TENOR.md (Section 8: Persona, Section 9: Operation)
@docs/interchange-schema.json
@conformance/positive/fact_basic.tenor
@conformance/positive/operation_basic.tenor
@conformance/positive/integration_escrow.tenor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conformance tests for persona, outcomes, and shared types</name>
  <files>
    conformance/positive/persona_basic.tenor
    conformance/positive/persona_basic.expected.json
    conformance/positive/persona_multiple.tenor
    conformance/positive/persona_multiple.expected.json
    conformance/positive/operation_outcomes.tenor
    conformance/positive/operation_outcomes.expected.json
    conformance/positive/shared_types.tenor
    conformance/positive/shared_types.expected.json
    conformance/negative/pass2/duplicate_persona.tenor
    conformance/negative/pass2/duplicate_persona.expected-error.json
    conformance/negative/pass5/persona_undeclared.tenor
    conformance/negative/pass5/persona_undeclared.expected-error.json
    conformance/negative/pass5/outcomes_missing.tenor
    conformance/negative/pass5/outcomes_missing.expected-error.json
  </files>
  <action>
    Create new conformance test fixtures following established conventions. Each positive test is a `.tenor` + `.expected.json` pair. Each negative test is a `.tenor` + `.expected-error.json` pair. All JSON keys must be sorted lexicographically within each object.

    **Positive tests:**

    1. **persona_basic.tenor** — Single persona declaration with minimal dependent constructs:
       ```
       persona admin
       fact status { type: Enum(["active", "inactive"]), source: sys.status }
       entity Account { states: [open, closed], initial: open, transitions: [open -> closed] }
       operation close_account {
         personas: [admin]
         require: status = "active"
         effects: [Account: open -> closed]
       }
       ```
       Generate the corresponding `.expected.json` by running the elaborator and capturing output. Verify the output includes a Persona construct with `"kind": "Persona"`.

    2. **persona_multiple.tenor** — Multiple persona declarations used in different Operations and a Flow:
       ```
       persona reviewer
       persona approver
       fact amount { type: Money(currency: "USD"), source: request.amount }
       entity Request { states: [pending, reviewed, approved], initial: pending, transitions: [pending -> reviewed, reviewed -> approved] }
       operation review_request {
         personas: [reviewer]
         require: amount > $0.00
         effects: [Request: pending -> reviewed]
       }
       operation approve_request {
         personas: [approver]
         require: amount > $0.00
         effects: [Request: reviewed -> approved]
       }
       flow approval {
         snapshot: at_initiation
         entry: step_review
         step step_review { op: review_request, as: reviewer, on_success: step_approve, on_failure: done(failure) }
         step step_approve { op: approve_request, as: approver, on_success: done(success), on_failure: done(failure) }
       }
       ```
       Generate `.expected.json` with persona constructs in the output.

    3. **operation_outcomes.tenor** — Operation with explicit outcomes field:
       ```
       persona agent
       fact claim_amount { type: Money(currency: "USD"), source: claim.amount }
       entity Claim { states: [open, approved, denied], initial: open, transitions: [open -> approved, open -> denied] }
       operation decide_claim {
         personas: [agent]
         require: claim_amount > $0.00
         outcomes: [approved, denied]
         effects: [Claim: open -> approved -> approved, Claim: open -> denied -> denied]
         on_error: [precondition_failed]
       }
       ```
       Adjust the exact syntax to match what the parser expects for effect-to-outcome association. Generate `.expected.json` with `"outcomes"` array present.

    4. **shared_types.tenor** — Type library usage with imported shared types:
       Create a type library file (`conformance/positive/shared_types_lib.tenor`) containing only TypeDecl constructs, and a main file that imports it. This tests the P5 shared type library constraint that type library files contain only TypeDecl constructs.

    **Negative tests:**

    5. **duplicate_persona.tenor** (pass2) — Two personas with the same id:
       ```
       persona admin
       persona admin
       ```
       Expected error: pass 2, construct_kind "Persona", duplicate id.

    6. **persona_undeclared.tenor** (pass5) — Operation referencing undeclared persona:
       ```
       fact x { type: Bool, source: sys.x }
       entity E { states: [a, b], initial: a, transitions: [a -> b] }
       operation op { personas: [nonexistent], require: x = true, effects: [E: a -> b] }
       ```
       Expected error: pass 5, undeclared persona reference.

    7. **outcomes_missing.tenor** (pass5) — If v1.0 requires outcomes on Operations, create a test that fails when outcomes are expected but missing. (Only if the spec mandates this; if outcomes are optional, adjust to test a different validation — e.g., outcome name collision with error_contract.)

    **IMPORTANT:** Generate expected JSON by running the elaborator on each positive test file and capturing the actual output:
    ```
    cargo run -p tenor-cli -- elaborate conformance/positive/persona_basic.tenor > conformance/positive/persona_basic.expected.json
    ```
    Then verify the JSON is correct by inspection. For negative tests, construct the expected error JSON manually following the error format: `{ "pass": N, "construct_kind": "...", "construct_id": "...", "field": "...", "file": "...", "line": N, "message": "..." }`.

    **Adapt test content to actual parser syntax.** The research provides example syntax but the actual parser may differ. Read `crates/tenor-core/src/parser.rs` to confirm the exact syntax for persona declarations and outcomes fields. Adjust fixture content accordingly.
  </action>
  <verify>
    Run `cargo run -p tenor-cli -- run conformance` — all tests pass (old 47 + new tests).
    Verify new test files exist: `ls conformance/positive/persona_*.tenor conformance/positive/operation_outcomes.tenor conformance/positive/shared_types*.tenor`.
    Verify negative tests exist: `ls conformance/negative/pass2/duplicate_persona.tenor conformance/negative/pass5/persona_undeclared.tenor`.
    Count total tests — should be at least 50.
  </verify>
  <done>
    Conformance suite extended with positive tests for persona (basic + multiple), Operation outcomes, shared types, and negative tests for duplicate persona and undeclared persona. Total test count exceeds 50.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add JSON Schema validation test and CI pipeline</name>
  <files>
    crates/tenor-core/Cargo.toml
    crates/tenor-core/tests/schema_validation.rs
    .github/workflows/ci.yml
    CLAUDE.md
  </files>
  <action>
    **Part A: Schema validation test (TEST-08)**

    1. **Add jsonschema dev-dependency** to `crates/tenor-core/Cargo.toml`:
       ```toml
       [dev-dependencies]
       jsonschema = "0.28"
       glob = "0.3"
       ```

    2. **Create integration test** at `crates/tenor-core/tests/schema_validation.rs`:
       ```rust
       //! Validates all positive conformance test expected JSONs against the formal interchange schema.

       use std::path::Path;

       #[test]
       fn validate_all_positive_conformance_outputs_against_schema() {
           let schema_path = Path::new(env!("CARGO_MANIFEST_DIR"))
               .join("../../docs/interchange-schema.json");
           let schema_src = std::fs::read_to_string(&schema_path)
               .unwrap_or_else(|e| panic!("Failed to read schema at {}: {}", schema_path.display(), e));
           let schema_value: serde_json::Value = serde_json::from_str(&schema_src).unwrap();
           let compiled = jsonschema::compile(&schema_value)
               .unwrap_or_else(|e| panic!("Failed to compile schema: {}", e));

           let conformance_root = Path::new(env!("CARGO_MANIFEST_DIR"))
               .join("../../conformance");

           let mut tested = 0;
           let mut failures = Vec::new();

           // Check all directories with expected.json files
           for dir_name in &["positive", "numeric", "promotion", "shorthand"] {
               let dir = conformance_root.join(dir_name);
               if !dir.exists() { continue; }
               for entry in std::fs::read_dir(&dir).unwrap() {
                   let path = entry.unwrap().path();
                   if path.extension().map_or(true, |e| e != "json") { continue; }
                   if !path.to_string_lossy().contains("expected.json") { continue; }
                   if path.to_string_lossy().contains("expected-error.json") { continue; }

                   let json_src = std::fs::read_to_string(&path).unwrap();
                   let instance: serde_json::Value = serde_json::from_str(&json_src).unwrap();
                   let result = compiled.validate(&instance);
                   if let Err(errors) = result {
                       let error_msgs: Vec<String> = errors.map(|e| e.to_string()).collect();
                       failures.push(format!("{}: {}", path.display(), error_msgs.join("; ")));
                   }
                   tested += 1;
               }
           }

           // Also check cross_file expected JSONs
           let cross_dir = conformance_root.join("cross_file");
           if cross_dir.exists() {
               for entry in std::fs::read_dir(&cross_dir).unwrap() {
                   let path = entry.unwrap().path();
                   if path.extension().map_or(true, |e| e != "json") { continue; }
                   if !path.to_string_lossy().contains("expected.json") { continue; }
                   if path.to_string_lossy().contains("expected-error.json") { continue; }

                   let json_src = std::fs::read_to_string(&path).unwrap();
                   let instance: serde_json::Value = serde_json::from_str(&json_src).unwrap();
                   let result = compiled.validate(&instance);
                   if let Err(errors) = result {
                       let error_msgs: Vec<String> = errors.map(|e| e.to_string()).collect();
                       failures.push(format!("{}: {}", path.display(), error_msgs.join("; ")));
                   }
                   tested += 1;
               }
           }

           assert!(tested > 0, "No conformance expected.json files found — check paths");
           assert!(failures.is_empty(),
               "Schema validation failed for {} of {} files:\n{}",
               failures.len(), tested, failures.join("\n"));

           eprintln!("Schema validation passed for {} expected.json files", tested);
       }
       ```

       **Note:** Adapt the code to the actual `jsonschema` crate API (version 0.28). The API may use `jsonschema::validator_for()` instead of `jsonschema::compile()`. Check the crate docs. The `glob` crate may not be needed if we iterate directories manually as shown above.

       **Potential schema issues:** If the interchange schema requires fields that the current elaborator omits (e.g., `outcomes` on Operations, `tenor_version` on bundle), the test will surface these gaps. Fix by either updating the schema to make those fields optional or updating the elaborator output to include them. The schema was authored from the spec, so the elaborator may need adjustments.

    **Part B: CI pipeline (TEST-01)**

    3. **Create `.github/workflows/ci.yml`:**
       ```yaml
       name: CI

       on:
         push:
           branches: [main, v1]
         pull_request:
           branches: [main, v1]

       jobs:
         test:
           runs-on: ubuntu-latest
           steps:
             - uses: actions/checkout@v4

             - uses: dtolnay/rust-toolchain@stable

             - uses: Swatinem/rust-cache@v2

             - name: Build workspace
               run: cargo build --workspace

             - name: Run conformance suite
               run: cargo run -p tenor-cli -- run conformance

             - name: Run schema validation and unit tests
               run: cargo test --workspace

             - name: Check formatting
               run: cargo fmt --all -- --check

             - name: Run clippy
               run: cargo clippy --workspace -- -D warnings
       ```

       Include both `main` and `v1` branches (current branch is `v1`). The pipeline runs: workspace build, conformance suite (via tenor-cli), all tests (including schema validation), formatting check, and clippy lints.

    **Part C: Update CLAUDE.md**

    4. **Update CLAUDE.md** build/test section to include the new commands:
       - Add `cargo test --workspace` for running schema validation and unit tests
       - Note the CI pipeline at `.github/workflows/ci.yml`
       - Update the expected conformance count from "47/47" to the new count
  </action>
  <verify>
    Run `cargo test -p tenor-core` — schema validation test passes.
    Run `cargo run -p tenor-cli -- run conformance` — all tests pass.
    Verify `.github/workflows/ci.yml` exists and contains expected job structure.
    Verify CLAUDE.md references the new test command and updated test count.
  </verify>
  <done>
    Schema validation test validates all positive conformance expected JSONs against `docs/interchange-schema.json`. CI pipeline configured for workspace build, conformance suite, schema validation, formatting, and clippy on every push/PR. CLAUDE.md updated.
  </done>
</task>

</tasks>

<verification>
1. `cargo run -p tenor-cli -- run conformance` passes all tests (50+)
2. `cargo test -p tenor-core` passes schema validation test
3. `cargo test --workspace` passes all tests
4. `.github/workflows/ci.yml` exists with build, conformance, test, fmt, clippy steps
5. New conformance fixtures exist for persona, outcomes, shared types
6. Negative test fixtures exist for duplicate persona and undeclared persona
7. CLAUDE.md reflects updated test commands and conformance count
</verification>

<success_criteria>
- Conformance suite extended to 50+ tests covering persona, outcomes, and shared types
- Every positive conformance expected JSON validates against the interchange schema
- CI pipeline runs all suites on push and PR to main/v1
- CLAUDE.md updated with new build/test instructions
</success_criteria>

<output>
After completion, create `.planning/phases/02-foundation/02-04-SUMMARY.md`
</output>
