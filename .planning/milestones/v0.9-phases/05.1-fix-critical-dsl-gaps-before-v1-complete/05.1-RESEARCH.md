# Phase 05.1: Fix Critical DSL Gaps Before v1-Complete - Research

**Researched:** 2026-02-22
**Domain:** DSL parser/lexer, elaborator, evaluator, interchange schema, static analysis
**Confidence:** HIGH

## Summary

Phase 5 Domain Validation identified 13 gaps across 5 real-world contracts. Three were evaluator bugs (fixed inline). Four are inherent to the language model (no fix needed). The remaining gaps represent genuine DSL feature deficits where the spec defines features that the toolchain does not implement. Phase 05.1 must close three categories of gaps: (1) effect-to-outcome mapping syntax for multi-outcome operations (GAP-006/010/013, HIGH priority), (2) bounded existential quantification (GAP-003, MEDIUM priority), and (3) S6 flow path analysis following Escalate handler targets (GAP-007, LOW priority). A fourth item, CLI flow evaluation (GAP-008, MEDIUM priority), is a CLI ergonomics improvement.

All four gaps have well-defined scope. The spec already defines the semantics for each feature. The interchange schema already supports the `outcome` field on effects. The evaluator already supports effect-to-outcome routing. The primary work is in the parser, serializer, and conformance tests, with secondary work in the interchange schema (adding `ExistsExpr`), the evaluator (adding `Exists` predicate variant), and S6 analysis.

**Primary recommendation:** Implement effect-to-outcome mapping syntax first (highest impact, 3/5 domains hit this), then `exists` quantifier, then S6 escalation path tracing, then CLI flow eval.

## Standard Stack

### Core

This phase works entirely within the existing Rust codebase. No new dependencies needed.

| Crate | Purpose | Files Affected |
|-------|---------|----------------|
| `tenor-core` | Lexer, parser, AST, type checker, validator, serializer | `lexer.rs`, `ast.rs`, `parser.rs`, `pass4_typecheck.rs`, `pass5_validate.rs`, `pass6_serialize.rs` |
| `tenor-eval` | Evaluator predicate engine, operation executor | `types.rs`, `predicate.rs` |
| `tenor-analyze` | S6 flow path enumeration | `s6_flow_paths.rs` |
| `tenor-cli` | CLI eval subcommand | `main.rs` |

### Supporting

| Library | Purpose |
|---------|---------|
| `serde_json` | Interchange JSON serialization (already a dependency) |
| `clap 4.5` | CLI argument parsing (already a dependency) |

### Alternatives Considered

None. All work is within existing crates using existing patterns.

## Architecture Patterns

### Pattern 1: Adding a New Token (Exists Quantifier)

The lexer recognizes Unicode operators by character match. Adding `exists` requires:

1. **Lexer** (`lexer.rs`): Add `Exists` variant to `Token` enum. Add `\u{2203}` (there-exists, ∃) to the Unicode operator match block. Also recognize the ASCII keyword `exists` in the identifier path (same pattern as how `forall` is handled through `Word("forall")` — but currently `forall` uses the Unicode token directly, not a keyword).

Current `forall` handling: The lexer produces `Token::Forall` for `\u{2200}`. The parser matches `Token::Forall` in `parse_atom_expr`. The ASCII word `forall` is NOT currently recognized — only the Unicode symbol.

For `exists`: Add `Token::Exists` for `\u{2203}`. The parser should handle it identically to `Forall` but produce `RawExpr::Exists`.

2. **AST** (`ast.rs`): Add `RawExpr::Exists` variant mirroring `RawExpr::Forall` with identical fields (`var`, `domain`, `body`, `line`).

3. **Parser** (`parser.rs`): In `parse_atom_expr`, add a branch for `Token::Exists` that parses identically to `Token::Forall` but produces `RawExpr::Exists`.

4. **Type checker** (`pass4_typecheck.rs`): Add `RawExpr::Exists` handling identical to `RawExpr::Forall` (same domain type check, same body type check).

5. **Serializer** (`pass6_serialize.rs`): Add `RawExpr::Exists` handling identical to `RawExpr::Forall` but emit `"quantifier": "exists"`.

6. **Interchange schema** (`docs/interchange-schema.json`): Add `ExistsExpr` definition mirroring `ForallExpr` but with `"quantifier": {"const": "exists"}`. Add it to the `PredicateExpression` oneOf array.

7. **Evaluator** (`crates/eval/src/types.rs`): In `parse_predicate`, add check for `quantifier == "exists"` → `Predicate::Exists`. Add `Predicate::Exists` variant to the enum.

8. **Evaluator** (`crates/eval/src/predicate.rs`): Add `Predicate::Exists` evaluation: iterate elements, short-circuit on first `true` (inverse of `Forall` which short-circuits on first `false`).

**Example — `Exists` evaluation logic:**
```rust
Predicate::Exists { variable, variable_type: _, domain, body } => {
    let domain_val = eval_pred(domain, facts, verdicts, ctx, collector)?;
    let elements = match domain_val {
        Value::List(items) => items,
        _ => return Err(EvalError::TypeError {
            message: format!("exists domain must be a List, got {}", domain_val.type_name()),
        }),
    };
    for elem in &elements {
        let mut inner_ctx = ctx.clone();
        inner_ctx.bindings.insert(variable.clone(), elem.clone());
        let result = eval_pred(body, facts, verdicts, &inner_ctx, collector)?;
        if result.as_bool()? {
            return Ok(Value::Bool(true)); // short-circuit on first match
        }
    }
    Ok(Value::Bool(false))
}
```

### Pattern 2: Adding Effect-to-Outcome Mapping Syntax

The spec DSL syntax (Section 9) is:
```
effects: [
  Claim: review -> approved  -> approved,
  Claim: review -> rejected  -> rejected
]
```

The fourth element after the third `->` is the outcome label. Currently `parse_effects()` parses `(entity, from, to)` tuples. The extension:

1. **AST** (`ast.rs`): Change `Operation.effects` from `Vec<(String, String, String, u32)>` to `Vec<(String, String, String, Option<String>, u32)>` — adding optional outcome label.

2. **Parser** (`parser.rs`): In `parse_effects()`, after parsing `to`, check for another `Comma` or `Gt` (arrow) token. If found, parse the outcome label word. Otherwise, leave `None`.

Current effect tuple parse:
```rust
let entity = self.take_word()?;
self.expect_comma()?;
let from = self.take_word()?;
self.expect_comma()?;
let to = self.take_word()?;
self.expect_rparen()?;
effects.push((entity, from, to, e_line));
```

Extended with optional outcome:
```rust
let entity = self.take_word()?;
self.expect_comma()?;
let from = self.take_word()?;
self.expect_comma()?;
let to = self.take_word()?;
// Optional outcome label: (Entity, from, to, outcome_label)
let outcome = if self.peek() == &Token::Comma || self.peek() == &Token::Gt {
    self.advance();
    Some(self.take_word()?)
} else {
    None
};
self.expect_rparen()?;
effects.push((entity, from, to, outcome, e_line));
```

Note: The spec shows `->` between the `to` state and the outcome label: `review -> approved -> approved`. The lexer produces `Token::Gt` for both `->` and `→`. So the separator between `to` and `outcome_label` can be either `,` or `>` (which represents `->` in the token stream).

3. **Pass 5 validation** (`pass5_validate.rs`): Add validation for multi-outcome operations:
   - If an operation declares 2+ outcomes, every effect MUST have an outcome label
   - Each outcome label must reference a declared outcome
   - For single-outcome operations, outcome label is optional (inferred)

4. **Serializer** (`pass6_serialize.rs`): When emitting effect objects, include `"outcome": label` if the outcome label is `Some`. For single-outcome operations with no explicit label, the evaluator already handles inference.

5. **Evaluator**: Already handles `effect.outcome` field — no changes needed in the evaluator itself. The `parse_effect()` function in `types.rs` already reads the optional `"outcome"` field from interchange JSON.

### Pattern 3: S6 Escalation Path Tracing

S6 (`s6_flow_paths.rs`) currently follows:
- `OperationStep` → outcome targets
- `BranchStep` → if_true, if_false targets
- `HandoffStep` → next target
- `SubFlowStep` → on_success, on_failure targets
- `ParallelStep` → join targets

It does NOT follow `on_failure` handlers on `OperationStep` that use `Escalate` (which has a `next` field pointing to another step). The fix:

In the `OperationStep` match arm, after processing outcome targets, also check `on_failure`:
- If `on_failure.kind == "Escalate"`, extract `on_failure.next` and add it to the DFS stack as an additional reachable path.
- This ensures steps reachable through Escalate are not reported as unreachable.

### Pattern 4: CLI Flow Evaluation

Current `tenor eval` only calls `tenor_eval::evaluate()` (rule-level evaluation). The extension adds `--flow` and `--persona` flags:

```rust
Eval {
    bundle: PathBuf,
    #[arg(long)]
    facts: PathBuf,
    #[arg(long)]
    flow: Option<String>,
    #[arg(long)]
    persona: Option<String>,
},
```

When `--flow` is provided, call `tenor_eval::evaluate_flow()` instead of `tenor_eval::evaluate()`. Requires passing initial entity states (derived from entity definitions in the bundle).

### Anti-Patterns to Avoid

- **Do not add ASCII keywords for `exists`/`forall` at this time.** The DSL uses Unicode operators consistently (`∀`, `∃`, `∧`, `∨`, `¬`). Adding ASCII aliases like the word `exists` would be a separate design decision. The current `forall` in the parser only recognizes `Token::Forall` (which is `\u{2200}`), not the word "forall". Be consistent: add `Token::Exists` for `\u{2203}` only.
  - **CORRECTION:** Actually, looking more carefully at the parser's `parse_atom_expr`, it only checks `self.peek() == &Token::Forall` — so the word "forall" typed as ASCII is NOT recognized. Only the Unicode `∀` character works. The `exists` feature should follow the same pattern: only `∃` (U+2203) works. However, consider that the spec DSL examples may show ASCII keywords. This should be clarified during planning.

- **Do not change the AST type signature from tuple to struct for effects.** While a struct would be cleaner, it would require changes throughout the entire codebase (all 6 passes, conformance runner, etc.). Keep the tuple with an added element for now.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Unicode character handling | Custom char parsing | Existing lexer `match c` pattern | Pattern is established, just add one more match arm |
| JSON schema validation | Manual JSON checks | `jsonschema` crate (already used) | Conformance tests already validate interchange against schema |
| Effect-to-outcome validation | Custom outcome matching | Extend existing Pass 5 validation | Pass 5 already validates outcomes, effects, and their relationship |

## Common Pitfalls

### Pitfall 1: Breaking Existing Conformance Tests by Changing AST Tuple Size

**What goes wrong:** Changing `Operation.effects` from 4-tuple to 5-tuple breaks every pattern match on effects throughout the codebase.
**Why it happens:** The tuple `(String, String, String, u32)` is matched in pass2, pass4, pass5, pass6, and the conformance runner.
**How to avoid:** Do a `grep` for all sites that destructure `effects` tuples. Update them all at once. The new element is `Option<String>`, so existing patterns just need `_` or explicit handling.
**Warning signs:** Compiler errors after changing the tuple type — this is expected and the compiler will find all sites.

### Pitfall 2: Interchange Schema Must Match Serializer Output Exactly

**What goes wrong:** Adding `ExistsExpr` to the schema but forgetting to add it to the `PredicateExpression` oneOf, or adding it with wrong required fields.
**Why it happens:** Schema is manually maintained separately from the serializer code.
**How to avoid:** The `ExistsExpr` definition should be an exact copy of `ForallExpr` with `"quantifier": {"const": "exists"}` instead of `"forall"`. Add the `$ref` to `PredicateExpression.oneOf`.
**Warning signs:** Schema validation test failures in `cargo test --workspace`.

### Pitfall 3: Effect-to-Outcome Validation Must Handle Single-Outcome Operations

**What goes wrong:** Pass 5 rejects single-outcome operations that don't have explicit outcome labels on effects.
**Why it happens:** Over-eagerly requiring outcome labels when the spec says they're only required for multi-outcome operations.
**How to avoid:** The validation rule is: if `outcomes.len() >= 2`, then every effect MUST have an outcome label. If `outcomes.len() == 1`, outcome labels on effects are optional (inferred from the sole outcome).
**Warning signs:** Existing conformance tests failing — all existing operations are single-outcome.

### Pitfall 4: S6 Escalation Path Tracing May Create Duplicate Paths

**What goes wrong:** Following Escalate targets creates paths that overlap with normal outcome paths, inflating path counts.
**Why it happens:** Escalate is an error path, not a normal outcome. It should produce separate paths but not duplicate the normal paths.
**How to avoid:** When following an Escalate handler, create a new path fork from the failing step (with a "failure/escalate" outcome annotation), not from the beginning.
**Warning signs:** Path count inflation in S6 output.

### Pitfall 5: CLI Flow Eval Requires Entity Initial States

**What goes wrong:** `evaluate_flow()` needs initial entity states, but the CLI only has the interchange bundle JSON.
**Why it happens:** Entity initial states are derived from entity definitions (each entity starts in its `initial` state), but the evaluator API expects them as input.
**How to avoid:** Extract entity initial states from the bundle's entity constructs before calling `evaluate_flow()`. The bundle JSON contains entity constructs with `initial` fields.
**Warning signs:** Missing entity state errors at flow evaluation time.

## Code Examples

### Effect-to-Outcome DSL Syntax (from Spec Section 9)

```
// Single-outcome (existing, no change needed):
operation approve_order {
  allowed_personas: [reviewer]
  precondition: verdict_present(eligible)
  effects: [(Order, pending, approved)]
  outcomes: [approved]
  error_contract: [precondition_failed]
}

// Multi-outcome (new syntax):
operation decide_claim {
  allowed_personas: [adjudicator]
  precondition: verdict_present(claim_eligible)
  outcomes: [approved, rejected]
  effects: [
    (Claim, review, approved, approved),
    (Claim, review, rejected, rejected)
  ]
  error_contract: [precondition_failed]
}
```

### Exists Quantifier DSL Syntax (from Spec Section 10.2)

```
// Universal (existing):
rule all_items_valid {
  stratum: 0
  when: ∀ item ∈ inspection_items . item.compliant = true
  produce: verdict all_valid { payload: Bool = true }
}

// Existential (new):
rule any_item_defective {
  stratum: 0
  when: ∃ item ∈ inspection_items . item.compliant = false
  produce: verdict has_defect { payload: Bool = true }
}
```

### Interchange JSON for Exists

```json
{
  "body": { "left": {"field_ref": {"field": "compliant", "var": "item"}}, "op": "=", "right": {"literal": false, "type": {"base": "Bool"}} },
  "domain": { "fact_ref": "inspection_items" },
  "quantifier": "exists",
  "variable": "item",
  "variable_type": { "base": "Record", "fields": { "compliant": { "base": "Bool" } } }
}
```

### Interchange JSON for Multi-Outcome Effects

```json
{
  "effects": [
    { "entity_id": "Claim", "from": "review", "outcome": "approved", "to": "approved" },
    { "entity_id": "Claim", "from": "review", "outcome": "rejected", "to": "rejected" }
  ],
  "outcomes": ["approved", "rejected"]
}
```

## Gap-to-Implementation Mapping

| Gap ID | Priority | Scope | Files Changed | Tests Needed |
|--------|----------|-------|---------------|--------------|
| GAP-006/010/013 | HIGH | Parser + AST + Pass5 + Pass6 | `ast.rs`, `parser.rs`, `pass5_validate.rs`, `pass6_serialize.rs` + all pattern match sites | Positive: multi-outcome operation elaboration. Negative: effect without outcome on multi-outcome op, effect with undeclared outcome |
| GAP-003 | MEDIUM | Lexer + Parser + AST + Pass4 + Pass6 + Schema + Evaluator | `lexer.rs`, `ast.rs`, `parser.rs`, `pass4_typecheck.rs`, `pass6_serialize.rs`, `interchange-schema.json`, `types.rs`, `predicate.rs` | Positive: exists quantifier elaboration + evaluation. Negative: exists on non-List domain |
| GAP-007 | LOW | S6 analyzer | `s6_flow_paths.rs` | Test: flow with Escalate handler has no false-positive unreachable steps |
| GAP-008 | MEDIUM | CLI | `main.rs` | Integration test: `tenor eval --flow <id> --persona <p>` |

## Detailed Change Analysis

### GAP-006/010/013: Effect-to-Outcome Mapping

**Affected files and exact changes:**

1. `crates/core/src/ast.rs` line 179: Change `effects: Vec<(String, String, String, u32)>` to `effects: Vec<(String, String, String, Option<String>, u32)>`
2. `crates/core/src/parser.rs` `parse_effects()` (line 903): After parsing `to`, optionally parse outcome label
3. `crates/core/src/pass5_validate.rs`: Add validation — multi-outcome ops require outcome labels on all effects, outcome labels must be declared outcomes
4. `crates/core/src/pass6_serialize.rs` (line 196-204): Emit `"outcome"` field on effect objects when present
5. All pattern match sites for `effects` tuple — compiler will find these

**Conformance tests needed:**
- `positive/multi_outcome_operation.tenor` + `.expected.json`: Operation with 2 outcomes and effect-to-outcome mapping
- `negative/pass5/effect_missing_outcome.tenor` + `.expected-error.json`: Multi-outcome operation with effect that has no outcome label
- `negative/pass5/effect_undeclared_outcome.tenor` + `.expected-error.json`: Effect with outcome label not in outcomes list

### GAP-003: Exists Quantifier

**Affected files and exact changes:**

1. `crates/core/src/lexer.rs`: Add `Exists` to `Token` enum (after `Forall`). Add `\u{2203}` match in Unicode operators block.
2. `crates/core/src/ast.rs`: Add `RawExpr::Exists { var, domain, body, line }` variant.
3. `crates/core/src/parser.rs` `parse_atom_expr()`: Add `Token::Exists` branch mirroring `Token::Forall`.
4. `crates/core/src/pass4_typecheck.rs`: Add `RawExpr::Exists` handling (same as `Forall`).
5. `crates/core/src/pass6_serialize.rs`: Add `RawExpr::Exists` serialization with `"quantifier": "exists"`.
6. `docs/interchange-schema.json`: Add `ExistsExpr` definition. Add to `PredicateExpression` oneOf.
7. `crates/eval/src/types.rs`: Add `Predicate::Exists` variant. Add parse logic for `quantifier == "exists"`.
8. `crates/eval/src/predicate.rs`: Add `Predicate::Exists` evaluation (short-circuit on first true).

**Conformance tests needed:**
- `positive/exists_quantifier.tenor` + `.expected.json`: Rule using `∃`
- Evaluator test: exists evaluates correctly (true when any element matches, false when none match)

### GAP-007: S6 Escalation Path Tracing

**Affected file:** `crates/analyze/src/s6_flow_paths.rs`

In the `OperationStep` match arm (around line 143), after processing outcomes, check `on_failure`:
- If the step has `on_failure` with `kind == "Escalate"` and a `next` field, push the `next` step onto the DFS stack as an additional path.

**Test needed:** Flow with Escalate handler where the escalation target step is correctly reported as reachable.

### GAP-008: CLI Flow Evaluation

**Affected file:** `crates/cli/src/main.rs`

Add `--flow` and `--persona` optional args to `Eval` subcommand. When `--flow` is provided:
1. Extract entity initial states from bundle
2. Call `tenor_eval::evaluate_flow()` with the specified flow, persona, facts, and entity states
3. Format and display the flow result (similar to rule verdict display)

**Test needed:** CLI integration test with `--flow` flag.

## Open Questions

1. **Should ASCII keywords `exists` and `forall` be recognized alongside Unicode?**
   - What we know: Currently only Unicode `∀` (U+2200) is recognized for forall. The spec uses Unicode in the grammar (Section 10.2). The DSL examples in TENOR.md use Unicode.
   - What's unclear: Whether contract authors would benefit from ASCII fallbacks (e.g., `exists` keyword, `forall` keyword) when Unicode input is inconvenient.
   - Recommendation: For Phase 05.1, implement Unicode-only (`∃`) to match the existing `∀` pattern. ASCII aliases can be a separate improvement. This keeps the scope tight.

2. **Should the domain contract fixtures be updated to use the new features?**
   - What we know: GAP-006/010/013 affected 3 domain contracts that used BranchStep workarounds. GAP-003 affected 1 domain contract that used De Morgan workaround.
   - What's unclear: Whether updating domain contracts is in scope for Phase 05.1 or should be a follow-up.
   - Recommendation: Update at least one domain contract per gap to demonstrate the feature works end-to-end. But this could be a separate plan within the phase.

3. **Effect-to-outcome syntax: comma or arrow as separator?**
   - What we know: The spec shows `Claim: review -> approved  -> approved` (arrow syntax). But the parser uses `(Entity, from, to)` parenthesized tuple syntax, not colon/arrow syntax.
   - What's unclear: Should the tuple syntax be `(Entity, from, to, outcome)` with comma, or `(Entity, from, to -> outcome)` with arrow?
   - Recommendation: Use comma: `(Entity, from, to, outcome)`. This is consistent with the existing tuple syntax. The arrow syntax shown in the spec DSL examples uses a different notation style than what the parser implements. The parser uses `(Claim, review, approved, approved_label)` parenthesized tuples. The comma separator is natural within a tuple.

## Sources

### Primary (HIGH confidence)
- `docs/TENOR.md` — Sections 9 (Operation), 10 (PredicateExpression), 10.2 (Grammar showing `∃`), 9.1 (effect-to-outcome DSL syntax), 9.5 (interchange representation with `outcome` on effects)
- `docs/interchange-schema.json` — `Effect` definition already has optional `outcome` field; `ForallExpr` is the template for `ExistsExpr`
- `.planning/phases/05-domain-validation/05-SPEC-GAP-REPORT.md` — All 13 gaps catalogued with severity
- `.planning/phases/05-domain-validation/gap-log.md` — Raw gap findings with implementation details

### Secondary (HIGH confidence — source code inspection)
- `crates/core/src/lexer.rs` — Token enum, Unicode operator handling
- `crates/core/src/ast.rs` — RawExpr, RawConstruct, effect tuple types
- `crates/core/src/parser.rs` — parse_effects(), parse_atom_expr() (forall handling)
- `crates/core/src/pass4_typecheck.rs` — Forall type checking pattern
- `crates/core/src/pass5_validate.rs` — Operation/effect validation
- `crates/core/src/pass6_serialize.rs` — Forall serialization pattern, effect serialization
- `crates/eval/src/types.rs` — Predicate enum, parse_predicate(), Effect struct with `outcome: Option<String>`
- `crates/eval/src/predicate.rs` — Forall evaluation pattern
- `crates/eval/src/operation.rs` — Effect-to-outcome routing (already implemented)
- `crates/analyze/src/s6_flow_paths.rs` — DFS path enumeration, missing Escalate handler tracing

## Metadata

**Confidence breakdown:**
- Effect-to-outcome mapping: HIGH — spec defines it, evaluator supports it, only parser/serializer gap
- Exists quantifier: HIGH — spec defines it, identical pattern to forall, well-scoped
- S6 escalation tracing: HIGH — clear gap in DFS traversal, localized fix
- CLI flow eval: MEDIUM — requires understanding evaluate_flow() API and entity state initialization

**Research date:** 2026-02-22
**Valid until:** 2026-03-22 (stable — all findings based on current codebase)
