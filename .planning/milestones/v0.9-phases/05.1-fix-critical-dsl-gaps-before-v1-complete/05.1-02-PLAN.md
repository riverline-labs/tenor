---
phase: 05.1-fix-critical-dsl-gaps-before-v1-complete
plan: 02
type: execute
wave: 2
depends_on:
  - "05.1-01"
files_modified:
  - crates/core/src/lexer.rs
  - crates/core/src/ast.rs
  - crates/core/src/parser.rs
  - crates/core/src/pass4_typecheck.rs
  - crates/core/src/pass6_serialize.rs
  - docs/interchange-schema.json
  - crates/eval/src/types.rs
  - crates/eval/src/predicate.rs
  - conformance/positive/exists_quantifier.tenor
  - conformance/positive/exists_quantifier.expected.json
autonomous: true
requirements:
  - CLI-02
  - SPEC-02  # Secondary: exists quantifier is a predicate expression gap (GAP-003), not directly Operation outcome typing; CLI-02 (elaborator correctness) is the primary fit

must_haves:
  truths:
    - "The exists quantifier (U+2203) is recognized by the lexer and parsed into RawExpr::Exists"
    - "Rules using exists quantifier elaborate to interchange JSON with quantifier: exists"
    - "The evaluator correctly evaluates exists quantifier (true when any element matches, false when none match)"
    - "The interchange schema validates ExistsExpr documents"
    - "Existing forall quantifier behavior is unchanged"
  artifacts:
    - path: "crates/core/src/lexer.rs"
      provides: "Token::Exists for U+2203"
      contains: "Exists"
    - path: "crates/core/src/ast.rs"
      provides: "RawExpr::Exists variant"
      contains: "Exists"
    - path: "crates/eval/src/predicate.rs"
      provides: "Predicate::Exists evaluation"
      contains: "Exists"
    - path: "docs/interchange-schema.json"
      provides: "ExistsExpr schema definition"
      contains: "ExistsExpr"
    - path: "conformance/positive/exists_quantifier.tenor"
      provides: "Positive conformance fixture for exists quantifier"
    - path: "conformance/positive/exists_quantifier.expected.json"
      provides: "Expected interchange JSON for exists quantifier"
  key_links:
    - from: "crates/core/src/lexer.rs"
      to: "crates/core/src/parser.rs"
      via: "Token::Exists consumed by parse_atom_expr()"
      pattern: "Token::Exists"
    - from: "crates/core/src/pass6_serialize.rs"
      to: "docs/interchange-schema.json"
      via: "Serialized ExistsExpr validates against schema"
      pattern: "quantifier.*exists"
    - from: "crates/eval/src/types.rs"
      to: "crates/eval/src/predicate.rs"
      via: "Predicate::Exists parsed from interchange JSON, evaluated in predicate engine"
      pattern: "Exists"
---

<objective>
Implement bounded existential quantification (exists / U+2203) across the full elaboration and evaluation pipeline (GAP-003).

Purpose: The spec defines bounded existential quantification (Section 10.2) alongside universal quantification (forall). The lexer/parser only supports forall (U+2200). Supply chain contracts needed "exists item in list: item.defective = true" and had to use the De Morgan workaround `not (forall item in list . item.compliant = true)`. Adding exists is a small, well-scoped change that mirrors the existing forall implementation at every stage.

Output: Full `exists` support from lexer token through parser, type checker, serializer, interchange schema, and evaluator evaluation.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-fix-critical-dsl-gaps-before-v1-complete/05.1-RESEARCH.md
@.planning/phases/05.1-fix-critical-dsl-gaps-before-v1-complete/05.1-01-SUMMARY.md

# Source files (forall pattern to mirror)
@crates/core/src/lexer.rs
@crates/core/src/ast.rs
@crates/core/src/parser.rs
@crates/core/src/pass4_typecheck.rs
@crates/core/src/pass6_serialize.rs
@docs/interchange-schema.json
@crates/eval/src/types.rs
@crates/eval/src/predicate.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exists quantifier to lexer, parser, elaboration passes, schema, and evaluator</name>
  <files>
    crates/core/src/lexer.rs
    crates/core/src/ast.rs
    crates/core/src/parser.rs
    crates/core/src/pass4_typecheck.rs
    crates/core/src/pass6_serialize.rs
    docs/interchange-schema.json
    crates/eval/src/types.rs
    crates/eval/src/predicate.rs
  </files>
  <action>
    Mirror the existing `forall` implementation at every stage. For each file, find the `Forall` handling and add a parallel `Exists` path.

    1. **Lexer** (`lexer.rs`):
       - Add `Exists` variant to `Token` enum (after `Forall` line, currently at line 36: `Forall, // U+2200`). Add comment: `Exists, // U+2203`.
       - In the Unicode operator match block (around line 334 where `'\u{2200}' => Token::Forall`), add: `'\u{2203}' => Token::Exists`.
       - Unicode-only: do NOT add an ASCII keyword alias. This matches the existing forall pattern (only U+2200 works, not the word "forall").

    2. **AST** (`ast.rs`):
       - Add `RawExpr::Exists { var: String, domain: Box<RawExpr>, body: Box<RawExpr>, line: u32 }` variant. Place it after the `Forall` variant with identical field structure.

    3. **Parser** (`parser.rs`):
       - In `parse_atom_expr()` (around line 445 where `Token::Forall` is matched), add a branch for `Token::Exists`. The parsing logic is identical: consume the token, parse variable name, expect `In` or element-of token, parse domain expression, expect dot, parse body expression. Produce `RawExpr::Exists { var, domain, body, line }`.

    4. **Type checker** (`pass4_typecheck.rs`):
       - Find the `RawExpr::Forall { .. }` match arm. Add a parallel arm for `RawExpr::Exists { var, domain, body, line }` with identical type checking logic: check domain is a List type, bind variable to element type, check body is Bool, return Bool.

    5. **Serializer** (`pass6_serialize.rs`):
       - Find the `RawExpr::Forall { .. }` serialization arm. Add a parallel arm for `RawExpr::Exists { var, domain, body, line }` producing identical JSON structure but with `"quantifier": "exists"` instead of `"quantifier": "forall"`.

    6. **Interchange schema** (`docs/interchange-schema.json`):
       - Find the `ForallExpr` definition in `$defs`. Copy it to create `ExistsExpr` with `"quantifier": {"const": "exists"}` instead of `"const": "forall"`.
       - Find the `PredicateExpression` `oneOf` array. Add `{"$ref": "#/$defs/ExistsExpr"}` to the array.

    7. **Evaluator types** (`crates/eval/src/types.rs`):
       - Add `Predicate::Exists { variable: String, variable_type: Option<String>, domain: Box<Predicate>, body: Box<Predicate> }` variant to the `Predicate` enum (after `Forall`).
       - In `parse_predicate()`, find the `quantifier == "forall"` check. Add a parallel check: if `quantifier == "exists"`, produce `Predicate::Exists { variable, variable_type, domain, body }`.

    8. **Evaluator predicate engine** (`crates/eval/src/predicate.rs`):
       - Find the `Predicate::Forall` match arm. Add `Predicate::Exists` with inverse logic: iterate domain elements, bind each to the variable in context, evaluate body. Short-circuit return `Ok(Value::Bool(true))` on first `true` result. After exhausting all elements, return `Ok(Value::Bool(false))`. Record provenance the same way as Forall.

    9. **Build verification**: Run `cargo build --workspace` to confirm compilation.
  </action>
  <verify>
    `cargo build --workspace` succeeds.
    `cargo test --workspace` passes all existing tests (forall behavior unchanged).
    `cargo run -p tenor-cli -- test conformance` passes all existing conformance tests.
  </verify>
  <done>
    The exists quantifier (U+2203) is implemented across the full pipeline: lexer tokenizes it, parser produces RawExpr::Exists, type checker validates it, serializer emits quantifier: "exists" in interchange JSON, interchange schema validates ExistsExpr, and evaluator correctly evaluates existential quantification with short-circuit semantics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conformance fixtures and evaluator test for exists quantifier</name>
  <files>
    conformance/positive/exists_quantifier.tenor
    conformance/positive/exists_quantifier.expected.json
  </files>
  <action>
    1. **Positive conformance fixture** (`conformance/positive/exists_quantifier.tenor`): Create a contract that uses the exists quantifier. Example:
       ```
       type InspectionItem {
         item_id: Text,
         compliant: Bool
       }

       fact inspection_items: List(InspectionItem)

       rule has_defect {
         stratum: 0
         when: ∃ item ∈ inspection_items . item.compliant = false
         produce: verdict defect_found { payload: Bool = true }
       }
       ```
       Use the Unicode symbol U+2203 (∃) and U+2208 (element-of ∈) to match the forall pattern. Check what element-of token the parser expects for forall and use the same.

    2. **Expected JSON** (`conformance/positive/exists_quantifier.expected.json`): Elaborate the .tenor file using `cargo run -p tenor-cli -- elaborate conformance/positive/exists_quantifier.tenor` and capture the output. Verify the interchange JSON contains `"quantifier": "exists"` in the predicate expression. Save as the expected JSON with all keys sorted lexicographically.

    3. **Evaluator test**: Add an evaluator test (in `crates/eval/src/` test module or `crates/eval/tests/`) that verifies:
       - `exists` returns `true` when at least one element matches the body predicate
       - `exists` returns `false` when no element matches
       Use the elaborated interchange JSON from the conformance fixture, or create a test that directly constructs the Predicate::Exists and evaluates it.

    4. Run `cargo run -p tenor-cli -- test conformance` to verify the new fixture passes.
    5. Run `cargo test --workspace` to verify the evaluator test passes.
  </action>
  <verify>
    `cargo run -p tenor-cli -- test conformance` passes all tests including the new exists_quantifier fixture.
    `cargo test --workspace` passes including the evaluator exists test.
  </verify>
  <done>
    The exists quantifier has a positive conformance fixture proving correct elaboration, and an evaluator test proving correct evaluation semantics (true on first match, false when exhausted). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- compiles without errors
2. `cargo test --workspace` -- all tests pass (including new evaluator exists test)
3. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass (including new exists_quantifier fixture)
4. Manually verify: `cargo run -p tenor-cli -- elaborate conformance/positive/exists_quantifier.tenor` produces JSON with `"quantifier": "exists"`
5. Schema validation: the exists_quantifier expected JSON validates against `docs/interchange-schema.json`
6. No regressions: all existing forall-based tests pass unchanged
</verification>

<success_criteria>
- Lexer recognizes U+2203 as Token::Exists
- Parser produces RawExpr::Exists with identical structure to Forall
- Type checker validates Exists (domain is List, body is Bool)
- Serializer emits `"quantifier": "exists"` in interchange JSON
- Interchange schema includes ExistsExpr definition and validates exists expressions
- Evaluator Predicate::Exists short-circuits on first true (inverse of Forall's short-circuit on first false)
- Positive conformance fixture passes
- Evaluator test confirms correct true/false behavior
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-fix-critical-dsl-gaps-before-v1-complete/05.1-02-SUMMARY.md`
</output>
