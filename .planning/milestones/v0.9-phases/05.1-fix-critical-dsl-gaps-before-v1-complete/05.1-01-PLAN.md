---
phase: 05.1-fix-critical-dsl-gaps-before-v1-complete
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/ast.rs
  - crates/core/src/parser.rs
  - crates/core/src/pass2_index.rs
  - crates/core/src/pass4_typecheck.rs
  - crates/core/src/pass5_validate.rs
  - crates/core/src/pass6_serialize.rs
  - conformance/positive/multi_outcome_operation.tenor
  - conformance/positive/multi_outcome_operation.expected.json
  - conformance/negative/pass5/effect_missing_outcome.tenor
  - conformance/negative/pass5/effect_missing_outcome.expected-error.json
  - conformance/negative/pass5/effect_undeclared_outcome.tenor
  - conformance/negative/pass5/effect_undeclared_outcome.expected-error.json
autonomous: true
requirements:
  - SPEC-02
  - CLI-02

must_haves:
  truths:
    - "Multi-outcome operations with effect-to-outcome mapping syntax elaborate correctly"
    - "Single-outcome operations without outcome labels continue to elaborate unchanged"
    - "Pass 5 rejects multi-outcome operations where an effect is missing its outcome label"
    - "Pass 5 rejects effects that reference an undeclared outcome"
  artifacts:
    - path: "crates/core/src/ast.rs"
      provides: "Operation effects tuple with optional outcome label"
      contains: "Option<String>"
    - path: "crates/core/src/parser.rs"
      provides: "Effect-to-outcome parsing in parse_effects()"
      contains: "outcome"
    - path: "crates/core/src/pass5_validate.rs"
      provides: "Multi-outcome effect validation"
      contains: "outcome"
    - path: "conformance/positive/multi_outcome_operation.tenor"
      provides: "Positive conformance fixture for multi-outcome operations"
    - path: "conformance/positive/multi_outcome_operation.expected.json"
      provides: "Expected interchange JSON for multi-outcome operations"
  key_links:
    - from: "crates/core/src/parser.rs"
      to: "crates/core/src/ast.rs"
      via: "parse_effects() produces 5-tuple with outcome label"
      pattern: "effects\\.push"
    - from: "crates/core/src/pass5_validate.rs"
      to: "crates/core/src/ast.rs"
      via: "Validates outcome labels against declared outcomes"
      pattern: "outcome"
    - from: "crates/core/src/pass6_serialize.rs"
      to: "interchange JSON"
      via: "Emits outcome field on effect objects when present"
      pattern: "outcome"
---

<objective>
Implement effect-to-outcome mapping syntax for multi-outcome operations in the DSL parser and elaboration pipeline (GAP-006/010/013).

Purpose: This is the single highest-priority DSL gap -- hit independently in 3 of 5 domain contracts during Phase 5 validation. The spec describes multi-outcome operations with effect-to-outcome mapping, the interchange schema already supports the `outcome` field on effects, and the evaluator already handles effect-to-outcome routing. Only the parser and serializer lack the syntax. Closing this gap enables contract authors to express multi-outcome operations naturally instead of using the BranchStep workaround.

Output: Updated parser recognizing `(Entity, from, to, outcome_label)` syntax, Pass 5 validation for outcome label correctness, Pass 6 serialization of the outcome field, and conformance fixtures proving the feature works.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-fix-critical-dsl-gaps-before-v1-complete/05.1-RESEARCH.md

# Source files
@crates/core/src/ast.rs
@crates/core/src/parser.rs
@crates/core/src/pass5_validate.rs
@crates/core/src/pass6_serialize.rs
@docs/interchange-schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add effect-to-outcome mapping to AST, parser, and all elaboration passes</name>
  <files>
    crates/core/src/ast.rs
    crates/core/src/parser.rs
    crates/core/src/pass2_index.rs
    crates/core/src/pass4_typecheck.rs
    crates/core/src/pass5_validate.rs
    crates/core/src/pass6_serialize.rs
  </files>
  <action>
    1. **AST** (`ast.rs`): Change `Operation.effects` from `Vec<(String, String, String, u32)>` to `Vec<(String, String, String, Option<String>, u32)>`. The 4th element is the optional outcome label, the 5th is the line number.

    2. **Parser** (`parser.rs`): In `parse_effects()`, after parsing `to`, check if the next token is a comma followed by a word (not `RParen`). If so, consume the comma and parse the outcome label word. Otherwise, leave outcome as `None`. The syntax is `(Entity, from, to, outcome_label)` with comma separator. Be careful: the existing code has `self.expect_rparen()` after parsing `to`. The new logic: peek after `to` -- if next is `Comma`, advance past comma, peek again -- if next is a Word (not RParen), parse it as outcome label. Then expect RParen.

    3. **All pattern match sites**: After changing the tuple from 4 to 5 elements, the Rust compiler will find every site that destructures the effects tuple. Update each site:
       - `pass2_index.rs`: Any effects iteration -- add `_` for the new outcome field
       - `pass4_typecheck.rs`: Any effects iteration -- add `_` for outcome field
       - `pass5_validate.rs`: Effects validation -- see Task 1 step 4
       - `pass6_serialize.rs`: Effect serialization -- see Task 1 step 5
       - Any other match sites the compiler identifies

    4. **Pass 5 validation** (`pass5_validate.rs`): Add new validation rules for multi-outcome operations:
       - If an operation declares `outcomes.len() >= 2`, then every effect MUST have `outcome.is_some()`. Error if any effect is missing an outcome label.
       - Each outcome label (when present) MUST exist in the operation's `outcomes` list. Error if an effect references an undeclared outcome.
       - For single-outcome operations (`outcomes.len() <= 1`), outcome labels on effects are optional.
       - Error format: `ElabError` with pass=5, appropriate construct_kind="Operation", construct_id, field="effects", and descriptive message.

    5. **Pass 6 serialization** (`pass6_serialize.rs`): In the effect serialization block (where `entity_id`, `from`, `to` are emitted), add: if `outcome.is_some()`, emit `"outcome": label_value` in the effect JSON object. Keys must remain sorted lexicographically (entity_id, from, outcome, to).

    6. **Build verification**: Run `cargo build --workspace` to confirm compilation. The compiler will catch any missed pattern match sites.
  </action>
  <verify>
    `cargo build --workspace` succeeds with no errors.
    `cargo test --workspace` passes all existing tests (no regressions -- existing single-outcome operations should be unaffected).
    `cargo run -p tenor-cli -- test conformance` passes all existing conformance tests.
  </verify>
  <done>
    The AST, parser, type checker, validator, and serializer all handle the optional outcome label on effects. All existing tests continue to pass, confirming backward compatibility for single-outcome operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conformance fixtures for multi-outcome operations</name>
  <files>
    conformance/positive/multi_outcome_operation.tenor
    conformance/positive/multi_outcome_operation.expected.json
    conformance/negative/pass5/effect_missing_outcome.tenor
    conformance/negative/pass5/effect_missing_outcome.expected-error.json
    conformance/negative/pass5/effect_undeclared_outcome.tenor
    conformance/negative/pass5/effect_undeclared_outcome.expected-error.json
  </files>
  <action>
    1. **Positive fixture** (`conformance/positive/multi_outcome_operation.tenor`): Create a contract with a multi-outcome operation. Example:
       ```
       type ClaimRecord { status: Text }
       persona adjudicator {}
       entity Claim { states: [review, approved, rejected] initial: review }
       fact claim_data: ClaimRecord
       fact claim_eligible: Bool
       rule check_eligible {
         stratum: 0
         when: claim_data.status = "ready"
         produce: verdict claim_eligible_v { payload: Bool = true }
       }
       operation decide_claim {
         allowed_personas: [adjudicator]
         precondition: claim_eligible = true
         outcomes: [approved, rejected]
         effects: [
           (Claim, review, approved, approved),
           (Claim, review, rejected, rejected)
         ]
         error_contract: [precondition_failed]
       }
       ```

    2. **Expected JSON** (`conformance/positive/multi_outcome_operation.expected.json`): Elaborate the .tenor file using `cargo run -p tenor-cli -- elaborate conformance/positive/multi_outcome_operation.tenor` and capture the output. Verify the effects array in the interchange JSON contains `"outcome"` fields. Save as the expected JSON. Ensure all JSON keys are sorted lexicographically.

    3. **Negative fixture: effect missing outcome** (`conformance/negative/pass5/effect_missing_outcome.tenor`): Create a contract where a multi-outcome operation (2+ outcomes) has an effect WITHOUT an outcome label. The expected error should be a Pass 5 error on the "effects" field indicating the missing outcome label.

    4. **Expected error** (`conformance/negative/pass5/effect_missing_outcome.expected-error.json`): Error JSON with `pass: 5`, `construct_kind: "Operation"`, `field: "effects"`, and message about missing outcome label.

    5. **Negative fixture: undeclared outcome** (`conformance/negative/pass5/effect_undeclared_outcome.tenor`): Create a contract where an effect references an outcome label that is NOT in the operation's outcomes list. The expected error should reference the undeclared outcome.

    6. **Expected error** (`conformance/negative/pass5/effect_undeclared_outcome.expected-error.json`): Error JSON with `pass: 5`, `construct_kind: "Operation"`, `field: "effects"`, and message about undeclared outcome.

    7. Run `cargo run -p tenor-cli -- test conformance` to verify all fixtures pass.
  </action>
  <verify>
    `cargo run -p tenor-cli -- test conformance` passes all tests including the 3 new fixtures.
    `cargo test --workspace` passes.
  </verify>
  <done>
    Three conformance fixtures exist: one positive proving multi-outcome operations elaborate correctly with outcome fields in interchange JSON, two negative proving Pass 5 catches missing and undeclared outcome labels. All conformance tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- compiles without errors
2. `cargo test --workspace` -- all unit tests pass
3. `cargo run -p tenor-cli -- test conformance` -- all conformance tests pass (including new multi-outcome fixtures)
4. Manually verify: `cargo run -p tenor-cli -- elaborate conformance/positive/multi_outcome_operation.tenor` produces JSON with `"outcome"` fields on effects
5. No regressions: all existing single-outcome operations continue to elaborate identically
</verification>

<success_criteria>
- Multi-outcome operation DSL syntax `(Entity, from, to, outcome_label)` is parsed and elaborated correctly
- Pass 5 enforces outcome labels on multi-outcome operations and validates against declared outcomes
- Interchange JSON includes `"outcome"` field on effects for multi-outcome operations
- All existing conformance tests pass unchanged (backward compatibility)
- Three new conformance fixtures (1 positive, 2 negative) all pass
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-fix-critical-dsl-gaps-before-v1-complete/05.1-01-SUMMARY.md`
</output>
