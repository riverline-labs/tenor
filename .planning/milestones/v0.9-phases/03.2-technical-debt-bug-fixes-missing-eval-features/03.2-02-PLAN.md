---
phase: 03.2-technical-debt-bug-fixes-missing-eval-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/parser.rs
  - crates/core/src/pass3_types.rs
  - crates/core/src/pass4_typecheck.rs
  - crates/core/src/pass5_validate.rs
  - crates/cli/src/ambiguity/api.rs
  - crates/cli/src/ambiguity/compare.rs
  - crates/cli/src/ambiguity/report.rs
  - crates/cli/src/ambiguity/mod.rs
  - Cargo.toml
  - crates/cli/Cargo.toml
  - crates/core/Cargo.toml
autonomous: true
requirements: []  # Remediation work â€” no v1.0 requirement ID; tracked by success criteria

must_haves:
  truths:
    - "No unjustified .unwrap() calls remain in non-test code of tenor-core"
    - "Ambiguity API retry logic uses structured HTTP status codes, not string substring matching"
    - "Dead code annotations in ambiguity module are either removed (fields used) or justified with comments"
    - "jsonschema dependency is declared once in workspace Cargo.toml, not duplicated in crate-level Cargo.toml files"
  artifacts:
    - path: "crates/core/src/parser.rs"
      provides: "Safe integer parsing replacing unwrap"
      contains: "expect|map_err|parse.*Result"
    - path: "crates/core/src/pass3_types.rs"
      provides: "SAFETY comments on justified invariant unwraps"
      contains: "SAFETY:"
    - path: "crates/cli/src/ambiguity/api.rs"
      provides: "Structured retry logic using HTTP status codes"
      contains: "status.*429|extract_http_status|u16"
    - path: "Cargo.toml"
      provides: "Workspace-level jsonschema dependency"
      contains: "jsonschema"
  key_links:
    - from: "crates/cli/Cargo.toml"
      to: "Cargo.toml"
      via: "workspace dependency reference for jsonschema"
      pattern: "jsonschema.*workspace"
    - from: "crates/core/Cargo.toml"
      to: "Cargo.toml"
      via: "workspace dependency reference for jsonschema"
      pattern: "jsonschema.*workspace"
---

<objective>
Clean up tech debt items from the codebase concerns audit: eliminate unwrap fragility in tenor-core, replace string-match retry logic in the ambiguity API client, address dead code annotations, and normalize workspace dependencies.

Purpose: Code quality and maintainability improvements that reduce the surface area for future bugs. These are independent of the evaluator bug fixes and can run in parallel.
Output: Hardened core parsing, annotated safety invariants, structured retry logic, clean workspace deps.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-technical-debt-bug-fixes-missing-eval-features/03.2-RESEARCH.md

@crates/core/src/parser.rs
@crates/core/src/pass3_types.rs
@crates/core/src/pass4_typecheck.rs
@crates/core/src/pass5_validate.rs
@crates/cli/src/ambiguity/api.rs
@crates/cli/src/ambiguity/mod.rs
@Cargo.toml
@crates/cli/Cargo.toml
@crates/core/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and fix unwrap fragility in tenor-core</name>
  <files>
    crates/core/src/parser.rs
    crates/core/src/pass3_types.rs
    crates/core/src/pass4_typecheck.rs
    crates/core/src/pass5_validate.rs
  </files>
  <action>
Audit every `.unwrap()` call in non-test code of tenor-core and either fix or annotate:

**T1 - parser.rs:125** (`w.parse().unwrap()`):
This parses a string token to an integer. The lexer should guarantee the string is numeric, but this is the most concerning unwrap. Replace with `.map_err(|e| ElabError::parse(...))` returning a proper parse error. The pattern should be: `w.parse::<i64>().map_err(|_| ElabError::parse(&format!("invalid integer literal: {}", w), file, line))?`

**T2 - pass3_types.rs:46,50,51,52,79,113** (6 unwraps):
These are in cycle detection and type resolution where the code has just confirmed the key exists. For each:
- If the unwrap is preceded by a check that guarantees the key exists (e.g., `if decls.contains_key(name)` then `decls.get(name).unwrap()`), add `// SAFETY: key existence verified by <check> above` comment.
- If the invariant is not obvious, restructure using `if let Some(val) = decls.get(name)`.
- Specifically: lines 50-52 are in `resolve_one()` after `decls.contains_key()` -- these are safe but need `// SAFETY:` annotation. Line 79 is `in_stack.iter().position(|x| x == name).unwrap()` after detecting `name` is in `in_stack` -- safe, add `// SAFETY: name was just detected in in_stack by the if-let above`. Line 113 is `env.get(dep).unwrap()` after iterating keys from `decls` which should be in `env` -- document or restructure.

**T3 - pass4_typecheck.rs:176-177** (`products.iter().min().unwrap()` and `.max().unwrap()`):
The `products` array is built from 4 elements (`[a*c, a*d, b*c, b*d]`), so it is always non-empty. Add comment: `// SAFETY: products has exactly 4 elements (all range endpoint products)`. No code change needed beyond the comment.

**T4 - pass5_validate.rs:623,734,851,861** (4 unwraps):
Audit each:
- Line 623: likely in entity validation. Check context -- if it's after a `.get()` on a map that was just populated, annotate with `// SAFETY:`.
- Line 734: likely in operation validation. Same analysis.
- Line 851: in parallel branch conflict detection. Check the `b2_trace.as_ref().unwrap()` pattern noted in CONCERNS.md. Per the concerns audit, this IS safe (the branch only runs when `b2_trace` is `Some`), but restructure to `if let Some(t) = b2_trace.as_ref()` for clarity.
- Line 861: same area. Restructure similarly.

Do NOT change the actual logic -- only add safety annotations or restructure to eliminate unwrap where the invariant is fragile.
  </action>
  <verify>
Run `cargo build --workspace` -- no warnings or errors. Run `cargo test --workspace` -- all 55 conformance tests and all unit tests pass. Run `cargo clippy --workspace` -- no new clippy warnings. Grep for `.unwrap()` in non-test code of core/src/ and verify each remaining instance has a `// SAFETY:` comment.
  </verify>
  <done>
Every .unwrap() in non-test tenor-core code is either replaced with proper error handling (parser.rs integer parse) or annotated with a `// SAFETY:` comment explaining the invariant that prevents the panic (pass3_types.rs, pass4_typecheck.rs, pass5_validate.rs). The most dangerous unwrap (parser.rs:125) now returns a proper ElabError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix ambiguity retry logic, dead code, and workspace deps</name>
  <files>
    crates/cli/src/ambiguity/api.rs
    crates/cli/src/ambiguity/compare.rs
    crates/cli/src/ambiguity/report.rs
    crates/cli/src/ambiguity/mod.rs
    Cargo.toml
    crates/cli/Cargo.toml
    crates/core/Cargo.toml
  </files>
  <action>
**T5 - String-match retry replacement (api.rs ~lines 162-171):**
Replace the `is_retryable()` function that uses `error.contains("429")` etc. with structured HTTP status code extraction. Add an `extract_http_status(error: &str) -> Option<u16>` helper that finds a 3-digit HTTP status code in the error string (ureq v3 formats errors with the status code accessible). The retryable check becomes: `matches!(status, 429 | 500 | 502 | 503)` for HTTP errors, plus `error.contains("connection") || error.contains("timeout")` for network-level errors. See RESEARCH.md "Fix 6" for the implementation pattern.

**T6 - Dead code annotations (ambiguity/*.rs):**
There are 6 `#[allow(dead_code)]` annotations across the ambiguity module. For each:
1. Check if the field/struct IS used somewhere downstream. If yes, remove the annotation.
2. If the field is not used, determine if it SHOULD be used (e.g., a field that was designed for future reporting). If it's used in a serialized output or display, ensure it's actually read somewhere. If genuinely unused and not needed, remove the field entirely.
3. For `AmbiguityTestCase` fields in mod.rs: check if `contract_path`, `facts_path`, `verdicts_path`, `spec_sections` are read by any calling code. They may be read by the orchestrator in mod.rs -- trace the usage.
4. For `AmbiguityRunResult` fields: check if `total_cases`, `mismatches`, `errors`, `results` are consumed. They may be returned but never read by the caller.
5. If fields are part of the public API return type and the caller currently ignores them, add a `// Used by callers to inspect run results` comment and keep the `#[allow(dead_code)]` with a justification comment: `#[allow(dead_code)] // Public API: consumed by external callers`.

**T7 - Workspace dependency normalization (Cargo.toml files):**
`jsonschema = "0.42"` appears in both `crates/cli/Cargo.toml:15` and `crates/core/Cargo.toml:12` as dev-dependencies. Normalize:
1. Add `jsonschema = "0.42"` to `[workspace.dependencies]` in the root `Cargo.toml`.
2. Replace the version pin in both crate-level `Cargo.toml` files with `jsonschema.workspace = true` (under `[dev-dependencies]`).
3. Verify no other duplicated dependencies exist by comparing root workspace deps against crate-level deps. If found, normalize those too.
  </action>
  <verify>
Run `cargo build --workspace` -- succeeds. Run `cargo test --workspace` -- all tests pass. Run `cargo clippy --workspace` -- no new warnings. Grep for `is_retryable` in api.rs and verify it uses structured status code matching. Grep for `#[allow(dead_code)]` in ambiguity/ and verify each instance has a justification or was removed. Grep for `jsonschema = "0.42"` in crate-level Cargo.toml files -- should be zero matches (only workspace reference).
  </verify>
  <done>
Ambiguity API retry logic uses structured HTTP status code extraction instead of string matching. Dead code annotations are either justified with comments or removed. jsonschema dependency declared once in workspace root Cargo.toml with workspace references in crate-level files.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds with no new warnings
2. `cargo test --workspace` passes all existing tests
3. `cargo clippy --workspace` clean
4. `cargo run -p tenor-cli -- test conformance` still reports 55/55 passing
5. No unjustified `.unwrap()` in non-test tenor-core code
6. No `error.contains("429")` or similar string-match patterns in api.rs
7. `jsonschema` in workspace deps, not duplicated in crate-level Cargo.toml
</verification>

<success_criteria>
- All unwraps in non-test core code are either replaced with proper error handling or annotated with SAFETY comments
- Ambiguity retry logic is robust against error message format changes
- Workspace dependency hygiene established (no version drift possible for jsonschema)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-technical-debt-bug-fixes-missing-eval-features/03.2-02-SUMMARY.md`
</output>
