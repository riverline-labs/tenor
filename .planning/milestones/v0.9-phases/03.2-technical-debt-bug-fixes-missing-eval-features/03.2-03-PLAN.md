---
phase: 03.2-technical-debt-bug-fixes-missing-eval-features
plan: 03
type: execute
wave: 2
depends_on:
  - 03.2-01
files_modified:
  - crates/eval/src/flow.rs
  - crates/eval/src/lib.rs
  - conformance/eval/positive/parallel_step.tenor
  - conformance/eval/positive/parallel_step.facts.json
  - conformance/eval/positive/parallel_step.verdicts.json
  - conformance/eval/positive/compensate_handler.tenor
  - conformance/eval/positive/compensate_handler.facts.json
  - conformance/eval/positive/compensate_handler.verdicts.json
  - conformance/eval/positive/escalate_handler.tenor
  - conformance/eval/positive/escalate_handler.facts.json
  - conformance/eval/positive/escalate_handler.verdicts.json
autonomous: true
requirements: []  # Remediation work â€” no v1.0 requirement ID; tracked by success criteria

must_haves:
  truths:
    - "ParallelStep executes all branches with isolated entity state clones and merges results on join"
    - "Compensate failure handler executes compensation steps in order, then routes to the then target"
    - "Escalate failure handler records persona transfer and routes to the next step"
    - "SubFlowStep Compensate and Escalate handlers work the same as OperationStep handlers"
    - "Flow initiating_persona is recorded in FlowResult for provenance (not used for authorization gating)"
    - "Each implemented feature has at least one eval conformance test"
  artifacts:
    - path: "crates/eval/src/flow.rs"
      provides: "ParallelStep execution, Compensate handler, Escalate handler"
      contains: "ParallelStep|Compensate|Escalate|branch_entity_states"
    - path: "crates/eval/src/lib.rs"
      provides: "Persona provenance recording in evaluate_flow"
      contains: "initiating_persona|persona.*provenance"
    - path: "conformance/eval/positive/parallel_step.verdicts.json"
      provides: "ParallelStep conformance test expected output"
    - path: "conformance/eval/positive/compensate_handler.verdicts.json"
      provides: "Compensate handler conformance test expected output"
    - path: "conformance/eval/positive/escalate_handler.verdicts.json"
      provides: "Escalate handler conformance test expected output"
  key_links:
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/operation.rs"
      via: "execute_operation called for each compensation step and parallel branch"
      pattern: "execute_operation"
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/types.rs"
      via: "EvalError::FlowError for parallel branch and handler errors"
      pattern: "EvalError::FlowError"
---

<objective>
Implement the three deferred evaluator features: ParallelStep execution, Compensate failure handler, and Escalate failure handler. Also wire the flow initiating_persona parameter for provenance. Each feature gets conformance test fixtures.

Purpose: Complete the evaluator's coverage of the Tenor spec's flow execution semantics. Contracts using parallel steps, compensation, or escalation currently fail at runtime with opaque "not yet implemented" errors. After this plan, all spec-defined flow features are functional.
Output: Working ParallelStep, Compensate, and Escalate in flow.rs; persona provenance in lib.rs; 3+ conformance test fixtures.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-technical-debt-bug-fixes-missing-eval-features/03.2-RESEARCH.md
@.planning/phases/03.2-technical-debt-bug-fixes-missing-eval-features/03.2-01-SUMMARY.md

@crates/eval/src/flow.rs
@crates/eval/src/lib.rs
@crates/eval/src/types.rs
@crates/eval/src/operation.rs
@docs/TENOR.md (Section 11: Flow, Section 11.2: Step Types, Section 11.3: Failure Handling, Section 11.5: Constraints)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ParallelStep, Compensate, and Escalate in flow.rs</name>
  <files>
    crates/eval/src/flow.rs
    crates/eval/src/lib.rs
  </files>
  <action>
Implement the three missing flow features and wire persona provenance:

**F1 - ParallelStep execution (flow.rs ~lines 335-339):**
Replace the `TypeError("not yet implemented")` with actual parallel branch execution per spec Section 11.5:

1. For each branch in `branches`, clone `entity_states` to create an isolated `branch_entity_states`.
2. Build a branch-local step sequence and execute it. Each branch is essentially a mini-flow: iterate through its steps using the SAME `execute_flow` step-walking logic (or a shared helper). The branch shares the parent flow's immutable `Snapshot` but has its own mutable entity states.
3. Collect branch outcomes. Use a `BranchOutcome` enum or tuple `(branch_id, Result<String, EvalError>)` -- NOT string-based outcome classification.
4. After all branches complete, merge entity state changes back to the parent `entity_states`. The spec guarantees non-overlapping entity effect sets (validated at elaboration), so merge is safe -- just apply each branch's final entity states for entities it modified.
5. Evaluate the join policy:
   - `on_all_success`: if all branches completed without error, route to this target
   - `on_any_failure`: if any branch errored, route to this target
   - `on_all_complete`: route here regardless (after success/failure routing)
6. Route to the appropriate `StepTarget` (terminal or step ref).

See RESEARCH.md "Pattern 3" for the code structure. Adapt to the actual `FlowStep::ParallelStep` variant fields in the existing code (check what fields are actually parsed: branches, join).

**F2 - Compensate failure handler (flow.rs ~lines 189-198):**
Replace the `TypeError` with compensation execution per spec Section 11.3:

1. When a step fails and the failure handler is `FailureHandler::Compensate { steps, then }`:
2. Execute each compensation step in order. Each compensation step references an Operation -- find it in the contract, execute it via `execute_operation()`.
3. Record each compensation step in `steps_executed` with `step_type: "compensation"`.
4. If a compensation step itself fails, check its `on_failure` field:
   - `Terminal { outcome }`: return FlowResult with that outcome
   - `StepRef(ref)`: break out of compensation loop and continue flow from that step
5. If all compensation steps succeed, route to `then`:
   - `Terminal { outcome }`: return FlowResult with that outcome
   - `StepRef(next_id)`: continue flow from next_id

See RESEARCH.md "Fix 4" for the implementation pattern.

**F3 - Escalate failure handler (flow.rs ~lines 199-206):**
Replace the `TypeError` with escalation handling per spec Section 11.3:

1. When a step fails and the failure handler is `FailureHandler::Escalate { to_persona, next }`:
2. Record the escalation in `steps_executed` with `step_type: "escalation"` and result showing the persona transfer.
3. Set `current_step_id = next.clone()` to continue the flow from the next step.
4. The escalation is a provenance event -- the persona executing subsequent steps changes to `to_persona`.

See RESEARCH.md "Fix 5" for the pattern.

**F4 - SubFlowStep Compensate/Escalate (flow.rs ~lines 306-316):**
The SubFlowStep also has `on_failure` handlers that currently use a wildcard `_ =>` returning TypeError. Apply the same Compensate and Escalate logic from F2/F3 to the SubFlowStep's failure handling arms. Factor out a shared helper if the code would otherwise be duplicated.

**F5 - Persona provenance (lib.rs ~line 75):**
Change `_persona` to `persona` in `evaluate_flow`. Store it in the `FlowResult` (add an `initiating_persona: Option<String>` field to `FlowResult` if not already present, or record it in the steps_executed). Add a comment: `// Per spec Section 11.4: initiating_persona is recorded for provenance. Flow-level persona authorization is delegated to step-level Operation persona checks.`

This is NOT an authorization gate -- the spec does not define `allowed_personas` on Flow constructs. Persona auth happens per-step via Operation `allowed_personas`, which is already implemented.
  </action>
  <verify>
Run `cargo build --workspace` -- no warnings or errors. Run `cargo test --workspace` -- all existing tests still pass. The previously-failing ParallelStep, Compensate, and Escalate code paths now execute instead of returning TypeError. Check that flow.rs has no remaining `TypeError` variants for not-implemented features (all E2-E5 from the research inventory should be resolved).
  </verify>
  <done>
ParallelStep executes branches with isolated entity state clones and merges on join. Compensate handler executes compensation steps and routes to then-target. Escalate handler records persona transfer and routes to next step. SubFlowStep handlers use the same logic. Flow initiating_persona recorded for provenance. No "not yet implemented" TypeError paths remain in flow.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conformance test fixtures for new flow features</name>
  <files>
    conformance/eval/positive/parallel_step.tenor
    conformance/eval/positive/parallel_step.facts.json
    conformance/eval/positive/parallel_step.verdicts.json
    conformance/eval/positive/compensate_handler.tenor
    conformance/eval/positive/compensate_handler.facts.json
    conformance/eval/positive/compensate_handler.verdicts.json
    conformance/eval/positive/escalate_handler.tenor
    conformance/eval/positive/escalate_handler.facts.json
    conformance/eval/positive/escalate_handler.verdicts.json
  </files>
  <action>
Create conformance test fixtures for each new flow feature. Follow the existing eval conformance triplet convention: .tenor source + .facts.json + .verdicts.json.

**C4 - ParallelStep test fixture:**
Create a contract with:
- Two entities (e.g., `OrderFulfillment` and `PaymentProcessing`), each with 2-3 states
- Two Operations, one affecting each entity (non-overlapping entity effects per spec constraint)
- A Flow with a ParallelStep containing two branches, one executing each Operation
- Join policy: `on_all_success` routes to a terminal outcome
- Facts that make both Operations succeed
- Expected verdicts from rule evaluation, plus flow_outcome showing the join succeeded
- Steps_executed should show both branches executed

**C5 - Compensate handler test fixture:**
Create a contract with:
- An entity with states [pending, active, failed, rolled_back]
- An Operation that transitions pending->active (can succeed or fail based on precondition)
- A compensation Operation that transitions active->rolled_back
- A Flow where step 1 is the main operation with `on_failure: compensate { steps: [compensation_op], then: terminal("rolled_back") }`
- Facts that cause the main operation to FAIL (precondition not met)
- Expected: flow triggers compensation, routes to terminal "rolled_back"
- Steps_executed should show main op failure + compensation step + terminal

**C6 - Escalate handler test fixture:**
Create a contract with:
- A persona "agent" and a persona "supervisor"
- An Operation with `allowed_personas: [agent, supervisor]`
- A Flow where step 1 (as agent) has `on_failure: escalate { to: supervisor, next: step2 }`, and step 2 executes the same operation as supervisor
- Facts that cause step 1 to fail
- Expected: flow escalates to supervisor, continues from step 2
- Steps_executed should show step1 failure + escalation event + step2 execution

For each fixture:
1. Write the .tenor source file following DSL conventions (lowercase keywords)
2. Elaborate it: `cargo run -p tenor-cli -- elaborate <file>.tenor > /dev/null` to verify it elaborates
3. Create the .facts.json with appropriate fact values
4. Run the eval to generate the .verdicts.json: `cargo run -p tenor-cli -- eval <elaborated-bundle> --facts <facts.json>`
5. If the eval produces the expected output, save it as the .verdicts.json
6. If the eval output differs from expectation, investigate and fix

Note: The eval conformance runner discovers fixtures in `conformance/eval/positive/` automatically -- no runner changes needed.
  </action>
  <verify>
Run the eval conformance suite: `cargo test -p tenor-eval` -- all existing + new tests pass. Verify that each new fixture triplet exists and the conformance runner picks them up. The new tests should cover: ParallelStep (C4), Compensate (C5), Escalate (C6). Run `cargo run -p tenor-cli -- test conformance` to verify elaborator conformance is unaffected (still 55/55).
  </verify>
  <done>
Three new eval conformance test fixtures exist: parallel_step, compensate_handler, escalate_handler. Each exercises the newly-implemented flow feature and verifies correct output. Test coverage gaps C4, C5, C6 from the research inventory are closed. Elaborator conformance (55/55) unaffected.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds with no new warnings
2. `cargo test --workspace` passes all existing + new tests
3. `cargo run -p tenor-cli -- test conformance` still reports 55/55 passing
4. No `TypeError("not yet implemented")` or `TypeError("parallel step")` strings remain in flow.rs
5. `evaluate_flow` records initiating_persona in FlowResult
6. At least 3 new eval conformance fixtures exist in conformance/eval/positive/
7. ParallelStep, Compensate, Escalate all execute without error on well-formed contracts
</verification>

<success_criteria>
- ParallelStep, Compensate, and Escalate fully functional in evaluator
- Flow-level persona recorded for provenance (not authorization gating, per spec)
- All new features have conformance test coverage
- No remaining "not yet implemented" stubs in flow.rs
- All existing 55 elaborator conformance tests still pass
- All existing eval tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-technical-debt-bug-fixes-missing-eval-features/03.2-03-SUMMARY.md`
</output>
