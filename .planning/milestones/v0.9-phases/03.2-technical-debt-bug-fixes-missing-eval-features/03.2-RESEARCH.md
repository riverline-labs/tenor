# Phase 03.2: Technical Debt, Bug Fixes & Missing Eval Features - Research

**Researched:** 2026-02-21
**Domain:** Rust evaluator correctness, flow execution completeness, code quality
**Confidence:** HIGH

## Summary

Phase 03.2 addresses a concrete set of bugs, missing features, and tech debt items identified through a codebase concerns audit. The work falls into four categories: (1) critical bugs that cause panics or silent incorrect behavior, (2) unimplemented evaluator features (ParallelStep execution, Compensate/Escalate failure handlers), (3) semantic corrections to error types and flow persona handling, and (4) code quality improvements (unwrap elimination, string-match retry logic, dead code cleanup, workspace dependency normalization).

All issues are internal to the existing Rust codebase -- no new external dependencies, no architectural changes, no spec modifications. The evaluator crate (`tenor-eval`) is the primary target, with smaller fixes in `tenor-core` and `tenor-cli`. The existing test infrastructure (unit tests + conformance suite) provides a strong regression safety net: 55/55 conformance tests and all workspace unit tests currently pass.

**Primary recommendation:** Fix critical bugs first (precision overflow panic, Money currency gap, multi-outcome fallback), then implement missing features (ParallelStep, Compensate, Escalate), then clean up tech debt. Each fix must include test coverage.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| TEST-03 | Static analyzer test suite covering each S1-S7 analysis with known-good and known-bad contracts | This phase prepares the evaluator for Phase 4 (Static Analysis) by ensuring the evaluator itself is correct. TEST-03 is formally a Phase 4 requirement, but Phase 03.2 contributes by closing coverage gaps and ensuring the evaluator foundation is solid before S1-S7 analyses are built on top of it. |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| rust_decimal | 1.36 | Fixed-point decimal arithmetic | Already in workspace deps; all eval numeric paths use it |
| serde_json | 1 | JSON interchange deserialization | Already in workspace deps; contract parsing uses it |
| serde | 1 | Serialization framework | Already in workspace deps |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| clap | 4.5 | CLI argument parsing | Already in workspace; no changes needed |

### Alternatives Considered
No new libraries needed. All work uses existing workspace dependencies.

## Architecture Patterns

### Recommended Project Structure

No structural changes. All modifications are within existing files:

```
crates/
  eval/src/
    numeric.rs        # Fix precision overflow panic, Duration comparison, Money currency validation
    flow.rs           # Implement ParallelStep, Compensate, Escalate; fix TypeError usage
    operation.rs      # Fix multi-outcome fallback silent bug
    types.rs          # Add new EvalError variants (FlowError, StepLimitExceeded, etc.)
    assemble.rs       # Add Date/Duration format validation
    lib.rs            # Wire initiating_persona parameter
  core/src/
    parser.rs         # Fix unwrap on parse
    pass3_types.rs    # Audit unwraps (some are justified invariants)
    pass5_validate.rs # Audit unwraps
  cli/src/
    ambiguity/api.rs  # Replace string-match retry with status code enum
    ambiguity/mod.rs  # Remove dead_code annotations or justify
```

### Pattern 1: Error Variant Granularity

**What:** Replace `EvalError::TypeError` catch-all with semantically precise error variants.
**When to use:** Any error site currently using `TypeError` for non-type errors.

Currently `TypeError` is used for:
- Flow step limit exceeded (should be `StepLimitExceeded` or `FlowError`)
- ParallelStep not implemented (should be `NotImplemented` or specific error)
- Compensate/Escalate not implemented (should be `NotImplemented`)
- Forall domain not a list (is a genuine TypeError, keep)
- Multiplication on non-numeric (is a genuine TypeError, keep)

**Example:**
```rust
// BEFORE (semantically wrong)
return Err(EvalError::TypeError {
    message: format!("flow '{}' exceeded maximum step count ({})", flow.id, max_steps),
});

// AFTER (semantically correct)
return Err(EvalError::FlowError {
    flow_id: flow.id.clone(),
    message: format!("exceeded maximum step count ({})", max_steps),
});
```

### Pattern 2: Checked Arithmetic for Precision Bounds

**What:** Replace `10i64.pow(n)` with `Decimal::TEN.checked_pow()` or `i64::checked_pow()` to prevent panics.
**When to use:** Any place computing `10^n` where `n` could exceed 18 for i64.

**Example:**
```rust
// BEFORE (panics when max_int_digits > 18)
let max_val = Decimal::from(10i64.pow(max_int_digits)) - Decimal::ONE;

// AFTER (handles large precision safely)
let max_val = Decimal::TEN
    .checked_powi(max_int_digits as i64)
    .ok_or_else(|| EvalError::Overflow {
        message: format!("precision {} exceeds representable range", precision),
    })?
    - Decimal::ONE;
```

### Pattern 3: ParallelStep Execution with Isolated Entity States

**What:** Execute each branch with a clone of entity states, then merge on join.
**When to use:** ParallelStep execution in flow.rs.

Per spec Section 11.5:
- All branches execute under the parent Flow's frozen snapshot
- No branch sees entity state changes from another branch
- No two branches may have overlapping entity effect sets (enforced at elaboration)
- All branches run to completion before join evaluates

**Example:**
```rust
FlowStep::ParallelStep { id, branches, join } => {
    let mut branch_outcomes = Vec::new();
    let mut all_entity_changes = Vec::new();

    for branch in branches {
        // Each branch gets its OWN clone of entity states
        let mut branch_entity_states = entity_states.clone();

        // Build branch-local step index and execute
        let branch_flow = Flow {
            id: format!("{}:{}", flow.id, branch.id),
            snapshot: flow.snapshot.clone(),
            entry: branch.entry.clone(),
            steps: branch.steps.clone(),
        };

        match execute_flow(&branch_flow, contract, snapshot, &mut branch_entity_states) {
            Ok(result) => {
                // Merge entity state changes back (non-overlapping guaranteed by spec)
                all_entity_changes.extend(result.entity_state_changes);
                branch_outcomes.push((branch.id.clone(), result.outcome));
            }
            Err(e) => {
                branch_outcomes.push((branch.id.clone(), format!("error: {}", e)));
            }
        }
    }

    // Apply non-overlapping entity changes to parent state
    for change in &all_entity_changes {
        entity_states.insert(change.entity_id.clone(), change.to_state.clone());
    }

    // Evaluate join policy
    let all_success = branch_outcomes.iter().all(|(_, o)| !o.starts_with("error:"));
    let any_failure = branch_outcomes.iter().any(|(_, o)| o.starts_with("error:"));

    if all_success {
        if let Some(ref target) = join.on_all_success { /* route */ }
    } else if any_failure {
        if let Some(ref handler) = join.on_any_failure { /* handle */ }
    }
    if let Some(ref target) = join.on_all_complete { /* route */ }
}
```

### Anti-Patterns to Avoid
- **Catch-all error variants:** `TypeError` being used for non-type errors loses semantic information. Use specific variants.
- **String-based error classification:** `is_retryable()` matching on substrings of error messages is fragile. Use structured error types or HTTP status codes.
- **Silent fallbacks:** `op.outcomes[0].clone()` when there's no effect-to-outcome mapping hides a contract authoring error. Return an error instead.
- **Panic-inducing arithmetic:** `10i64.pow(n)` where n is user-controlled (from contract precision declarations). Always use checked operations.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Fixed-point arithmetic | Custom decimal math | `rust_decimal::Decimal` | Already in use; handles precision, rounding, overflow correctly |
| Date/DateTime parsing | Custom date parser | String format validation (regex or simple check) | Only need to validate ISO 8601 format, not full date library |
| HTTP status code matching | String substring search | Parse status code from ureq error type | ureq provides structured error info |

**Key insight:** This phase is about fixing existing code, not building new infrastructure. Every fix should be minimal and targeted.

## Common Pitfalls

### Pitfall 1: Precision Overflow Panic
**What goes wrong:** `10i64.pow(max_int_digits)` panics when `max_int_digits > 18` because `10^19 > i64::MAX`. The default precision fallback in `predicate.rs:189` is `unwrap_or(28)`, meaning a decimal multiplication without explicit precision will compute `check_precision(val, 28, 0)`, triggering `10i64.pow(28)` -- instant panic.
**Why it happens:** `i64::pow()` is not a checked operation in Rust; it wraps or panics on overflow.
**How to avoid:** Use `Decimal::TEN.checked_powi()` or `i64::checked_pow(10, n).ok_or(...)`.
**Warning signs:** Any arithmetic on `precision - scale` passed to `pow()`.

### Pitfall 2: Money Currency Comparison Gap
**What goes wrong:** When `compare_with_promotion` handles Money comparison_type, it calls `coerce_to_money_amount()` which extracts the `amount` field but discards the `currency`. Two Money values with different currencies compare as equal if amounts match.
**Why it happens:** The promotion path assumes comparison_type already constrains currency, but doesn't validate it.
**How to avoid:** Add currency validation in `compare_with_promotion` for the Money case, OR in `coerce_to_money_amount`, return `(amount, currency)` and validate match.
**Warning signs:** Money comparisons returning `true` when currencies differ.

### Pitfall 3: Multi-Outcome Routing Silently Defaults
**What goes wrong:** In `operation.rs:210-212`, when an Operation has multiple declared outcomes but no effect carries an `outcome` field, execution silently falls back to `outcomes[0]`. Per spec, multi-outcome Operations REQUIRE explicit effect-to-outcome association.
**Why it happens:** The outcome determination logic has a fallback chain that doesn't distinguish "single outcome" from "multi-outcome without mapping."
**How to avoid:** For multi-outcome Operations (len > 1), if no effect carries an outcome, return an error.
**Warning signs:** Operations with multiple outcomes always routing to the first one.

### Pitfall 4: Entity State Merge in ParallelStep
**What goes wrong:** When implementing ParallelStep, naively sharing `entity_states` across branches lets one branch's state changes affect another's execution.
**Why it happens:** Rust's borrow rules would actually prevent this at compile time, but the temptation is to execute branches sequentially with shared state.
**How to avoid:** Clone `entity_states` for each branch. Merge back after all branches complete. The spec guarantees non-overlapping entity effect sets (validated at elaboration), so merge is safe.
**Warning signs:** Branch execution order affecting results.

### Pitfall 5: EvalError Variant Changes Breaking Callers
**What goes wrong:** Changing EvalError variants (e.g., removing TypeError, adding FlowError) breaks existing match arms in flow.rs, operation.rs, and test code.
**Why it happens:** EvalError is used across multiple modules. Changes require updating all match sites.
**How to avoid:** Add new variants first, migrate callers, then consider deprecating (not removing) old variants. Since this is internal code (not a public API beyond tenor-eval), a clean rename is acceptable within a single phase.
**Warning signs:** Compiler errors on exhaustive matches after adding variants.

### Pitfall 6: ParallelStep Branch Outcome Classification
**What goes wrong:** The join policy needs to distinguish "success" outcomes from "failure" outcomes for `on_all_success` vs `on_any_failure` routing. The current code uses string matching (`starts_with("error:")`), which is fragile.
**Why it happens:** Branch outcomes are represented as strings, not typed enums.
**How to avoid:** Use a `BranchOutcome` enum (Success(String), Failure(String)) to cleanly classify branch results for join evaluation.
**Warning signs:** Join routing giving wrong results when outcome labels happen to contain "error".

## Code Examples

### Fix 1: Precision Overflow (numeric.rs:83)

```rust
// BEFORE (panics when max_int_digits > 18):
let max_val = Decimal::from(10i64.pow(max_int_digits)) - Decimal::ONE;

// AFTER (safe for any precision):
fn check_precision(val: Decimal, precision: u32, scale: u32) -> Result<(), EvalError> {
    if precision <= scale {
        let int_part = val.trunc().abs();
        if int_part > Decimal::ZERO {
            return Err(EvalError::Overflow {
                message: format!(
                    "result {} exceeds declared precision({}, {})",
                    val, precision, scale
                ),
            });
        }
        return Ok(());
    }
    let max_int_digits = precision - scale;
    let int_part = val.trunc().abs();
    // Use Decimal arithmetic to avoid i64 overflow
    let max_val = if max_int_digits > 28 {
        // rust_decimal supports up to 28 significant digits
        // Any value that fits in Decimal is valid at this precision
        return Ok(());
    } else {
        // Safe: max_int_digits <= 28, Decimal can represent 10^28
        let mut bound = Decimal::ONE;
        for _ in 0..max_int_digits {
            bound = bound.checked_mul(Decimal::TEN).ok_or_else(|| EvalError::Overflow {
                message: format!("precision bound computation overflow for precision({}, {})", precision, scale),
            })?;
        }
        bound - Decimal::ONE
    };
    if int_part > max_val {
        return Err(EvalError::Overflow {
            message: format!(
                "result {} exceeds declared precision({}, {})",
                val, precision, scale
            ),
        });
    }
    Ok(())
}
```

### Fix 2: Money Currency Validation in Promoted Comparison (numeric.rs)

```rust
// BEFORE:
"Money" => {
    let l = coerce_to_money_amount(left)?;
    let r = coerce_to_money_amount(right)?;
    compare_decimals(l, r, op)
}

// AFTER:
"Money" => {
    let (l_amount, l_currency) = coerce_to_money(left)?;
    let (r_amount, r_currency) = coerce_to_money(right)?;
    if l_currency != r_currency {
        return Err(EvalError::TypeError {
            message: format!(
                "cannot compare Money with different currencies: {} vs {}",
                l_currency, r_currency
            ),
        });
    }
    compare_decimals(l_amount, r_amount, op)
}

fn coerce_to_money(val: &Value) -> Result<(Decimal, &str), EvalError> {
    match val {
        Value::Money { amount, currency } => Ok((*amount, currency.as_str())),
        _ => Err(EvalError::TypeError {
            message: format!("cannot coerce {} to Money", val.type_name()),
        }),
    }
}
```

### Fix 3: Multi-Outcome Routing Error (operation.rs)

```rust
// BEFORE:
let outcome = if let Some(effect_outcome) = outcome_from_effects {
    effect_outcome
} else if op.outcomes.len() == 1 {
    op.outcomes[0].clone()
} else if !op.outcomes.is_empty() {
    op.outcomes[0].clone()  // BUG: silent fallback for multi-outcome
} else {
    "success".to_string()
};

// AFTER:
let outcome = if let Some(effect_outcome) = outcome_from_effects {
    effect_outcome
} else if op.outcomes.len() == 1 {
    op.outcomes[0].clone()
} else if op.outcomes.len() > 1 {
    // Multi-outcome operations REQUIRE effect-to-outcome mapping
    return Err(OperationError::PreconditionFailed {
        operation_id: op.id.clone(),
        condition_desc: "multi-outcome operation has no effect-to-outcome mapping".to_string(),
    });
} else {
    "success".to_string()
};
```

### Fix 4: Compensate Handler Execution (flow.rs)

```rust
FailureHandler::Compensate { steps, then } => {
    // Execute compensation steps in order
    for comp_step in steps {
        let comp_op = contract
            .operations
            .iter()
            .find(|o| o.id == comp_step.op)
            .ok_or_else(|| EvalError::DeserializeError {
                message: format!("compensation operation '{}' not found", comp_step.op),
            })?;

        match execute_operation(comp_op, &comp_step.persona, &snapshot.facts, &snapshot.verdicts, entity_states) {
            Ok(comp_result) => {
                entity_changes_all.extend(comp_result.effects_applied.clone());
                steps_executed.push(StepRecord {
                    step_id: format!("comp:{}", comp_step.op),
                    step_type: "compensation".to_string(),
                    result: comp_result.outcome.clone(),
                });
            }
            Err(comp_err) => {
                // Compensation step failed -- route per comp_step.on_failure (Terminal only)
                steps_executed.push(StepRecord {
                    step_id: format!("comp:{}", comp_step.op),
                    step_type: "compensation".to_string(),
                    result: format!("error: {}", comp_err),
                });
                match &comp_step.on_failure {
                    StepTarget::Terminal { outcome } => {
                        return Ok(FlowResult {
                            outcome: outcome.clone(),
                            steps_executed,
                            entity_state_changes: entity_changes_all,
                        });
                    }
                    StepTarget::StepRef(step_ref) => {
                        current_step_id = step_ref.clone();
                        // Break out of compensation loop and continue flow
                        break;
                    }
                }
            }
        }
    }
    // All compensation succeeded -- route to `then`
    match then {
        StepTarget::Terminal { outcome } => {
            return Ok(FlowResult {
                outcome: outcome.clone(),
                steps_executed,
                entity_state_changes: entity_changes_all,
            });
        }
        StepTarget::StepRef(next_id) => {
            current_step_id = next_id.clone();
        }
    }
}
```

### Fix 5: Escalate Handler Execution (flow.rs)

```rust
FailureHandler::Escalate { to_persona, next } => {
    // Escalation is a persona transfer on failure -- record handoff and continue
    steps_executed.push(StepRecord {
        step_id: id.clone(),
        step_type: "escalation".to_string(),
        result: format!("escalated to {}", to_persona),
    });
    current_step_id = next.clone();
}
```

### Fix 6: String-Match Retry Replacement (ambiguity/api.rs)

```rust
// BEFORE: fragile string matching
fn is_retryable(error: &str) -> bool {
    error.contains("429") || error.contains("rate limit") || ...
}

// AFTER: structured error classification
// ureq v3 provides structured errors. Check for ureq::Error type
// or parse HTTP status codes from the error message using a status code prefix
fn is_retryable(error: &str) -> bool {
    // Match on "status: NNN" pattern from ureq error formatting
    if let Some(status) = extract_http_status(error) {
        matches!(status, 429 | 500 | 502 | 503)
    } else {
        // Network-level errors (connection reset, timeout) are retryable
        error.contains("connection") || error.contains("timeout")
    }
}

fn extract_http_status(error: &str) -> Option<u16> {
    // ureq formats errors as "http status: NNN" or similar
    // Extract the 3-digit status code
    error
        .find("status")
        .and_then(|pos| {
            error[pos..].split_whitespace()
                .find_map(|word| word.parse::<u16>().ok())
                .filter(|&code| (100..600).contains(&code))
        })
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `i64::pow()` for precision bounds | `Decimal` checked arithmetic | This phase | Eliminates panic on valid contracts with precision > 18 |
| `EvalError::TypeError` catch-all | Semantically specific error variants | This phase | Better error messages and error handling for callers |
| String-match retry classification | Structured HTTP status check | This phase | More robust retry behavior, fewer false retries |

## Open Questions

1. **Flow-level persona authorization semantics**
   - What we know: The spec defines `execute_flow : Flow x PersonaId x Snapshot -> FlowOutcome` with an `initiating_persona` parameter. The current evaluator accepts but ignores this parameter (`_persona`). The spec does not define `allowed_personas` on Flow constructs -- persona auth is per-step via Operation `allowed_personas`.
   - What's unclear: Should the evaluator validate the `initiating_persona` against something? The spec doesn't define a Flow-level `allowed_personas` set. The step-level `persona` fields are declarative (they say *who* executes each step), not authorization checks.
   - Recommendation: Document that flow-level persona authorization is delegated to step-level Operation persona checks (which are already implemented). The `_persona` parameter in `evaluate_flow` should be stored in the FlowResult for provenance, but not used for authorization gating. Add a comment explaining this design decision per the spec.

2. **Date format validation depth**
   - What we know: Dates are stored as strings and compared lexicographically. The spec says `Date` values are ISO 8601 format, which lexicographic comparison works correctly for (`"2024-01-15" < "2024-02-01"` is correct).
   - What's unclear: Should the evaluator validate incoming date strings conform to ISO 8601? Currently, any string is accepted.
   - Recommendation: Add a basic ISO 8601 format check (YYYY-MM-DD pattern) during fact assembly. This prevents silent incorrect comparisons from malformed date strings without requiring a full date parsing library.

3. **Duration comparison semantics**
   - What we know: The spec defines Duration comparisons with unit promotion rules (ยง4). The evaluator currently has no Duration comparison path -- it would fall through to a type error.
   - What's unclear: Whether Phase 03.2 should implement full Duration arithmetic with unit promotion, or just same-unit comparison.
   - Recommendation: Implement same-unit Duration comparison (error on cross-unit) for Phase 03.2. Full unit promotion is better handled in the context of spec-driven domain validation (Phase 5) where real contracts exercise these paths.

4. **Unwraps in tenor-core**
   - What we know: 13 `unwrap()` calls in core's non-test code. Several are in positions where the program state guarantees they won't fail (e.g., `in_stack.iter().position(|x| x == name).unwrap()` after just detecting `name` is in `in_stack`).
   - What's unclear: Which are genuinely safe invariant assertions vs which could fail on unexpected input.
   - Recommendation: Audit each, add `// SAFETY: <invariant>` comments for justified ones, replace with proper error handling for unjustified ones. The `parser.rs:125` unwrap (`w.parse().unwrap()`) is most concerning since it depends on lexer output.

## Sources

### Primary (HIGH confidence)
- Codebase source code audit (all files read directly)
- `docs/TENOR.md` spec sections: 4 (BaseType), 8 (Persona), 9 (Operation), 11 (Flow), 11.2 (Step Types), 11.3 (Failure Handling), 11.4 (Evaluation), 11.5 (Constraints)
- Existing test suites: 55/55 conformance, all workspace unit tests passing

### Secondary (MEDIUM confidence)
- `rust_decimal` crate documentation for `checked_powi` and precision capabilities
- Phase description and success criteria from ROADMAP.md

## Metadata

**Confidence breakdown:**
- Critical bugs (precision panic, Money currency, multi-outcome): HIGH -- confirmed by direct code reading
- Missing features (ParallelStep, Compensate, Escalate): HIGH -- spec is explicit, code has `// not yet implemented` stubs
- Tech debt (unwrap, retry, dead code): HIGH -- confirmed by grep across codebase
- Flow persona auth semantics: MEDIUM -- spec is not fully explicit about flow-level auth
- Duration/Date validation: MEDIUM -- correct behavior clear from spec, implementation gap confirmed

**Research date:** 2026-02-21
**Valid until:** 2026-03-21 (stable domain, internal codebase)

---

## Bug & Tech Debt Inventory

The following is the complete inventory of issues to address, organized by severity.

### Critical Bugs (Panics / Silent Incorrect Behavior)

| # | File | Line | Issue | Severity |
|---|------|------|-------|----------|
| B1 | `eval/src/numeric.rs` | 83 | `10i64.pow(max_int_digits)` panics when `precision - scale > 18`. Default precision fallback of 28 in `predicate.rs:189` guarantees this path is reachable. | PANIC |
| B2 | `eval/src/numeric.rs` | 163-165 | `compare_with_promotion` for Money discards currency -- compares amounts across currencies silently. | SILENT WRONG |
| B3 | `eval/src/operation.rs` | 210-212 | Multi-outcome Operations without effect-to-outcome mapping silently default to first outcome. Should be an error. | SILENT WRONG |
| B4 | `eval/src/numeric.rs` | 137-138 | Date/DateTime comparison uses raw string comparison. Non-ISO-8601 formatted strings compare incorrectly. | SILENT WRONG (data-dependent) |

### Missing Features (Stub / Not Implemented)

| # | File | Line | Feature | Spec Reference |
|---|------|------|---------|----------------|
| F1 | `eval/src/flow.rs` | 335-339 | ParallelStep execution returns `TypeError("not yet implemented")` | Spec 11.2 |
| F2 | `eval/src/flow.rs` | 189-198 | Compensate failure handler returns `TypeError` instead of executing compensation steps | Spec 11.3 |
| F3 | `eval/src/flow.rs` | 199-206 | Escalate failure handler returns `TypeError` instead of performing escalation handoff | Spec 11.3 |
| F4 | `eval/src/flow.rs` | 306-316 | SubFlowStep Compensate/Escalate handlers use wildcard `_ =>` returning `TypeError` | Spec 11.3 |
| F5 | `eval/src/lib.rs` | 75 | `_persona` parameter in `evaluate_flow` is ignored -- no provenance recording of initiating persona | Spec 11.4 |

### EvalError Semantic Misuse

| # | File | Line | Current Error | Should Be |
|---|------|------|---------------|-----------|
| E1 | `eval/src/flow.rs` | 100-105 | `TypeError` for flow step limit exceeded | `FlowError { flow_id, message }` or dedicated `StepLimitExceeded` |
| E2 | `eval/src/flow.rs` | 192-198 | `TypeError` for Compensate not implemented | (will be removed when F2 implemented) |
| E3 | `eval/src/flow.rs` | 200-206 | `TypeError` for Escalate not implemented | (will be removed when F3 implemented) |
| E4 | `eval/src/flow.rs` | 308-316 | `TypeError` for SubFlow Compensate/Escalate | (will be removed when F4 implemented) |
| E5 | `eval/src/flow.rs` | 337-339 | `TypeError` for ParallelStep not implemented | (will be removed when F1 implemented) |

### Tech Debt

| # | Category | Location | Issue |
|---|----------|----------|-------|
| T1 | Unwrap fragility | `core/src/parser.rs:125` | `w.parse().unwrap()` -- depends on lexer producing valid integers |
| T2 | Unwrap fragility | `core/src/pass3_types.rs:46,50,51,52,79,113` | Several `.unwrap()` calls -- most are justified invariants but need `// SAFETY:` annotations |
| T3 | Unwrap fragility | `core/src/pass4_typecheck.rs:176-177` | `products.iter().min().unwrap()` and `.max().unwrap()` -- products could be empty |
| T4 | Unwrap fragility | `core/src/pass5_validate.rs:623,734,851,861` | Multiple `.unwrap()` in validation logic |
| T5 | String-match retry | `cli/src/ambiguity/api.rs:162-171` | `is_retryable()` uses substring matching on error messages to detect HTTP status codes |
| T6 | Dead code | `cli/src/ambiguity/*.rs` | 6 `#[allow(dead_code)]` annotations across api.rs, compare.rs, report.rs, mod.rs |
| T7 | Workspace dep drift | `cli/Cargo.toml:15` | `jsonschema = "0.42"` duplicated (also in `core/Cargo.toml:12`) -- should be workspace dependency |
| T8 | Duration validation | `eval/src/assemble.rs` | No Duration unit validation against spec DurationUnit enum (seconds, minutes, hours, days) |
| T9 | Duration comparison | `eval/src/numeric.rs` | No Duration comparison support in `compare_values()` |

### Test Coverage Gaps

| # | Area | Missing Coverage |
|---|------|-----------------|
| C1 | Precision overflow | No test for `precision > 18` (would panic) |
| C2 | Money cross-currency promotion | No test for Money comparison via comparison_type with different currencies |
| C3 | Multi-outcome fallback | No test for multi-outcome Operation with missing effect-to-outcome mapping |
| C4 | ParallelStep | No tests (returns error immediately) |
| C5 | Compensate handler | No execution tests (returns error immediately) |
| C6 | Escalate handler | No execution tests (returns error immediately) |
| C7 | Duration comparison | No tests for Duration value comparison |
| C8 | Date format validation | No tests for malformed date strings |
| C9 | Flow step limit | Test exists implicitly but uses wrong error variant |
