---
phase: 03.1-cffp-migration-semantics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/cffp/migration-semantics.json
autonomous: true
requirements:
  - MIGR-02

must_haves:
  truths:
    - "A CFFP JSON artifact exists at docs/cffp/migration-semantics.json that validates against docs/cffp.cue schema structure"
    - "The CFFP run resolves the diff representation question (Candidate A/B/C) with the consensus favoring Tenor contract output per user directive"
    - "Every construct kind (Fact, Entity, Rule, Persona, Operation, Flow) has its fields systematically classified as breaking or non-breaking for each change type (add/remove/change)"
    - "All seven pressure test questions from CONTEXT.md are addressed in Phase 3 counterexamples"
    - "The breaking change taxonomy is exhaustive — every (construct kind, field, change type) triple has a classification"
  artifacts:
    - path: "docs/cffp/migration-semantics.json"
      provides: "Complete CFFP run artifact for migration semantics"
      contains: "phase1"
  key_links:
    - from: "docs/cffp/migration-semantics.json"
      to: "docs/cffp.cue"
      via: "Schema conformance"
      pattern: "protocol.*version.*0\\.2\\.1"
---

<objective>
Execute a full CFFP run for migration semantics — resolving the diff representation question (Candidate A/B/C) and producing the breaking change taxonomy that classifies every construct-level change as breaking or non-breaking.

Purpose: MIGR-02 requires a CFFP-derived classification of what constitutes breaking vs non-breaking contract changes. This taxonomy is the formal foundation for Phase 4's `tenor diff --breaking` implementation. The CFFP run must also resolve whether Tenor diffs should be expressed as Tenor contracts (per user directive: favor Candidate B or C).

Output: `docs/cffp/migration-semantics.json` — a complete CFFP instance following the `docs/cffp.cue` schema structure.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-cffp-migration-semantics/CONTEXT.md
@.planning/phases/03.1-cffp-migration-semantics/03.1-RESEARCH.md
@docs/cffp.cue
@docs/cffp/persona.json
@docs/interchange-schema.json
@docs/TENOR.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execute CFFP Phases 1-3 (Invariants, Candidates, Pressure Testing)</name>
  <files>docs/cffp/migration-semantics.json</files>
  <action>
Create `docs/cffp/migration-semantics.json` following the exact structure of `docs/cffp.cue` (CFFPInstance schema). Use `docs/cffp/persona.json` as the format exemplar — match the same JSON structure, field names, and conventions.

**Construct definition:**
```json
{
  "name": "Migration Semantics",
  "description": "Breaking change taxonomy and diff representation for contract version transitions. Classifies every construct-level change as breaking or non-breaking, and determines whether the migration output is expressed as a Tenor contract, JSON interchange diff, or hybrid.",
  "depends_on": ["Fact", "Entity", "Rule", "Persona", "Operation", "Flow", "TypeDecl"]
}
```

**Phase 1 — Invariant Declaration:**
Declare the following invariants (refined from RESEARCH.md section "CFFP Invariant Candidates"):
- MI1 — Diff completeness: diff representation captures every semantic change between two contract versions
- MI2 — Diff determinism: same two contracts produce identical diff regardless of elaborator
- MI3 — Classification decidability: breaking/non-breaking classification is decidable at static analysis time
- MI4 — Taxonomy exhaustiveness: every (construct kind, field, change type) triple has a classification
- MI5 — Policy declaration mandatory: executor deploying breaking changes MUST declare in-flight flow migration policy
- MI6 — Policy does not affect contract semantics: migration policy is executor concern only
- MI7 — Policy completeness: declared policy addresses all in-flight flows

Each invariant must have `testable: true`, `structural: true`, and an appropriate `class` field.

**Phase 2 — Candidate Formalisms:**
Define three candidates per CONTEXT.md:

*Candidate A (Interchange Diff):* Output is structured JSON describing structural changes (current `diff.rs` approach). Formalism: diff is a list of `DiffEntry = {kind, id, change_type, fields}` where `change_type` is `added | removed | changed`. Claims satisfaction of MI1-MI4 straightforwardly. Does NOT claim MI5-MI7 (those are spec prose obligations, not diff representation concerns). Failure modes: no composability, no self-reference, cannot validate migration correctness.

*Candidate B (Migration as Tenor Contract):* Output is a `.tenor` file using the DSL's own constructs to describe the transformation. Formalism: migration is a Tenor contract where Facts represent before/after state, Entities represent construct lifecycle, Rules classify changes, Operations describe migration steps, Flows sequence multi-step migrations. Claims MI1-MI4 by reduction to the evaluator. Failure modes: may require new constructs violating v1.0 freeze, circular dependency risk, evaluator may not be expressive enough for meta-level descriptions.

*Candidate C (Hybrid):* Structural diff for raw output (`tenor diff`), migration contract generation for `tenor diff --migration`. Both representations, different use cases. Formalism: `tenor diff` produces DiffEntry JSON (Candidate A's structure); `tenor diff --migration` generates a `.tenor` contract that expresses the migration using Tenor constructs. The migration contract is a valid Tenor contract consumable by the evaluator. Claims MI1-MI4 via the DiffEntry arm; adds composability/validatability via the contract arm.

Each candidate needs explicit claims with proof sketches, complexity analysis, and failure modes per `cffp.cue` schema.

**Phase 3 — Pressure Testing:**
Generate counterexamples targeting each candidate. The seven pressure test questions from CONTEXT.md MUST each appear as counterexamples or be addressed:

1. Can every construct change type be naturally expressed in Tenor's existing constructs? (targets B)
2. What new constructs would be needed? Does this violate v1.0 freeze? (targets B)
3. Is there a clean mapping from diff-of-contracts to contract-describing-diff? (targets B)
4. Can migration contracts reference the contracts they migrate? Import semantics? (targets B)
5. Does this create circular dependencies? (targets B)
6. Is the evaluator powerful enough to evaluate migration contracts? (targets B)
7. What does composing two migration contracts look like in DSL? (targets B)

Also generate counterexamples against A (no composability, no self-validation) and C (complexity of maintaining two representations).

For Candidate B counterexamples: if a pressure test question reveals that existing Tenor constructs CANNOT naturally express migration semantics without new constructs, record a scope_narrowing rebuttal noting the limitation — but per user directive favoring Candidate B/C, evaluate whether the migration contract can still work with acknowledged limitations (e.g., the migration contract uses a constrained subset of Tenor's expressiveness, or uses Tenor constructs in a conventionalized way rather than requiring new constructs).

**Derived section:**
Populate the `derived` object with `eliminated` and `survivors` arrays. Per user directive, the outcome should favor Candidate B or C (Tenor contract as migration output). If Candidate B survives with scope narrowings, record them as `scope_narrowings` on the Survivor entry. If Candidate B is eliminated by fatal counterexamples (e.g., requires constructs not in v1.0 spec), Candidate C should survive as the hybrid approach (keeps JSON interchange AND adds Tenor contract output).

Key guidance: the user explicitly wants migration output expressed as a Tenor contract, with JSON interchange kept alongside if desired. This favors Candidate C (hybrid) as the most natural fit — it preserves the existing `tenor diff` JSON output while adding `tenor diff --migration` that produces a Tenor contract. But if Candidate B can survive pressure testing (migration contracts work within existing v1.0 constructs), it is also acceptable.
  </action>
  <verify>
Validate the JSON is well-formed: `python3 -c "import json; json.load(open('docs/cffp/migration-semantics.json'))"`. Verify all required CFFP fields are present: protocol, construct, version, phase1 (with invariants), phase2 (with candidates), phase3 (with counterexamples), derived (with survivors). Check that derived.survivors is non-empty.
  </verify>
  <done>
docs/cffp/migration-semantics.json exists with complete Phase 1-3 content. At least 7 invariants declared. Three candidates formalized with claims and proof sketches. All seven CONTEXT.md pressure test questions addressed in Phase 3 counterexamples. Derived section populated with at least one survivor (Candidate B or C per user directive). The survivor's scope_narrowings capture any limitations discovered during pressure testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Execute CFFP Phases 4-6 (Collapse, Static Obligations, Canonicalization) and produce breaking change taxonomy</name>
  <files>docs/cffp/migration-semantics.json</files>
  <action>
Continue the CFFP run in `docs/cffp/migration-semantics.json` by adding Phase 4, Phase 5, and Phase 6.

**Phase 4 — Collapse Test:**
If multiple survivors exist (e.g., both B and C survive):
- Attempt collapse: Can they be merged? Candidate C is already a superset of A+B, so if both A and C survive, C subsumes A. If both B and C survive, C already contains B's migration-as-contract capability.
- If collapse succeeds, produce a merged_candidate. If collapse fails, select the survivor based on the user directive (favor the one that expresses migration as Tenor contract).
- Record `selection_basis` explaining the rationale.

If only one survivor (e.g., C alone): set `attempted: false` in collapse_result (no collapse needed with a single survivor).

**Phase 5 — Static Analysis Obligations:**
Define static obligations for the surviving candidate:
1. The diff representation preserves all semantic changes detectable by the interchange schema
2. The breaking/non-breaking classification is mechanically derivable from the diff output
3. The migration contract (if Candidate B or C) is a valid Tenor contract that elaborates without error
4. The taxonomy covers every field in every construct kind defined in `docs/interchange-schema.json`
5. The in-flight flow migration policy is orthogonal to contract evaluation semantics

Each obligation needs an argument and `provable: true` assessment. Set `all_provable: true` if all obligations pass.

**Phase 6 — Canonical Form:**
Produce the canonical form for Migration Semantics. The `formal_statement` must include:

1. **Diff representation definition:** Based on the selected candidate — if C (hybrid), define both the JSON DiffEntry format and the Tenor migration contract format. If B, define the Tenor migration contract as the primary output.

2. **Breaking change taxonomy:** The complete classification table covering every construct kind and field. Use the comprehensive analysis from RESEARCH.md as the starting material, but refine based on CFFP pressure testing results. The taxonomy must be structured as:
   - Per construct kind (Fact, Entity, Rule, Persona, Operation, Flow)
   - Per field within each construct
   - Per change type (add, remove, change)
   - Classification: BREAKING, NON-BREAKING, or REQUIRES-ANALYSIS
   - Reason for classification
   - Impact on new flows vs in-flight flows (separate analysis per RESEARCH.md Pitfall 4)

3. **In-flight flow migration policy requirement:** Executors deploying a new contract version with breaking changes MUST declare one of: blue-green (new flows on new version, in-flight flows complete on old version), force-migrate (all flows transition to new version), or abort (in-flight flows with breaking changes are terminated). The policy is a deployment concern, not a contract semantics concern.

The `evaluation_def` should describe how the taxonomy is applied: given a diff between two interchange bundles, iterate over each DiffEntry, look up the (construct_kind, field, change_type) triple in the taxonomy, and emit the classification. If any entry is BREAKING, the overall diff is BREAKING and the executor must declare a migration policy.

The `satisfies` array must list all invariant IDs that the canonical form satisfies.

The `acknowledged_limitations` must include any scope_narrowings from Phase 3 survivors.

Set `outcome` to "canonical" (if single survivor) or "collapse" (if collapse merged survivors).
Set `outcome_notes` explaining the result, referencing the user directive that migration output should be a Tenor contract.
  </action>
  <verify>
Validate the complete JSON: `python3 -c "import json; d = json.load(open('docs/cffp/migration-semantics.json')); assert 'phase5' in d; assert 'phase6' in d; assert d['phase5']['all_provable'] == True; assert d['outcome'] in ['canonical', 'collapse']"`. Verify the canonical form contains `formal_statement`, `evaluation_def`, `satisfies` (non-empty), and `acknowledged_limitations`. Verify the formal_statement contains the breaking change taxonomy covering all six construct kinds.
  </verify>
  <done>
docs/cffp/migration-semantics.json is a complete CFFP instance with all 6 phases. The canonical form contains: (1) the diff representation decision (Candidate B or C selected per user directive), (2) the complete breaking change taxonomy covering every (construct_kind, field, change_type) triple for all six construct kinds, (3) the in-flight flow migration policy requirement. The outcome is "canonical" or "collapse". All static obligations are provable. The taxonomy is exhaustive per MI4.
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import json; d = json.load(open('docs/cffp/migration-semantics.json')); print('Valid JSON'); assert d['protocol']['version'] == '0.2.1'; print('Protocol version OK'); assert len(d['phase1']['invariants']) >= 7; print(f'Invariants: {len(d[\"phase1\"][\"invariants\"])}'); assert len(d['phase2']['candidates']) == 3; print('Candidates: 3'); assert len(d['derived']['survivors']) >= 1; print(f'Survivors: {len(d[\"derived\"][\"survivors\"])}'); assert d['phase5']['all_provable']; print('All obligations provable'); assert d['outcome'] in ['canonical', 'collapse']; print(f'Outcome: {d[\"outcome\"]}')"` — all assertions pass
2. The selected candidate (outcome) expresses migration output as a Tenor contract (Candidate B or C)
3. The breaking change taxonomy in phase6.canonical.formal_statement covers all six construct kinds: Fact, Entity, Rule, Persona, Operation, Flow
4. Structure matches existing CFFP artifacts (docs/cffp/persona.json, p7-outcome-typing.json, p5-shared-types.json)
</verification>

<success_criteria>
- docs/cffp/migration-semantics.json exists and is valid JSON
- CFFP instance follows docs/cffp.cue schema structure (all required phases present)
- Diff representation question resolved — migration output expressed as Tenor contract
- Breaking change taxonomy classifies every construct change type (MIGR-02 satisfied)
- All seven pressure test questions from CONTEXT.md addressed
- CFFP outcome is "canonical" or "collapse" (not "open")
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-cffp-migration-semantics/03.1-01-SUMMARY.md`
</output>
