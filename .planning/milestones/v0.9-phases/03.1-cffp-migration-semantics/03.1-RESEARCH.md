# Phase 3.1: CFFP — Migration Semantics - Research

**Researched:** 2026-02-21
**Domain:** Contract versioning, breaking change taxonomy, in-flight migration policy, CFFP protocol application
**Confidence:** HIGH

## Summary

Phase 3.1 is a **spec prose and formal taxonomy** phase, not a code implementation phase. The deliverables are: (1) a CFFP-derived breaking change taxonomy classifying every construct change type as breaking or non-breaking, (2) a new "Versioning & Migration" section in TENOR.md defining executor obligations for contract version transitions, and (3) a mandatory in-flight flow migration policy declaration requirement. The existing `diff.rs` (MIGR-01, completed in Phase 3) provides the structural diff foundation that this taxonomy classifies.

The critical design question from CONTEXT.md — "Should Tenor diffs be expressed as Tenor contracts?" — must be resolved through the CFFP process before the taxonomy can be finalized. This question has three candidates (interchange diff, migration-as-contract, hybrid) that each imply different taxonomies and different executor obligations.

**Primary recommendation:** Execute the CFFP run on the diff representation question first (it gates everything else), then build the breaking change taxonomy by systematically enumerating every field of every construct kind and classifying each possible change. Structure the TENOR.md section to parallel the existing Executor Obligations pattern (Section 16) — numbered migration obligations (M1, M2, ...) with trust boundary annotations.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
CONTEXT.md does not contain explicit "Decisions" / "Claude's Discretion" / "Deferred Ideas" sections. Instead, it contains a single Critical Design Question with three candidates that MUST go through CFFP:

**MUST CFFP: "Should Tenor diffs be expressed as Tenor contracts?"**
- Candidate A: Interchange diff (current structural JSON diff)
- Candidate B: Migration as Tenor contract (diff output is a .tenor file)
- Candidate C: Hybrid (both representations, different use cases)

Seven pressure test questions are specified that the CFFP run must address.

### Phase Constraints (from phase description)
- CFFP protocol: invariant declaration, candidate formalisms, pressure testing, canonical form. Same rigor as Phase 1 spec work.
- Output is spec prose (new section in TENOR.md) plus a formal breaking-change taxonomy that Phase 4's `tenor diff --breaking` implements.
- In-flight flow migration policy: spec requires executors to DECLARE their policy (blue-green, force-migrate, or abort), not prescribe which one.

### Deferred Ideas (OUT OF SCOPE)
- No code implementation in this phase (taxonomy and spec prose only)
- Phase 4 implements `tenor diff --breaking` using S1-S7 analysis outputs
- Phase 4 implements `tenor diff --explain` for human-readable migration documents
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| MIGR-02 | Breaking change taxonomy — CFFP-derived classification rules for what constitutes breaking vs non-breaking changes (entity state removal, fact type narrowing, verdict removal, etc.) | Full construct-by-construct field analysis below; CFFP process pattern from Phase 1 persona/P7/P5 runs; prior art from Protobuf/Avro/Confluent compatibility models |
| MIGR-04 | Spec section on Versioning & Migration defining executor obligations for contract version transitions, including mandatory in-flight flow migration policy declaration | Executor Obligations pattern (Section 16) as template; in-flight migration strategies from XState/AWS Step Functions research; three policy options (blue-green, force-migrate, abort) identified |
</phase_requirements>

## Standard Stack

This phase produces spec prose and a CFFP JSON artifact, not code. There is no library stack.

### Core Deliverables
| Artifact | Format | Purpose | Why This Format |
|----------|--------|---------|-----------------|
| CFFP JSON | `docs/cffp/migration-semantics.json` | CFFP run record for diff representation + breaking change taxonomy | Matches existing CFFP provenance pattern (`docs/cffp/persona.json`, `p7-outcome-typing.json`, `p5-shared-types.json`) |
| TENOR.md section | Markdown in `docs/TENOR.md` | New "Versioning & Migration" spec section | Authoritative spec prose, parallels Section 16 (Executor Obligations) |
| Breaking change taxonomy | Table/rules in TENOR.md | Per-construct-field classification of breaking vs non-breaking | Referenced by Phase 4's `tenor diff --breaking` implementation |

### Supporting Artifacts
| Artifact | Format | Purpose | When to Create |
|----------|--------|---------|----------------|
| Acknowledged Limitations entries | AL entries in Appendix A | Migration-specific limitations | After CFFP run identifies scope narrowings |
| Pending Work updates | Section 17 updates | Track migration-related deferred items | If CFFP eliminates candidates with deferred capabilities |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| CFFP JSON file | Inline in TENOR.md | CFFP JSON preserves the full pressure testing record with counterexamples; inline would lose the formal structure |
| Single taxonomy table | Per-construct subsections | Table is more scannable; subsections allow per-construct nuance. Recommend: one summary table + per-construct detail |
| New spec section | Extend Section 16 (Executor Obligations) | Migration is both an executor concern AND a tooling concern (diff classification). Separate section is cleaner. |

## Architecture Patterns

### Pattern 1: CFFP Run Structure (from existing precedent)

**What:** The Constraint-First Formalization Protocol follows a six-phase structure established in the three prior runs (persona, P7, P5).

**When to use:** For the diff representation question and the breaking change taxonomy design.

**Structure (from `docs/cffp/persona.json`):**
```
phase1: Invariant declaration (testable, structural, classified by soundness/termination/determinism/analyzability/composability)
phase2: Candidate formalisms with claims against each invariant, complexity analysis, failure modes
phase3: Counterexamples targeting specific candidates/invariants, with rebuttals (valid/invalid, refutation/scope_narrowing)
phase4: Merge attempt or selection (with reason)
phase5: Composition obligations (provable properties)
phase6: Canonical form (formal_statement, evaluation_def, satisfies, acknowledged_limitations)
```

**Key observation:** The CFFP run for this phase has TWO distinct subjects:
1. **Diff representation** (Candidate A/B/C from CONTEXT.md) — gates the taxonomy structure
2. **Breaking change taxonomy rules** — depends on the diff representation choice

These could be one CFFP run or two sequential runs. Recommendation: one CFFP run where the diff representation is resolved first (Phase 1-4), then the taxonomy rules are formalized as part of the canonical form (Phase 5-6).

### Pattern 2: Breaking Change Taxonomy Structure

**What:** A systematic classification of every possible change to every field of every construct kind.

**When to use:** This IS the core deliverable of MIGR-02.

**Recommended structure:**
```
For each construct kind (Fact, Entity, Rule, Persona, Operation, Flow):
  For each field:
    ADD field/construct    → breaking or non-breaking + rule
    REMOVE field/construct → breaking or non-breaking + rule
    CHANGE field value     → breaking or non-breaking + rule (depends on direction)
```

**Prior art mapping (Confluent Schema Registry compatibility model):**
- BACKWARD compatible = new contract can process old facts/state → consumer (executor) upgraded first
- FORWARD compatible = old executor can process new contract → producer (contract author) upgraded first
- FULL compatible = both directions safe

For Tenor, the relevant direction is: **can an executor built against contract v1 safely process entities/flows that were started under contract v1 but now need to operate under contract v2?** This is the backward compatibility question.

### Pattern 3: Spec Section Structure (Executor Obligations as Template)

**What:** The existing Executor Obligations section (Section 16) provides the structural template for the new Versioning & Migration section.

**Template:**
```markdown
## N. Versioning & Migration

### N.1 The Migration Problem
[Framing paragraph, analogous to §16.1 "The Conformance Gap"]

### N.2 Breaking Change Taxonomy
[Summary table + per-construct classification rules]

### N.3 Executor Migration Obligations
[Numbered obligations M1-Mn, paralleling E1-E9]

### N.4 In-Flight Flow Migration Policy
[Mandatory policy declaration requirement]
```

### Anti-Patterns to Avoid
- **Prescribing a specific migration strategy:** The spec requires executors to DECLARE their policy, not follow a specific one. The taxonomy classifies changes; the executor chooses how to handle them.
- **Conflating interchange format versioning with contract versioning:** Section 13.2.1 already handles interchange format versioning (producer/consumer semver). This phase covers CONTRACT content versioning (what happens when the business logic changes).
- **Under-specifying "breaking":** "Breaking" must be defined relative to a specific consumer. For Tenor, "breaking" means: an executor built against contract v(N) cannot safely continue operating under contract v(N+1) without explicit migration action.
- **Ignoring the frozen verdict semantics interaction:** In-flight flows operate under frozen snapshots. A contract change that affects verdicts does not affect in-flight flows (their snapshot is immutable). But a contract change that affects entity states or operation definitions DOES affect in-flight flows because operations are executed against live entity state.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Compatibility model from scratch | Custom compatibility framework | Adapt Confluent/Protobuf compatibility patterns to Tenor's construct model | These models are battle-tested with well-understood semantics; Tenor's closed-world model maps cleanly to their backward/forward/full compatibility categories |
| CFFP process from scratch | New protocol | Follow the exact CFFP structure from `docs/cffp/persona.json` | Three prior runs establish the process; consistency matters for spec provenance |
| In-flight migration categories | Custom policy taxonomy | Adapt the three standard patterns (blue-green, drain-and-switch, force-migrate) | These are industry-standard deployment strategies with well-understood tradeoffs |

**Key insight:** The breaking change taxonomy is a formal classification problem with well-established prior art. The novelty is applying it to Tenor's specific construct model, not inventing new classification theory.

## Common Pitfalls

### Pitfall 1: Mixing Contract Versioning with Interchange Versioning
**What goes wrong:** The spec already has interchange format versioning (Section 13.2.1, `tenor_version` semver). Adding contract versioning could create confusion about which version is being discussed.
**Why it happens:** Both are "versioning" but operate at different levels — interchange is about the JSON structure, contract is about the business logic content.
**How to avoid:** Clearly distinguish: interchange versioning = structural format; contract versioning = semantic content. The breaking change taxonomy applies to contract content changes, not interchange format changes.
**Warning signs:** If the taxonomy references `tenor_version` bumps, it is probably conflating the two.

### Pitfall 2: Incomplete Construct Coverage
**What goes wrong:** The taxonomy misses a construct field, and Phase 4's `--breaking` implementation discovers the gap.
**Why it happens:** Manual enumeration of construct fields is error-prone.
**How to avoid:** Systematically enumerate from the interchange schema (`docs/interchange-schema.json`). Every field in every construct definition must appear in the taxonomy. Cross-reference against the JSON Schema `$defs` section.
**Warning signs:** If the taxonomy has fewer entries than the interchange schema has fields, coverage is incomplete.

### Pitfall 3: Under-Analyzing the CFFP Diff Representation Question
**What goes wrong:** The CFFP run on "should diffs be Tenor contracts?" does not adequately pressure-test Candidate B, and the selection is made without resolving the seven questions from CONTEXT.md.
**Why it happens:** Candidate B is intellectually attractive (self-hosting, composability) but may require new constructs that violate the v1.0 spec freeze.
**How to avoid:** Every one of the seven pressure test questions in CONTEXT.md must have a concrete answer in the CFFP counterexample phase. If any question cannot be answered definitively, that is a counterexample against the candidate.
**Warning signs:** If the CFFP phase3 counterexamples section does not address all seven questions, the run is incomplete.

### Pitfall 4: Ignoring Frozen Verdict Semantics in Migration Analysis
**What goes wrong:** The taxonomy treats all in-flight flows as equally affected by contract changes, when in reality frozen verdict semantics provide natural isolation for some changes.
**Why it happens:** Forgetting that flows freeze their verdict set at initiation.
**How to avoid:** For each change type, separately analyze: (a) impact on new flow initiations, (b) impact on in-flight flows. Frozen snapshots mean verdict-layer changes (rule changes, fact type changes) do NOT affect in-flight flows. But entity state and operation changes DO affect in-flight flows because operations execute against live entity state.
**Warning signs:** If the taxonomy does not distinguish "affects new flows" from "affects in-flight flows," it is incomplete.

### Pitfall 5: Candidate B (Migration-as-Contract) and the Spec Freeze
**What goes wrong:** Candidate B requires new Tenor constructs or construct extensions to express migrations, which violates the v1.0 spec freeze.
**Why it happens:** Expressing "Entity state was added" as a Tenor entity with states like "Added" and "Removed" requires either meta-level constructs not in the current spec, or repurposing existing constructs in ways they were not designed for.
**How to avoid:** In the CFFP pressure test, explicitly ask: "Does Candidate B require any construct or semantic change not in the frozen v1.0 spec?" If yes, it must be deferred or the spec freeze must be explicitly relaxed (which requires its own CFFP run).
**Warning signs:** If the Candidate B formalism references constructs or fields not in the current interchange schema.

## Code Examples

This phase produces no code. However, the following concrete examples illustrate the taxonomy entries:

### Example 1: Entity State Addition (Non-Breaking)
```
Contract v1:
  entity Order { states: [draft, submitted, approved] ... }

Contract v2:
  entity Order { states: [draft, submitted, approved, cancelled] ... }

Classification: NON-BREAKING
Reason: Adding a state does not invalidate any existing transition.
         An executor built for v1 will never encounter the "cancelled" state
         in existing flows. New flows may use it.
Caveat: If the new state is reachable via existing transitions, it requires
        new operation definitions — but the state addition itself is non-breaking.
```

### Example 2: Entity State Removal (BREAKING)
```
Contract v1:
  entity Order { states: [draft, submitted, approved, cancelled] ... }

Contract v2:
  entity Order { states: [draft, submitted, approved] ... }

Classification: BREAKING
Reason: Entities currently in "cancelled" state have no valid state in v2.
        Operations referencing "cancelled" as a source state are now invalid.
        In-flight flows that expect to transition to/from "cancelled" will fail.
Migration required: All entities in "cancelled" state must be migrated.
```

### Example 3: Fact Type Widening (Non-Breaking)
```
Contract v1:
  fact amount { type: Int(min: 0, max: 1000) ... }

Contract v2:
  fact amount { type: Int(min: 0, max: 10000) ... }

Classification: NON-BREAKING (widening)
Reason: All values valid under v1 are valid under v2.
        Existing rules comparing against this fact remain sound.
Caveat: Rules with hardcoded thresholds may need review,
        but the type change itself is safe.
```

### Example 4: Fact Type Narrowing (BREAKING)
```
Contract v1:
  fact amount { type: Int(min: 0, max: 10000) ... }

Contract v2:
  fact amount { type: Int(min: 0, max: 1000) ... }

Classification: BREAKING
Reason: Values valid under v1 (e.g., 5000) are invalid under v2.
        Existing data may contain values outside the new range.
Migration required: Executor must validate all existing fact values
        against the new type constraint.
```

### Example 5: Rule Removal (BREAKING)
```
Contract v1:
  rule check_threshold { stratum: 0, ... produce: threshold_met(...) }

Contract v2:
  [rule check_threshold removed]

Classification: BREAKING
Reason: Any rule in a higher stratum that references verdict "threshold_met"
        via verdict_present() will never fire. Any operation precondition
        referencing this verdict will never be satisfied.
Impact: Cascading — affects all constructs that depend on this verdict.
```

### Example 6: Operation Outcome Addition (Non-Breaking)
```
Contract v1:
  operation decide_claim { outcomes: [approved] ... }

Contract v2:
  operation decide_claim { outcomes: [approved, rejected] ... }

Classification: BREAKING (despite being additive)
Reason: Flow OperationSteps must exhaustively handle all outcomes (§11.5).
        Existing flows that only handle [approved] are now invalid because
        they do not handle "rejected".
Note: This is a key difference from schema evolution models — Tenor's
      exhaustive outcome handling makes additive outcome changes breaking.
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No contract versioning | Section 13.2.1 handles interchange format versioning only | Phase 1 (v1.0 spec) | Contract content versioning is the gap this phase fills |
| Generic JSON diff | Domain-aware (kind, id) diff in `diff.rs` | Phase 3 (MIGR-01) | Provides the structural foundation for breaking change classification |
| No CFFP for migration | CFFP required for migration semantics | Phase 3.1 (this phase) | Same rigor as construct design |

**Prior art in schema compatibility:**
- **Protobuf:** Field numbers are wire-format identifiers; adding optional fields is safe, removing/renumbering is breaking. Type changes are breaking if wire type changes.
- **Avro/Confluent:** BACKWARD/FORWARD/FULL/TRANSITIVE compatibility modes. Default is BACKWARD (new schema reads old data).
- **XState:** `xstate-migrate` generates JSON Patch operations for persisted state machine snapshots. In-flight machines can be "grandfathered" or force-migrated.
- **AWS Step Functions:** Blue-green deployment via versions and aliases. In-flight executions continue on old version; new executions route to new version.

**Tenor-specific considerations:**
- Tenor's closed-world semantics (C5) mean the contract IS the complete system description. A breaking change to the contract is a breaking change to the system — there is no "implementation code" that could bridge the gap.
- Tenor's frozen verdict semantics provide natural isolation for in-flight flows at the verdict layer, but NOT at the entity state or operation layer.
- Tenor's exhaustive outcome handling (§11.5) means additive changes to operation outcomes are BREAKING (unlike most schema evolution models where adding is safe).

## Comprehensive Construct-Field Change Analysis

This section systematically enumerates every construct kind and every field that could change, providing preliminary breaking/non-breaking classification. This is the raw material for the CFFP-derived taxonomy.

### Fact Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Fact | Non-breaking | No existing construct references it |
| id | Remove Fact | BREAKING | Rules/Operations may reference via fact_ref |
| type | Widen (larger range, more enum values) | Non-breaking | All existing values remain valid |
| type | Narrow (smaller range, fewer enum values) | BREAKING | Existing values may be invalid |
| type | Change base type (e.g., Int to Decimal) | BREAKING | Expression type-checking changes |
| source | Change source | Non-breaking | Source is executor metadata, not evaluation semantics |
| default | Add default | Non-breaking | Provides fallback where none existed |
| default | Remove default | BREAKING | Facts without values now fail assembly |
| default | Change default value | Context-dependent | May change evaluation outcomes |

### Entity Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Entity | Non-breaking | No existing construct references it |
| id | Remove Entity | BREAKING | Operations with effects on this entity are invalid |
| states | Add state | Non-breaking | Existing transitions unaffected |
| states | Remove state | BREAKING | Entities in removed state, operations with transitions from/to it |
| initial | Change initial state | BREAKING | New entity instances start in different state |
| transitions | Add transition | Non-breaking | New paths available, existing paths unchanged |
| transitions | Remove transition | BREAKING | Operations using this transition are invalid |
| parent | Add parent | Context-dependent | Depends on propagation semantics |
| parent | Remove parent | Context-dependent | Depends on propagation semantics |
| parent | Change parent | BREAKING | DAG structure and propagation changes |

### Rule Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Rule | Non-breaking (if stratum 0) to BREAKING | Higher-stratum rules may shadow or conflict |
| id | Remove Rule | BREAKING | Verdicts it produced are no longer available |
| stratum | Change stratum | BREAKING | Evaluation order changes, dependency validity may break |
| body.when | Change predicate | BREAKING | Different evaluation results |
| body.produce | Change verdict type | BREAKING | Downstream rules/operations referencing this verdict |
| body.produce | Change payload type | BREAKING | Consumers of this verdict expect specific type |
| body.produce | Change payload value/expression | BREAKING | Different verdict values |

### Persona Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Persona | Non-breaking | No existing construct references it |
| id | Remove Persona | BREAKING | Operations/Flows referencing this persona are invalid |

### Operation Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Operation | Non-breaking | No existing Flow references it |
| id | Remove Operation | BREAKING | Flows with OperationSteps referencing it are invalid |
| allowed_personas | Add persona | Non-breaking | Widens authority |
| allowed_personas | Remove persona | BREAKING | Narrows authority, existing flows may reference removed persona |
| precondition | Weaken (more permissive) | Non-breaking | All previously valid invocations still valid |
| precondition | Strengthen (more restrictive) | BREAKING | Previously valid invocations may now fail |
| effects | Add effect (new entity) | Non-breaking | Does not invalidate existing effects |
| effects | Remove effect | BREAKING | Entity state transitions no longer occur |
| effects | Change effect (different from/to states) | BREAKING | Different state transition behavior |
| outcomes | Add outcome | BREAKING | Exhaustive handling in Flows means all OperationSteps must be updated |
| outcomes | Remove outcome | BREAKING | Flows handling this outcome have dead routing paths |
| error_contract | Add error type | Non-breaking | New failure modes, existing handling unaffected |
| error_contract | Remove error type | Context-dependent | If failure handlers reference specific errors |

### Flow Changes
| Field | Change Type | Breaking? | Reason |
|-------|------------|-----------|--------|
| id | Add new Flow | Non-breaking | No existing construct references it (unless SubFlowStep) |
| id | Remove Flow | BREAKING | SubFlowSteps referencing it are invalid |
| entry | Change entry step | BREAKING | Different execution path |
| steps | Add step | Context-dependent | Depends on whether existing paths are modified |
| steps | Remove step | BREAKING | References to removed step are invalid |
| steps | Change step routing | BREAKING | Different execution paths |
| step.persona | Change | BREAKING | Different authority at runtime |
| step.outcomes | Change routing | BREAKING | Different flow paths for same operation outcomes |
| step.on_failure | Change | BREAKING | Different failure handling behavior |

## CFFP Invariant Candidates for Migration Semantics

Based on the analysis above, the following invariants should be declared in Phase 1 of the CFFP run:

### For Diff Representation Question
- **MI1 — Diff completeness:** The diff representation must capture every semantic change between two contract versions. No change that affects evaluation outcomes may be omitted.
- **MI2 — Diff determinism:** Given the same two contract versions, the diff must be identical regardless of which conforming elaborator produced the interchange bundles.
- **MI3 — Classification decidability:** For every change captured in the diff, the breaking/non-breaking classification must be decidable at static analysis time (no runtime information required).
- **MI4 — Taxonomy exhaustiveness:** Every (construct kind, field, change type) triple must have a classification. No "unknown" or "context-dependent" classifications in the final taxonomy.

### For In-Flight Migration Policy
- **MI5 — Policy declaration is mandatory:** An executor deploying a new contract version with any breaking changes MUST declare its in-flight flow migration policy.
- **MI6 — Policy does not affect contract semantics:** The migration policy is an executor concern. It does not change the evaluation model, verdict resolution, or any contract-level semantics.
- **MI7 — Policy completeness:** The declared policy must address all in-flight flows, not just a subset.

## Open Questions

1. **Where should the Versioning & Migration section be numbered in TENOR.md?**
   - What we know: Current sections go 1-17 plus Appendices A-C. Executor Obligations is Section 16. Pending Work is Section 17.
   - What's unclear: Should migration be a subsection of Executor Obligations (16.N) or a new top-level section (17, pushing Pending Work to 18)?
   - Recommendation: New top-level section. Migration is broader than executor obligations — it also covers tooling obligations (diff classification) and contract authoring obligations (version management).

2. **Should the CFFP run be one run or two?**
   - What we know: The diff representation question and the taxonomy are conceptually separable but the taxonomy depends on the diff representation choice.
   - What's unclear: Whether the CFFP protocol supports multi-subject runs.
   - Recommendation: One CFFP run with the diff representation as the primary subject. The taxonomy rules become part of the Phase 5/6 canonical form, contingent on the selected diff representation.

3. **How does "breaking" interact with the v1.0 spec freeze?**
   - What we know: The spec is frozen at v1.0. No breaking changes to construct semantics without a new CFFP run. The versioning section is an ADDITIVE change (new section, not modifying existing semantics).
   - What's unclear: Does adding migration obligations to executors constitute a change to the executor obligations section, or is it purely additive?
   - Recommendation: Treat as additive. The new section defines new obligations but does not modify E1-E9. Reference E1-E9 from the migration section where relevant.

4. **Candidate B feasibility with spec freeze**
   - What we know: Candidate B (migration-as-Tenor-contract) would require expressing diff concepts in Tenor's construct model. Current constructs (Fact, Entity, Rule, Operation, Flow, Persona) are designed for business domain contracts, not meta-level descriptions.
   - What's unclear: Whether existing constructs can naturally express migration semantics without new constructs or semantic changes.
   - Recommendation: The CFFP pressure test should evaluate this rigorously. The seven questions in CONTEXT.md are the right test. If Candidate B requires new constructs, it should be deferred to v2 and Candidate A selected for v1.0.

5. **Granularity of "breaking" for precondition changes**
   - What we know: Weakening a precondition (making it more permissive) is non-breaking; strengthening is breaking. But "weaker" and "stronger" for arbitrary predicate expressions may not be statically decidable.
   - What's unclear: How to classify precondition changes when static comparison of predicate strength is undecidable.
   - Recommendation: For the taxonomy, classify any precondition change as POTENTIALLY BREAKING with a note that S3a/S3b analysis (Phase 4's static analyzer) can refine the classification. The taxonomy should support a three-level classification: BREAKING, NON-BREAKING, REQUIRES-ANALYSIS.

## Sources

### Primary (HIGH confidence)
- `docs/TENOR.md` — Sections 4-16, complete construct definitions and semantics
- `docs/interchange-schema.json` — Complete field-level schema for all construct kinds
- `docs/cffp/persona.json` — CFFP process structure and precedent (Phases 1-6)
- `docs/cffp/p7-outcome-typing.json` — CFFP precedent for outcome-related changes
- `docs/cffp/p5-shared-types.json` — CFFP precedent for type system changes
- `crates/cli/src/diff.rs` — Existing structural diff implementation (MIGR-01)
- `.planning/phases/03.1-cffp-migration-semantics/CONTEXT.md` — Critical design question and pressure test questions

### Secondary (MEDIUM confidence)
- [Confluent Schema Registry compatibility model](https://docs.confluent.io/platform/current/schema-registry/fundamentals/schema-evolution.html) — BACKWARD/FORWARD/FULL/TRANSITIVE compatibility categories
- [Protobuf compatibility rules](https://earthly.dev/blog/backward-and-forward-compatibility/) — Field number stability, wire type compatibility, adding vs removing fields
- [XState migration discussion](https://github.com/statelyai/xstate/discussions/1338) — In-flight state machine migration strategies (grandfathering, event sourcing, force-migrate)
- [AWS Step Functions versioning](https://aws.amazon.com/blogs/compute/deploying-state-machines-incrementally-with-versions-and-aliases-in-aws-step-functions/) — Blue-green deployment for state machines with versions and aliases

### Tertiary (LOW confidence)
- [xstate-migrate npm package](https://www.npmjs.com/package/xstate-migrate) — JSON Patch-based state machine migration (implementation pattern, not directly applicable to Tenor's formal model)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — This is a spec prose phase with well-defined CFFP process from three prior runs
- Architecture: HIGH — Construct model is fully specified in TENOR.md; change surface area is enumerable from interchange schema
- Pitfalls: HIGH — Frozen verdict semantics interaction and exhaustive outcome handling are well-documented in the spec; the non-obvious breaking classifications (e.g., outcome addition is breaking) are derivable from spec constraints
- CFFP execution: MEDIUM — The diff representation question (Candidate B) introduces genuine uncertainty about whether existing constructs can express migration semantics. This must be resolved through the CFFP process itself.

**Research date:** 2026-02-21
**Valid until:** Indefinite (spec is frozen at v1.0; construct model is stable)
