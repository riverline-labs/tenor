---
phase: 04-static-analysis
plan: 02
type: execute
wave: 1
depends_on: [01]
files_modified:
  - crates/analyze/src/s2_reachability.rs
  - crates/analyze/src/s3a_admissibility.rs
  - crates/analyze/src/lib.rs
autonomous: true
requirements: [ANLZ-02, ANLZ-03]

must_haves:
  truths:
    - "S2 derives all states reachable from initial via BFS/DFS over the declared transition relation"
    - "S2 reports unreachable (dead) states -- declared but not reachable from initial"
    - "S3a determines for each (entity, state, persona) triple which Operations are structurally admissible"
    - "S3a performs type-level satisfiability checks on precondition expressions (e.g., Enum value mismatch is structurally unsatisfiable)"
    - "S3a is O(|expression tree|) per precondition -- always computationally feasible"
  artifacts:
    - path: "crates/analyze/src/s2_reachability.rs"
      provides: "S2 reachable state analysis with dead state detection"
      contains: "pub fn analyze_reachability"
    - path: "crates/analyze/src/s3a_admissibility.rs"
      provides: "S3a structural admissibility per (entity, state, persona)"
      contains: "pub fn analyze_admissibility"
  key_links:
    - from: "crates/analyze/src/s2_reachability.rs"
      to: "crates/analyze/src/s1_state_space.rs"
      via: "Uses S1 state space as input"
      pattern: "S1Result"
    - from: "crates/analyze/src/s3a_admissibility.rs"
      to: "crates/analyze/src/s2_reachability.rs"
      via: "Uses S2 reachability to scope analysis to reachable states"
      pattern: "S2Result"
---

<objective>
Implement S2 (Reachable States) and S3a (Structural Admissibility) analyses.

Purpose: S2 identifies dead states (declared but unreachable) -- a valuable finding for contract authors. S3a determines which Operations are structurally admissible per entity state and persona, using type-level analysis only. Together they answer "what can happen in each state?" without execution.

Output: S2 producing reachable/unreachable state sets per entity, and S3a producing `Map<(EntityId, State, PersonaId), Vec<OperationId>>` for structurally admissible operations.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-static-analysis/04-RESEARCH.md
@.planning/phases/04-static-analysis/04-CONTEXT.md

@crates/analyze/src/lib.rs
@crates/analyze/src/bundle.rs
@crates/analyze/src/s1_state_space.rs
@docs/TENOR.md (Section 15 â€” S2, S3a definitions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement S2 reachability analysis with dead state detection</name>
  <files>
    crates/analyze/src/s2_reachability.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s2_reachability.rs`:
   - Define `ReachabilityResult` struct (Debug, Clone, Serialize):
     - `entity_id: String`
     - `reachable_states: BTreeSet<String>` -- states reachable from initial via transition relation
     - `unreachable_states: BTreeSet<String>` -- declared states NOT reachable from initial (dead states)
     - `initial_state: String`
   - Define `S2Result` struct (Debug, Clone, Serialize):
     - `entities: BTreeMap<String, ReachabilityResult>`
     - `has_dead_states: bool` -- convenience flag: true if ANY entity has unreachable states
   - Implement `pub fn analyze_reachability(bundle: &AnalysisBundle) -> S2Result`:
     - For each entity:
       a. Build adjacency list from entity.transitions: `Map<String, Vec<String>>` (from -> [to])
       b. BFS from entity.initial_state:
          - Start with queue = [initial], visited = {initial}
          - For each state in queue, add all unvisited successor states
       c. `reachable_states` = visited set
       d. `unreachable_states` = declared_states - reachable_states
     - Set `has_dead_states` = any entity has non-empty unreachable_states

2. Update `lib.rs`: add `pub mod s2_reachability;` and re-export `S2Result`, `ReachabilityResult`.

3. Unit tests:
   a. Entity with all states reachable -- unreachable_states is empty
   b. Entity with a dead state (declared but no transition path from initial) -- verify it appears in unreachable_states
   c. Entity with single state (initial only, no transitions) -- reachable={initial}, unreachable={}
   d. Entity with disconnected subgraph -- multiple dead states detected
   e. Entity with cycle in transitions -- BFS still terminates, all cycle members reachable if reachable from initial
  </action>
  <verify>
    Run `cargo test -p tenor-analyze` -- S2 tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S2 correctly computes reachable and unreachable states for all entities via BFS. Dead states detected and reported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement S3a structural admissibility analysis</name>
  <files>
    crates/analyze/src/s3a_admissibility.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s3a_admissibility.rs`:
   - Define `AdmissibilityKey` struct (Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord):
     - `entity_id: String`
     - `state: String`
     - `persona_id: String`
   - Define `S3aResult` struct (Debug, Clone, Serialize):
     - `admissible_operations: BTreeMap<AdmissibilityKey, Vec<String>>` -- (entity, state, persona) -> [operation_ids]
     - `total_combinations_checked: usize`
   - Implement `pub fn analyze_admissibility(bundle: &AnalysisBundle) -> S3aResult`:
     - For each entity E, for each state S, for each persona P:
       a. Find Operations where:
          - P is in operation.allowed_personas
          - At least one effect has entity_id == E.id AND from_state == S
       b. For each matching Operation, check structural satisfiability of precondition:
          - If precondition is None (no precondition): structurally satisfiable
          - If precondition present: walk the expression tree checking type-level compatibility
       c. Collect operation IDs that pass both checks
     - Insert into BTreeMap keyed by AdmissibilityKey

   - Implement `fn is_structurally_satisfiable(precondition: &serde_json::Value, bundle: &AnalysisBundle) -> bool`:
     - Walk the predicate expression tree
     - For Compare nodes: check if the comparison operands have compatible types
       - If one operand is a literal and the other references a Fact with a known type:
         - Enum fact compared to string literal not in the enum's declared values -> unsatisfiable
         - Int fact compared to value outside declared range -> unsatisfiable
       - Otherwise: conservatively return true (structurally satisfiable)
     - For And nodes: all children must be structurally satisfiable
     - For Or nodes: at least one child must be structurally satisfiable
     - For Not nodes: child must be structurally satisfiable (negation doesn't change structural feasibility at type level)
     - For verdict_present nodes: always structurally satisfiable (depends on runtime)
     - For fact_ref nodes: always structurally satisfiable (fact exists = satisfiable)
     - This is the O(|expression tree|) analysis described in the spec

2. Update `lib.rs`: add `pub mod s3a_admissibility;` and re-export `S3aResult`.

3. Unit tests:
   a. Operation with persona authorized, effect matching state, no precondition -- admissible
   b. Operation with persona NOT in allowed_personas -- not admissible for that persona
   c. Operation with effect from wrong state -- not admissible for that state
   d. Operation with Enum precondition checking value not in declared enum -- structurally unsatisfiable
   e. Operation with compatible precondition -- structurally satisfiable
   f. Multiple personas, multiple entities -- verify cross-product enumeration
  </action>
  <verify>
    Run `cargo test -p tenor-analyze` -- S3a tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S3a correctly determines structural admissibility for all (entity, state, persona) triples. Type-level satisfiability analysis handles Enum value mismatch, Int range checks, and expression tree walking.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `cargo test -p tenor-analyze` -- S2 and S3a tests pass
3. S2 detects dead states in entities with unreachable state declarations
4. S3a correctly identifies structurally unsatisfiable preconditions (e.g., Enum mismatch)
5. All existing workspace tests pass
</verification>

<success_criteria>
- S2 produces reachable/unreachable state sets via BFS from initial
- S2 detects dead states and sets has_dead_states flag
- S3a enumerates admissible operations per (entity, state, persona) triple
- S3a performs type-level satisfiability checks on preconditions
- Both results are serializable structs
- Unit tests cover normal, edge, and error cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-static-analysis/04-02-SUMMARY.md`
</output>
