---
phase: 04-static-analysis
plan: 04
type: execute
wave: 3
depends_on: [03]
files_modified:
  - crates/analyze/src/s6_flow_paths.rs
  - crates/analyze/src/s7_complexity.rs
  - crates/analyze/src/lib.rs
autonomous: true
requirements: [ANLZ-06, ANLZ-07]

must_haves:
  truths:
    - "S6 enumerates all possible execution paths through each Flow including OperationStep outcome branching"
    - "S6 tracks personas at each step, Operation outcomes, entity states reachable, and terminal outcomes"
    - "S6 handles BranchStep (true/false paths), ParallelStep (branch and rejoin), and SubFlowStep (recursive)"
    - "S6 path enumeration is bounded at 10,000 paths to prevent exponential explosion"
    - "S7 computes evaluation complexity bounds for predicate expressions and flow max execution depth"
  artifacts:
    - path: "crates/analyze/src/s6_flow_paths.rs"
      provides: "S6 flow path enumeration"
      contains: "pub fn analyze_flow_paths"
    - path: "crates/analyze/src/s7_complexity.rs"
      provides: "S7 complexity bounds computation"
      contains: "pub fn analyze_complexity"
  key_links:
    - from: "crates/analyze/src/s6_flow_paths.rs"
      to: "crates/analyze/src/s5_verdicts.rs"
      via: "Uses S5 outcome space for OperationStep branching"
      pattern: "S5Result"
    - from: "crates/analyze/src/s7_complexity.rs"
      to: "crates/analyze/src/s6_flow_paths.rs"
      via: "Uses S6 path data for flow max depth computation"
      pattern: "S6Result"
---

<objective>
Implement S6 (Flow Path Enumeration) and S7 (Evaluation Complexity Bounds) analyses.

Purpose: S6 is the most complex analysis -- it enumerates all possible execution paths through each Flow, handling OperationStep outcome branching (exhaustive per Section 11.5), BranchStep (true/false), ParallelStep (branch/rejoin), and SubFlowStep (recursion). S7 uses S6 results to compute max execution depth and predicate expression complexity.

Output: S6 producing all enumerated paths with per-step metadata per flow (bounded at 10,000 paths). S7 producing complexity bounds for predicates and flow depth.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-static-analysis/04-RESEARCH.md
@.planning/phases/04-static-analysis/04-CONTEXT.md

@crates/analyze/src/lib.rs
@crates/analyze/src/bundle.rs
@crates/analyze/src/s5_verdicts.rs
@crates/eval/src/flow.rs
@docs/TENOR.md (Section 15 — S6, S7 definitions; Section 11 — Flow semantics)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement S6 flow path enumeration</name>
  <files>
    crates/analyze/src/s6_flow_paths.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s6_flow_paths.rs`:
   - Constants:
     - `const MAX_PATHS: usize = 10_000;` -- path enumeration cap
     - `const MAX_DEPTH: usize = 1_000;` -- recursion depth cap (matches eval step limit)

   - Define step type classification from raw JSON:
     - `enum StepKind { Operation, Branch, Parallel, SubFlow, Handoff, Unknown }`
     - Parse from step JSON `type` field

   - Define `FlowPathStep` struct (Debug, Clone, Serialize):
     - `step_id: String`
     - `step_type: String` -- "operation", "branch", "parallel", "subflow", "handoff"
     - `persona: Option<String>`
     - `operation_id: Option<String>` -- for OperationSteps
     - `outcome: Option<String>` -- which outcome branch was taken at this step
     - `entity_transitions: Vec<(String, String, String)>` -- (entity_id, from, to) derivable transitions

   - Define `FlowPath` struct (Debug, Clone, Serialize):
     - `steps: Vec<FlowPathStep>` -- ordered sequence of steps in this path
     - `terminal_step_id: Option<String>` -- final step (may be terminal outcome step)
     - `depth: usize` -- number of steps in path

   - Define `FlowPathResult` struct (Debug, Clone, Serialize):
     - `flow_id: String`
     - `paths: Vec<FlowPath>`
     - `path_count: usize`
     - `max_depth: usize` -- longest path in this flow
     - `truncated: bool` -- true if MAX_PATHS exceeded
     - `reachable_steps: BTreeSet<String>` -- all step IDs reachable from entry
     - `unreachable_steps: BTreeSet<String>` -- declared but unreachable steps

   - Define `S6Result` struct (Debug, Clone, Serialize):
     - `flows: BTreeMap<String, FlowPathResult>`
     - `total_paths: usize`

   - Implement `pub fn analyze_flow_paths(bundle: &AnalysisBundle, s5: &S5Result) -> S6Result`:
     - For each flow in bundle.flows:
       a. Parse step JSON array into a step index: `BTreeMap<String, serde_json::Value>` keyed by step ID
       b. Build step adjacency from routing/outcome fields:
          - OperationStep: outcomes map to next step IDs (one path per declared outcome from S5)
          - BranchStep: true_step and false_step (two paths)
          - ParallelStep: enumerate branches, then join at join_step (branches execute independently, rejoin)
          - SubFlowStep: treat as single step with success/failure paths
          - HandoffStep: single next step
       c. Enumerate paths via DFS from entry step:
          - Maintain path stack (current steps list)
          - At each step, compute possible next steps based on step type
          - For OperationSteps: branch on each declared outcome of the referenced operation
          - For BranchSteps: branch on true/false
          - For ParallelSteps: model as reaching join step (simplification -- individual branch paths are internal)
          - When step has no next (terminal): record current path as FlowPath
          - Track visited steps to detect cycles -- if cycle detected, record path and stop (don't infinite loop)
          - If paths.len() >= MAX_PATHS: stop enumeration, set truncated=true
       d. Compute reachable_steps = union of all step IDs in all paths
       e. unreachable_steps = all declared step IDs - reachable_steps
       f. max_depth = max path depth across all paths

2. Update `lib.rs`: add `pub mod s6_flow_paths;` and re-export `S6Result`.

3. Unit tests:
   a. Linear flow (3 steps, no branching) -- one path enumerated
   b. Flow with OperationStep having 2 outcomes -- two paths
   c. Flow with BranchStep -- two paths (true/false)
   d. Flow with unreachable step -- detected in unreachable_steps
   e. Path count cap -- construct flow that would produce > MAX_PATHS, verify truncated=true
  </action>
  <verify>
    Run `cargo test -p tenor-analyze` -- S6 tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S6 enumerates all flow paths handling OperationStep outcomes, BranchStep, ParallelStep, and SubFlowStep. Path explosion bounded at 10,000. Unreachable steps detected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement S7 evaluation complexity bounds</name>
  <files>
    crates/analyze/src/s7_complexity.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s7_complexity.rs`:
   - Define `PredicateComplexity` struct (Debug, Clone, Serialize):
     - `source_id: String` -- rule or operation ID containing this predicate
     - `node_count: usize` -- total nodes in expression tree
     - `max_depth: usize` -- deepest nesting level
     - `has_quantifiers: bool` -- contains forall/exists-like constructs
     - `complexity_class: String` -- "O(1)", "O(n)", "O(n^2)", etc. based on structure

   - Define `FlowDepthBound` struct (Debug, Clone, Serialize):
     - `flow_id: String`
     - `max_path_depth: usize` -- from S6
     - `max_step_count: usize` -- total unique steps
     - `has_cycles: bool` -- whether the flow graph contains cycles

   - Define `S7Result` struct (Debug, Clone, Serialize):
     - `predicate_complexities: Vec<PredicateComplexity>` -- one per predicate expression
     - `flow_depth_bounds: BTreeMap<String, FlowDepthBound>` -- per flow
     - `max_predicate_depth: usize` -- deepest predicate expression across all constructs
     - `max_flow_depth: usize` -- deepest flow path across all flows

   - Implement `pub fn analyze_complexity(bundle: &AnalysisBundle, s6: &S6Result) -> S7Result`:
     - For each rule's predicate (rule.when):
       - Walk the expression JSON tree, counting nodes and tracking depth
       - Classify complexity: simple comparisons are O(1), nested And/Or are O(nodes), quantifiers (if any) are O(n)
     - For each operation precondition (if present):
       - Same tree walking and classification
     - For each flow in S6 results:
       - Extract max_path_depth from S6 FlowPathResult
       - Count total unique steps
       - Check for cycles (if any path revisits a step, has_cycles=true)

   - Helper `fn walk_expression_tree(expr: &serde_json::Value) -> (usize, usize)`:
     - Returns (node_count, max_depth)
     - Recursively walk: Compare, And, Or, Not, fact_ref, verdict_present, literal nodes

2. Update `lib.rs`: add `pub mod s7_complexity;` and re-export `S7Result`.

3. Unit tests:
   a. Simple comparison predicate -- node_count=1, depth=1, class="O(1)"
   b. Nested And with 3 children -- node_count=4, depth=2
   c. Flow with S6 result having max depth 5 -- verify FlowDepthBound reflects it
   d. Empty predicate (no rules) -- empty complexities list
  </action>
  <verify>
    Run `cargo test -p tenor-analyze` -- S7 tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S7 computes predicate expression complexity bounds and flow execution depth bounds. Complexity classification based on expression tree structure.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `cargo test -p tenor-analyze` -- S6 and S7 tests pass
3. S6 handles all step types and bounds path enumeration at 10,000
4. S7 correctly classifies predicate complexity and extracts flow depth from S6
5. All existing workspace tests pass
</verification>

<success_criteria>
- S6 enumerates all flow paths including outcome branching, branch steps, parallel steps
- S6 detects unreachable steps and truncates at 10,000 paths
- S7 computes predicate node counts, depths, and complexity classes
- S7 extracts flow depth bounds from S6 results
- Unit tests cover linear, branching, capped, and complex flows
</success_criteria>

<output>
After completion, create `.planning/phases/04-static-analysis/04-04-SUMMARY.md`
</output>
