---
phase: 04-static-analysis
plan: 08
type: execute
wave: 5
depends_on: [06]
files_modified:
  - crates/cli/src/diff.rs
  - crates/cli/src/main.rs
autonomous: true
requirements: [MIGR-03, MIGR-05]

must_haves:
  truths:
    - "`tenor diff --breaking` classifies each change using the CFFP-derived taxonomy from Section 17.2"
    - "Each diff entry is annotated with BREAKING, NON_BREAKING, or REQUIRES_ANALYSIS severity"
    - "REQUIRES_ANALYSIS changes that can be resolved by S1-S7 analysis are resolved to BREAKING or NON_BREAKING"
    - "Text output: summary table of changes by severity, then per-change details with migration actions"
    - "JSON output: full DiffEntry with severity annotations suitable for programmatic consumption"
  artifacts:
    - path: "crates/cli/src/diff.rs"
      provides: "Breaking change classifier and --breaking output formatting"
      contains: "fn classify_change"
    - path: "crates/cli/src/main.rs"
      provides: "--breaking flag on Diff subcommand"
      contains: "breaking"
  key_links:
    - from: "crates/cli/src/diff.rs"
      to: "tenor_analyze"
      via: "S1-S7 analysis for REQUIRES_ANALYSIS resolution"
      pattern: "tenor_analyze::analyze"
    - from: "crates/cli/src/diff.rs"
      to: "docs/TENOR.md Section 17.2"
      via: "Breaking change taxonomy lookup table"
      pattern: "classify_change"
---

<objective>
Implement `tenor diff --breaking` by adding breaking change classification to the existing diff infrastructure and optionally running S1-S7 analysis on both bundles to resolve REQUIRES_ANALYSIS entries.

Purpose: This is the migration tooling -- when contract authors change a contract, `tenor diff --breaking` tells them which changes are breaking, which are safe, and which need further analysis. The taxonomy from Section 17.2 provides the classification rules; S1-S7 can resolve some REQUIRES_ANALYSIS entries.

Output: Working `tenor diff --breaking` producing severity-annotated diff output in both text and JSON modes.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-static-analysis/04-RESEARCH.md
@.planning/phases/04-static-analysis/04-CONTEXT.md

@crates/cli/src/diff.rs
@crates/cli/src/main.rs
@docs/TENOR.md (Section 17.2 â€” breaking change taxonomy tables)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement breaking change taxonomy classifier</name>
  <files>
    crates/cli/src/diff.rs
  </files>
  <action>
1. Add severity types to `crates/cli/src/diff.rs`:
   - Define `ChangeSeverity` enum (Debug, Clone, PartialEq, Serialize):
     - `Breaking` -- change may invalidate existing behavior
     - `NonBreaking` -- change is safe
     - `RequiresAnalysis` -- needs S1-S7 to resolve
   - Define `ChangeClassification` struct (Debug, Clone, Serialize):
     - `severity: ChangeSeverity`
     - `reason: String` -- human-readable explanation from taxonomy
     - `migration_action: Option<String>` -- required migration action if breaking
   - Define `ClassifiedDiff` struct (Debug, Clone, Serialize):
     - `added: Vec<ClassifiedConstruct>` -- added constructs with severity
     - `removed: Vec<ClassifiedConstruct>` -- removed constructs with severity
     - `changed: Vec<ClassifiedChange>` -- changed constructs with per-field severity
     - `summary: ClassificationSummary`
   - Define `ClassifiedConstruct` struct: `kind`, `id`, `classification: ChangeClassification`
   - Define `ClassifiedChange` struct: `kind`, `id`, `fields: Vec<ClassifiedFieldDiff>`
   - Define `ClassifiedFieldDiff` struct: `field`, `before`, `after`, `classification: ChangeClassification`
   - Define `ClassificationSummary` struct: `breaking_count`, `non_breaking_count`, `requires_analysis_count`, `total_changes`

2. Implement `pub fn classify_diff(diff: &BundleDiff) -> ClassifiedDiff`:
   - For added constructs: apply add-construct rules from Section 17.2:
     - Fact added: NON_BREAKING
     - Entity added: NON_BREAKING
     - Rule added: REQUIRES_ANALYSIS (stratum-dependent)
     - Persona added: NON_BREAKING
     - Operation added: NON_BREAKING
     - Flow added: NON_BREAKING
   - For removed constructs: apply remove-construct rules:
     - Fact removed: BREAKING (referenced by rules/operations)
     - Entity removed: BREAKING (operations with effects on this entity)
     - Rule removed: BREAKING (verdicts no longer produced)
     - Persona removed: BREAKING (referenced in allowed_personas)
     - Operation removed: BREAKING (referenced in flow steps)
     - Flow removed: BREAKING (SubFlowSteps, in-flight instances)
   - For changed constructs, per field: implement `fn classify_field_change(kind: &str, field: &str, before: &Value, after: &Value) -> ChangeClassification`:
     - Match on (kind, field) pairs using the taxonomy tables from Section 17.2.1-17.2.6
     - Key classifications:
       - (Entity, states): add=NON_BREAKING, remove=BREAKING
       - (Entity, initial): BREAKING
       - (Entity, transitions): add=NON_BREAKING, remove=BREAKING
       - (Fact, type): widen=NON_BREAKING, narrow=BREAKING, base_type_change=BREAKING
       - (Fact, default): add=NON_BREAKING, remove=BREAKING, change=REQUIRES_ANALYSIS
       - (Rule, stratum): BREAKING
       - (Rule, body.when): REQUIRES_ANALYSIS
       - (Rule, body.produce.verdict_type): BREAKING
       - (Operation, allowed_personas): add=NON_BREAKING, remove=BREAKING
       - (Operation, precondition): REQUIRES_ANALYSIS
       - (Operation, effects): add=NON_BREAKING, remove=BREAKING, change=BREAKING
       - (Operation, outcomes): add=BREAKING, remove=BREAKING
       - (Flow, entry): BREAKING
       - (Flow, steps): add=REQUIRES_ANALYSIS, remove=BREAKING, change=BREAKING
       - provenance/tenor/kind fields: NON_BREAKING or N/A
     - For type widen/narrow detection (Fact type changes):
       - Enum: if after is superset of before = widen (NON_BREAKING); if before has values not in after = narrow (BREAKING)
       - Int: if after range contains before range = widen; otherwise narrow
       - Other: base type change = BREAKING
   - Compute summary counts

3. Add methods to ClassifiedDiff:
   - `fn to_json(&self) -> serde_json::Value` -- full JSON serialization
   - `fn to_text(&self) -> String` -- human-readable output:
     - Summary line: "N changes: X breaking, Y non-breaking, Z requires analysis"
     - Per-severity sections listing each change with reason
     - Migration actions for breaking changes
  </action>
  <verify>
    Run `cargo build --workspace` -- compiles.
    Add unit tests in diff.rs for classify_field_change with key taxonomy entries.
    Run `cargo test --workspace` -- passes.
  </verify>
  <done>
    Breaking change taxonomy fully implemented as a pure classification function. All (kind, field, change_type) triples from Section 17.2 covered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --breaking flag into tenor diff CLI</name>
  <files>
    crates/cli/src/main.rs
  </files>
  <action>
1. Update the Diff subcommand in `crates/cli/src/main.rs`:
   - Add `--breaking` flag:
     ```
     Diff {
         t1: PathBuf,
         t2: PathBuf,
         /// Classify changes as breaking/non-breaking using Section 17.2 taxonomy
         #[arg(long)]
         breaking: bool,
     },
     ```
   - Update the match arm to pass `breaking` to cmd_diff:
     ```
     Commands::Diff { t1, t2, breaking } => {
         cmd_diff(&t1, &t2, breaking, cli.output, cli.quiet);
     }
     ```

2. Update `cmd_diff` to accept `breaking: bool` parameter:
   - After computing the diff, if `breaking` is true:
     a. Classify the diff: `let classified = diff::classify_diff(&bundle_diff);`
     b. Optionally run S1-S7 analysis on both bundles to resolve REQUIRES_ANALYSIS entries:
        - Parse both bundle JSONs
        - Run `tenor_analyze::analyze()` on each
        - For REQUIRES_ANALYSIS entries, check if analysis can resolve:
          - Fact type changes: compare S1 state spaces (does removed state have live entities?)
          - Rule predicate changes: check S2/S3a for reachability impact
          - Flow step changes: check S6 for path impact
        - NOTE: this is a best-effort resolution. Some REQUIRES_ANALYSIS entries genuinely cannot be resolved by S1-S7 alone.
     c. Output classified diff:
        - JSON mode: `classified.to_json()`
        - Text mode: `classified.to_text()`
     d. Exit code:
        - 0 if no breaking changes
        - 1 if any breaking changes (or unresolved REQUIRES_ANALYSIS)
   - If `breaking` is false: existing behavior (structural diff only)

3. Unit tests:
   - Test classify_diff with a BundleDiff containing added, removed, and changed constructs
   - Verify correct severity assignments per taxonomy
  </action>
  <verify>
    Run `cargo build --workspace` -- compiles.
    Generate two interchange bundles with known differences and run `tenor diff --breaking` on them.
    Verify text output shows severity classifications.
    Verify JSON output contains classification data.
    Run `cargo test --workspace` -- passes.
  </verify>
  <done>
    `tenor diff --breaking` classifies all changes per Section 17.2 taxonomy, optionally resolves REQUIRES_ANALYSIS via S1-S7, and produces severity-annotated output in both modes.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `tenor diff t1.json t2.json` still works without --breaking (no regression)
3. `tenor diff --breaking t1.json t2.json` produces severity-classified output
4. JSON output contains BREAKING/NON_BREAKING/REQUIRES_ANALYSIS per change
5. Text output has summary table and per-change details
6. Classification matches Section 17.2 taxonomy for key test cases
7. All existing tests pass
</verification>

<success_criteria>
- --breaking flag added to diff subcommand
- classify_diff implements full Section 17.2 taxonomy
- Type widen/narrow detection for Enum and Int fields
- Text output: severity summary + per-change details + migration actions
- JSON output: full ClassifiedDiff serialization
- Exit code 0 for no breaking changes, 1 for breaking changes
- Unit tests verify taxonomy classification for key entries
</success_criteria>

<output>
After completion, create `.planning/phases/04-static-analysis/04-08-SUMMARY.md`
</output>
