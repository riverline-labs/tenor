---
phase: 04-static-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/analyze/Cargo.toml
  - crates/analyze/src/lib.rs
  - crates/analyze/src/bundle.rs
  - crates/analyze/src/s1_state_space.rs
autonomous: true
requirements: [ANLZ-01]

must_haves:
  truths:
    - "tenor-analyze crate compiles with serde, serde_json, and tenor-core dependencies"
    - "Bundle deserialization extracts Entity, Fact, Rule, Operation, Flow, and Persona constructs from interchange JSON"
    - "S1 analysis enumerates the complete set of declared states for every Entity in the bundle"
    - "S1 result is a Rust struct with serde Serialize, returning Map<EntityId, Vec<State>> plus the initial state per entity"
    - "S1 correctly handles entities with zero transitions, single state, and complex multi-state machines"
  artifacts:
    - path: "crates/analyze/src/bundle.rs"
      provides: "Bundle deserialization from interchange JSON into typed analysis structs"
      contains: "pub fn from_interchange"
    - path: "crates/analyze/src/s1_state_space.rs"
      provides: "S1 entity state space enumeration"
      contains: "pub fn analyze_state_space"
    - path: "crates/analyze/src/lib.rs"
      provides: "Module declarations and public API re-exports"
      contains: "pub mod s1_state_space"
  key_links:
    - from: "crates/analyze/src/bundle.rs"
      to: "serde_json::Value"
      via: "interchange JSON deserialization"
      pattern: "from_interchange"
    - from: "crates/analyze/src/s1_state_space.rs"
      to: "crates/analyze/src/bundle.rs"
      via: "Entity struct consumption"
      pattern: "AnalysisBundle"
---

<objective>
Set up the tenor-analyze crate with interchange JSON deserialization and implement S1 (Complete State Space) analysis.

Purpose: Establishes the analysis crate foundation that all subsequent S2-S7 analyses build upon. The bundle deserialization layer is the shared infrastructure -- every analysis module consumes the same typed structs extracted from interchange JSON.

Output: A compiling tenor-analyze crate with bundle deserialization and S1 analysis producing `Map<EntityId, StateSpaceResult>` where each result contains declared states, initial state, and transitions.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-static-analysis/04-RESEARCH.md
@.planning/phases/04-static-analysis/04-CONTEXT.md

@crates/analyze/Cargo.toml
@crates/analyze/src/lib.rs
@crates/eval/src/lib.rs
@crates/eval/src/types.rs
@docs/interchange-schema.json
@conformance/positive/integration_escrow.tenor
@conformance/positive/entity_basic.tenor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up tenor-analyze crate dependencies and bundle deserialization</name>
  <files>
    crates/analyze/Cargo.toml
    crates/analyze/src/lib.rs
    crates/analyze/src/bundle.rs
  </files>
  <action>
1. Update `crates/analyze/Cargo.toml`:
   - Add `serde = { workspace = true }` and `serde_json = { workspace = true }` to `[dependencies]`

2. Create `crates/analyze/src/bundle.rs` -- interchange JSON deserialization into typed analysis structs:
   - Define `AnalysisBundle` struct containing: `entities: Vec<AnalysisEntity>`, `facts: Vec<AnalysisFact>`, `rules: Vec<AnalysisRule>`, `operations: Vec<AnalysisOperation>`, `flows: Vec<AnalysisFlow>`, `personas: Vec<AnalysisPersona>`
   - `AnalysisEntity`: `id: String`, `states: Vec<String>`, `initial: String`, `transitions: Vec<Transition>`, `parent: Option<String>`
   - `Transition`: `from: String`, `to: String`
   - `AnalysisFact`: `id: String`, `fact_type: serde_json::Value` (preserve raw type for S3a analysis)
   - `AnalysisRule`: `id: String`, `stratum: u64`, `when: serde_json::Value` (raw predicate expr), `produce_verdict_type: String`, `produce_payload: serde_json::Value`
   - `AnalysisOperation`: `id: String`, `allowed_personas: Vec<String>`, `precondition: Option<serde_json::Value>`, `effects: Vec<Effect>`, `outcomes: Vec<String>`, `error_contract: Option<serde_json::Value>`
   - `Effect`: `entity_id: String`, `from_state: String`, `to_state: String`, `outcome: Option<String>`
   - `AnalysisFlow`: `id: String`, `entry: String`, `steps: Vec<serde_json::Value>` (raw steps for S6 path enumeration), `snapshot: String`
   - `AnalysisPersona`: `id: String`
   - Implement `AnalysisBundle::from_interchange(bundle: &serde_json::Value) -> Result<Self, AnalysisError>`:
     - Extract `constructs` array from bundle
     - Iterate constructs, dispatch on `kind` field to parse each construct type
     - For Entity: extract `states`, `initial`, `transitions` arrays
     - For Fact: extract `id` and `type`
     - For Rule: extract `id`, `stratum`, `body.when`, `body.produce.verdict_type`, `body.produce.payload`
     - For Operation: extract `id`, `allowed_personas`, `precondition`, `effects`, `outcomes`, `error_contract`
     - For Flow: extract `id`, `entry`, `steps`, `snapshot`
     - For Persona: extract `id`
     - Unknown kinds: skip (future-proof)
   - Define `AnalysisError` enum: `InvalidBundle(String)`, `MissingField { construct: String, field: String }`
   - All structs derive `Debug, Clone, serde::Serialize`

3. Update `crates/analyze/src/lib.rs`:
   - Add module declarations: `pub mod bundle;`
   - Re-export: `pub use bundle::{AnalysisBundle, AnalysisError};`
  </action>
  <verify>
    Run `cargo build -p tenor-analyze` -- must compile without errors.
    Run `cargo test --workspace` -- all existing tests must pass (no regressions).
  </verify>
  <done>
    tenor-analyze crate compiles with bundle deserialization. All construct types parsed from interchange JSON into typed structs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement S1 entity state space enumeration with unit tests</name>
  <files>
    crates/analyze/src/s1_state_space.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s1_state_space.rs`:
   - Define `StateSpaceResult` struct (derives `Debug, Clone, Serialize`):
     - `entity_id: String`
     - `declared_states: Vec<String>` (all states from entity.states)
     - `initial_state: String`
     - `transitions: Vec<(String, String)>` (from, to pairs)
     - `state_count: usize`
   - Define `S1Result` struct (derives `Debug, Clone, Serialize`):
     - `entities: BTreeMap<String, StateSpaceResult>` (keyed by entity ID for deterministic output)
   - Implement `pub fn analyze_state_space(bundle: &AnalysisBundle) -> S1Result`:
     - For each entity in `bundle.entities`:
       - Build `StateSpaceResult` from entity fields
       - Insert into BTreeMap keyed by entity.id
     - Return `S1Result { entities }`
   - This is a straightforward extraction (Section 15 S1: "the complete set of states S(e) is enumerable")

2. Update `crates/analyze/src/lib.rs`:
   - Add `pub mod s1_state_space;`
   - Re-export: `pub use s1_state_space::{S1Result, StateSpaceResult};`

3. Add unit tests in `s1_state_space.rs`:
   - Test with a manually constructed AnalysisBundle containing:
     a. Single entity with 3 states, 2 transitions -- verify all states enumerated, initial correct
     b. Multiple entities -- verify each entity has its own StateSpaceResult
     c. Entity with single state and no transitions -- verify state_count=1
   - Use `#[cfg(test)] mod tests` pattern
  </action>
  <verify>
    Run `cargo build -p tenor-analyze` -- compiles.
    Run `cargo test -p tenor-analyze` -- S1 unit tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S1 analysis correctly enumerates entity state spaces. Unit tests cover single entity, multiple entities, and degenerate (single state) cases.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `cargo test -p tenor-analyze` -- S1 unit tests pass
3. `cargo test --workspace` -- all existing tests pass (no regressions)
4. S1 result is a serializable struct with BTreeMap<EntityId, StateSpaceResult>
</verification>

<success_criteria>
- tenor-analyze crate compiles with serde, serde_json, tenor-core dependencies
- Bundle deserialization extracts all construct types from interchange JSON
- S1 enumerates all declared states for each entity
- S1 result struct is serializable via serde
- Unit tests cover basic, multi-entity, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-static-analysis/04-01-SUMMARY.md`
</output>
