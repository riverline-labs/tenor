---
phase: 04-static-analysis
plan: 05
type: execute
wave: 2
depends_on: [01]
files_modified:
  - crates/analyze/src/s8_verdict_uniqueness.rs
  - crates/analyze/src/report.rs
  - crates/analyze/src/lib.rs
autonomous: true
requirements: [ANLZ-08]

must_haves:
  truths:
    - "S8 reports verdict uniqueness as pre-verified by Pass 5 of the elaborator"
    - "AnalysisReport aggregates all S1-S8 results into a single structured output"
    - "AnalysisReport is serializable via serde for both JSON and text consumption"
    - "Public API: analyze(bundle: &Value) -> Result<AnalysisReport, AnalysisError> as the top-level entry point"
  artifacts:
    - path: "crates/analyze/src/s8_verdict_uniqueness.rs"
      provides: "S8 verdict uniqueness confirmation (pre-verified)"
      contains: "pub fn confirm_verdict_uniqueness"
    - path: "crates/analyze/src/report.rs"
      provides: "AnalysisReport aggregating all analysis results"
      contains: "pub struct AnalysisReport"
    - path: "crates/analyze/src/lib.rs"
      provides: "Top-level analyze() public API"
      contains: "pub fn analyze"
  key_links:
    - from: "crates/analyze/src/lib.rs"
      to: "all s*_ modules"
      via: "analyze() orchestrates all analyses"
      pattern: "analyze_state_space"
---

<objective>
Implement S8 (Verdict Uniqueness) confirmation and the AnalysisReport aggregation layer with the top-level `analyze()` API.

Purpose: S8 is trivial (pre-verified by Pass 5), but the AnalysisReport and `analyze()` entry point are critical infrastructure -- they aggregate all S1-S7 results into the structured output that `tenor check` consumes. This plan creates the orchestration layer that ties all analyses together.

Output: S8 confirmation module, AnalysisReport struct, and `analyze(bundle) -> AnalysisReport` entry point.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-static-analysis/04-RESEARCH.md
@.planning/phases/04-static-analysis/04-CONTEXT.md

@crates/analyze/src/lib.rs
@crates/analyze/src/bundle.rs
@crates/analyze/src/s1_state_space.rs
@crates/eval/src/lib.rs (pattern reference for top-level API design)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement S8 verdict uniqueness confirmation and AnalysisReport aggregation</name>
  <files>
    crates/analyze/src/s8_verdict_uniqueness.rs
    crates/analyze/src/report.rs
    crates/analyze/src/lib.rs
  </files>
  <action>
1. Create `crates/analyze/src/s8_verdict_uniqueness.rs`:
   - Define `S8Result` struct (Debug, Clone, Serialize):
     - `pre_verified: bool` -- always true (Pass 5 enforces this)
     - `note: String` -- "Verdict uniqueness enforced during elaboration (Pass 5)"
   - Implement `pub fn confirm_verdict_uniqueness() -> S8Result`:
     - Return S8Result { pre_verified: true, note: "..." }
     - No analysis needed -- this is a confirmation that the elaborator already checks this

2. Create `crates/analyze/src/report.rs`:
   - Define `AnalysisReport` struct (Debug, Clone, Serialize):
     - `s1_state_space: Option<S1Result>`
     - `s2_reachability: Option<S2Result>`
     - `s3a_admissibility: Option<S3aResult>`
     - `s4_authority: Option<S4Result>`
     - `s5_verdicts: Option<S5Result>`
     - `s6_flow_paths: Option<S6Result>`
     - `s7_complexity: Option<S7Result>`
     - `s8_verdict_uniqueness: Option<S8Result>`
     - `analyses_run: Vec<String>` -- list of analyses that were run (e.g., ["s1", "s2", ...])
     - `findings: Vec<Finding>` -- aggregated notable findings across all analyses
   - Define `Finding` struct (Debug, Clone, Serialize):
     - `analysis: String` -- which analysis produced this finding (e.g., "s2")
     - `severity: FindingSeverity` -- Info, Warning
     - `message: String`
     - `entity_id: Option<String>` -- optional construct context
     - `details: Option<serde_json::Value>` -- optional structured details
   - Define `FindingSeverity` enum (Debug, Clone, Serialize): Info, Warning
   - Implement `AnalysisReport::new() -> Self` -- all fields None/empty
   - Implement methods to extract findings:
     - `fn extract_findings(&mut self)` -- populate `findings` from analysis results:
       - S2: if has_dead_states, add Warning finding per entity with dead states
       - S6: if any flow truncated, add Warning finding
       - S6: if any flow has unreachable steps, add Info finding
       - S7: if max_flow_depth > 100, add Warning about deep flow
     - Additional findings can be added in future

3. Update `crates/analyze/src/lib.rs`:
   - Add module declarations for s8_verdict_uniqueness and report
   - Implement `pub fn analyze(bundle: &serde_json::Value) -> Result<AnalysisReport, AnalysisError>`:
     - Deserialize bundle: `AnalysisBundle::from_interchange(bundle)?`
     - Run all analyses in sequence (they depend on each other):
       a. s1 = analyze_state_space(&analysis_bundle)
       b. s2 = analyze_reachability(&analysis_bundle)
       c. s3a = analyze_admissibility(&analysis_bundle)
       d. s4 = analyze_authority(&analysis_bundle, &s3a)
       e. s5 = analyze_verdict_space(&analysis_bundle)
       f. s6 = analyze_flow_paths(&analysis_bundle, &s5)
       g. s7 = analyze_complexity(&analysis_bundle, &s6)
       h. s8 = confirm_verdict_uniqueness()
     - Build AnalysisReport with all results
     - Call extract_findings()
     - Return report
   - Also implement `pub fn analyze_selected(bundle: &serde_json::Value, analyses: &[&str]) -> Result<AnalysisReport, AnalysisError>`:
     - Same as analyze() but only run selected analyses
     - Handle dependencies: if s4 requested, s3a must also run; if s6 requested, s5 must also run; etc.
     - Only populate selected analysis fields in the report
   - Re-export: `pub use report::{AnalysisReport, Finding, FindingSeverity};`
   - Re-export: `pub use s8_verdict_uniqueness::S8Result;`

4. Unit tests:
   a. S8 always returns pre_verified=true
   b. AnalysisReport::new() has all None fields
   c. extract_findings() generates findings from S2 dead states
  </action>
  <verify>
    Run `cargo build -p tenor-analyze` -- compiles.
    Run `cargo test -p tenor-analyze` -- all tests pass.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    S8 confirmation module, AnalysisReport aggregation, findings extraction, and top-level analyze() API all working. analyze_selected() supports partial analysis runs.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `cargo test -p tenor-analyze` -- all tests pass including S8 and report tests
3. `analyze()` produces a complete AnalysisReport with all S1-S8 results
4. `analyze_selected()` only runs requested analyses (with dependencies)
5. Findings extracted from analysis results (dead states, truncated paths, etc.)
</verification>

<success_criteria>
- S8 confirms verdict uniqueness as pre-verified by Pass 5
- AnalysisReport aggregates all S1-S8 results
- analyze() runs full analysis suite and returns AnalysisReport
- analyze_selected() supports partial analysis runs
- Findings extracted from notable analysis results
- All results serializable via serde
</success_criteria>

<output>
After completion, create `.planning/phases/04-static-analysis/04-05-SUMMARY.md`
</output>
