---
phase: 03-cli-evaluator
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/eval/Cargo.toml
  - crates/eval/src/lib.rs
  - crates/eval/src/types.rs
  - crates/eval/src/numeric.rs
  - crates/eval/src/assemble.rs
  - crates/eval/src/predicate.rs
  - crates/eval/src/rules.rs
  - crates/eval/src/provenance.rs
autonomous: true
requirements: [EVAL-01, EVAL-04]

must_haves:
  truths:
    - "Evaluator deserializes an interchange bundle into internal Contract representation"
    - "Evaluator assembles a FactSet from facts.json, type-checking each fact against its declared type"
    - "Missing facts with defaults use the contract default; missing facts without defaults abort with error"
    - "Stratified rule evaluation produces verdicts in correct stratum order"
    - "Predicate expressions (comparisons, logical ops, fact refs, verdict refs) evaluate correctly"
    - "All numeric arithmetic uses rust_decimal with MidpointNearestEven rounding, never f64"
    - "Int-to-Decimal promotion follows spec Section 12.2 rules"
  artifacts:
    - path: "crates/eval/src/types.rs"
      provides: "Runtime Value enum, FactSet, VerdictSet, VerdictInstance, Contract types"
      contains: "enum Value"
    - path: "crates/eval/src/numeric.rs"
      provides: "NumericModel implementation with rust_decimal"
      contains: "MidpointNearestEven"
    - path: "crates/eval/src/assemble.rs"
      provides: "FactSet assembly from facts.json with type checking"
      contains: "assemble_facts"
    - path: "crates/eval/src/predicate.rs"
      provides: "PredicateExpression evaluator"
      contains: "eval_pred"
    - path: "crates/eval/src/rules.rs"
      provides: "Stratified rule evaluation"
      contains: "eval_strata"
    - path: "crates/eval/src/provenance.rs"
      provides: "Provenance chain construction types"
      contains: "VerdictProvenance"
  key_links:
    - from: "crates/eval/src/rules.rs"
      to: "crates/eval/src/predicate.rs"
      via: "eval_pred called for rule conditions"
      pattern: "eval_pred"
    - from: "crates/eval/src/predicate.rs"
      to: "crates/eval/src/numeric.rs"
      via: "numeric comparison and arithmetic"
      pattern: "numeric::"
    - from: "crates/eval/src/assemble.rs"
      to: "crates/eval/src/types.rs"
      via: "Value construction from JSON"
      pattern: "Value::"
---

<objective>
Implement the evaluator core in `tenor-eval`: runtime value types, fixed-point numeric model, fact assembly, predicate expression evaluation, and stratified rule evaluation with provenance tracking.

Purpose: This is the evaluation engine that converts interchange bundles + fact sets into verdicts. It implements the spec's evaluation model (Sections 5, 7, 10, 12) as a tree-walker over deserialized interchange JSON.
Output: A `tenor-eval` crate with public `evaluate()` function that can evaluate rules against facts and produce provenance-traced verdicts. Operations and Flows are deferred to plan 03-03.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-evaluator/03-RESEARCH.md

@docs/TENOR.md (Sections 5, 7, 10, 12, 14 -- Fact, Rule, PredicateExpression, NumericModel, Evaluation Model)
@docs/interchange-schema.json
@crates/eval/src/lib.rs
@crates/eval/Cargo.toml
@crates/core/src/ast.rs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Define evaluator types and numeric model</name>
  <files>
    crates/eval/Cargo.toml
    crates/eval/src/lib.rs
    crates/eval/src/types.rs
    crates/eval/src/numeric.rs
    crates/eval/src/provenance.rs
  </files>
  <action>
**Cargo.toml:** Add dependencies:
```toml
[dependencies]
tenor-core = { path = "../core" }
serde = { workspace = true }
serde_json = { workspace = true }
rust_decimal = { version = "1.36", features = ["serde-with-str"] }

[dev-dependencies]
serde_json = { workspace = true }
```
Add `rust_decimal` to workspace dependencies in root `Cargo.toml` if not already present.

**types.rs:** Define evaluator runtime types. These are DISTINCT from tenor-core AST types -- the evaluator consumes interchange JSON, not raw DSL.

```rust
// Runtime value types (from spec Section 4 BaseType):
pub enum Value {
    Bool(bool),
    Int(i64),
    Decimal(rust_decimal::Decimal),
    Text(String),
    Date(String),           // ISO 8601
    DateTime(String),       // ISO 8601
    Money { amount: rust_decimal::Decimal, currency: String },
    Duration { value: i64, unit: String },
    Enum(String),
    Record(BTreeMap<String, Value>),
    List(Vec<Value>),
    TaggedUnion { tag: String, payload: Box<Value> },
}

// Contract representation deserialized from interchange JSON
pub struct Contract {
    pub facts: Vec<FactDecl>,
    pub entities: Vec<Entity>,
    pub rules: Vec<Rule>,
    pub operations: Vec<Operation>,
    pub flows: Vec<Flow>,
    pub personas: Vec<String>,
}

pub struct FactDecl {
    pub id: String,
    pub fact_type: TypeSpec,
    pub default: Option<Value>,
}

pub struct TypeSpec {
    pub kind: String,       // "Int", "Decimal", "Money", "Bool", "Text", "Date", "DateTime", "Duration", "Enum", "Record", "List", "TaggedUnion"
    pub precision: Option<u32>,
    pub scale: Option<u32>,
    pub currency: Option<String>,
    pub variants: Option<Vec<String>>,  // For Enum
    pub fields: Option<Vec<FieldSpec>>, // For Record
    pub element_type: Option<Box<TypeSpec>>, // For List
    pub max_length: Option<u32>,        // For List
}

// ... Entity, Rule, Operation, Flow, Step, etc. -- all deserialized from interchange JSON
// Rule should carry stratum, condition (predicate tree), and produce clause
// Predicate trees are nested structures: Compare, And, Or, Not, FactRef, VerdictRef, Literal, Mul

pub struct FactSet(pub BTreeMap<String, Value>);
pub struct VerdictSet(pub Vec<VerdictInstance>);

pub struct VerdictInstance {
    pub verdict_type: String,
    pub payload: Value,
    pub provenance: VerdictProvenance,
}
```

**numeric.rs:** Implement NumericModel from spec Section 12:
- `promote_int_to_decimal(val: i64, target: &TypeSpec) -> Decimal` -- convert Int to Decimal with appropriate precision/scale
- `eval_mul(left: Decimal, right: Decimal, result_precision: u32, result_scale: u32) -> Result<Decimal, EvalError>` -- multiply with overflow check
- `compare_values(left: &Value, right: &Value, op: &str, comparison_type: Option<&TypeSpec>) -> Result<bool, EvalError>` -- type-directed comparison with promotion
- All arithmetic uses `rust_decimal::Decimal` with `RoundingStrategy::MidpointNearestEven`
- NO `f64` anywhere in the evaluation path
- Overflow results in `EvalError::Overflow`

**provenance.rs:** Define provenance types:
```rust
pub struct VerdictProvenance {
    pub rule_id: String,
    pub stratum: u32,
    pub facts_used: Vec<String>,
    pub verdicts_used: Vec<String>,
}
```

**lib.rs:** Declare modules and re-export public types:
```rust
pub mod types;
pub mod numeric;
pub mod assemble;
pub mod predicate;
pub mod rules;
pub mod provenance;

pub use types::{Value, Contract, FactSet, VerdictSet, VerdictInstance, EvalError};
```

Write unit tests in each module covering:
- Value construction and equality
- Decimal arithmetic: multiplication, promotion, overflow detection
- MidpointNearestEven rounding correctness
- Int-to-Decimal promotion following spec Section 12.2
  </action>
  <verify>
`cargo build -p tenor-eval` compiles without errors.
`cargo test -p tenor-eval` passes all unit tests.
Grep for `f64` in crates/eval/src/ -- must find zero occurrences in evaluation logic (only in test assertions if any).
  </verify>
  <done>
Runtime Value type covers all spec BaseTypes. NumericModel uses rust_decimal exclusively with correct rounding. Provenance types defined. All unit tests pass.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Implement fact assembly and predicate evaluation</name>
  <files>
    crates/eval/src/assemble.rs
    crates/eval/src/predicate.rs
    crates/eval/src/types.rs
  </files>
  <action>
**Contract deserialization:** Add `Contract::from_interchange(bundle: &serde_json::Value) -> Result<Contract, EvalError>` to types.rs. This walks the interchange JSON and constructs the internal Contract representation. Extract facts, entities, rules, operations, flows, and personas from the `constructs` array. For each construct, match on `kind` field to determine type and deserialize fields.

**assemble.rs:** Implement `assemble_facts(contract: &Contract, facts_json: &serde_json::Value) -> Result<FactSet, EvalError>` following spec Section 5.2:

1. For each declared fact in contract.facts:
   - If fact_id exists in facts_json: parse value, type-check against declared type, insert into FactSet
   - If fact_id NOT in facts_json AND fact has default: use default value
   - If fact_id NOT in facts_json AND NO default: return `EvalError::MissingFact { fact_id }`
2. Type checking for fact values:
   - Bool: must be JSON boolean
   - Int: must be JSON integer
   - Decimal: must be JSON string parseable as Decimal
   - Money: must be JSON object with `amount` (string) and `currency` (string)
   - Text: must be JSON string
   - Enum: must be JSON string matching one of declared variants
   - List: JSON array, each element type-checked, length <= max_length
   - Record: JSON object with all declared fields present and correctly typed
3. Extra facts in facts_json that are not declared in contract: ignore (not an error)

**predicate.rs:** Implement `eval_pred(pred: &Predicate, facts: &FactSet, verdicts: &VerdictSet) -> Result<Value, EvalError>`:

The predicate tree is a recursive structure. Node types:
- `FactRef(id)` -> look up in FactSet, return Value
- `VerdictRef(id)` -> look up in VerdictSet (most recent verdict of that type), return payload
- `Literal(value)` -> return the literal Value
- `Compare { left, op, right, comparison_type }` -> evaluate left and right recursively, then compare using numeric::compare_values with the comparison_type for promotion context
- `Mul { left, literal, result_type }` -> evaluate left, multiply by literal using numeric::eval_mul
- `And(children)` -> all children must evaluate to Bool(true)
- `Or(children)` -> at least one child must evaluate to Bool(true)
- `Not(child)` -> negate Bool result
- `FieldAccess { value, field }` -> evaluate value (must be Record), extract field
- `ListAll { list, predicate }` -> evaluate list (must be List), check predicate holds for all elements
- `ListAny { list, predicate }` -> evaluate list, check predicate holds for at least one element

Write unit tests covering:
- Fact assembly with valid/invalid/missing facts
- Default value fallback
- Type checking for each BaseType
- Predicate evaluation: simple comparisons, logical operators, nested expressions
- FactRef and VerdictRef resolution
  </action>
  <verify>
`cargo test -p tenor-eval` passes all unit tests including fact assembly and predicate evaluation tests.
Test at least: missing fact with default, missing fact without default (error), type mismatch (error), simple comparison, nested And/Or, FactRef lookup.
  </verify>
  <done>
Contract deserializes from interchange JSON. FactSet assembly type-checks all values against declarations. Predicate evaluator handles all node types. Unit tests cover happy paths and error cases.
  </done>
</task>

<task type="tdd">
  <name>Task 3: Implement stratified rule evaluation</name>
  <files>
    crates/eval/src/rules.rs
    crates/eval/src/lib.rs
  </files>
  <action>
**rules.rs:** Implement `eval_strata(contract: &Contract, facts: &FactSet) -> Result<VerdictSet, EvalError>` following spec Section 7.4:

1. Determine max stratum from all rules
2. For stratum 0 to max_stratum:
   a. Collect all rules at current stratum
   b. For each rule, evaluate its condition predicate against current facts + accumulated verdicts
   c. If condition is true, compute the verdict payload from the produce clause
   d. Add VerdictInstance to VerdictSet with provenance tracking:
      - rule_id: the rule's id
      - stratum: current stratum number
      - facts_used: collect all fact refs encountered during predicate evaluation
      - verdicts_used: collect all verdict refs encountered during predicate evaluation
3. Rules at the same stratum are independent -- evaluation order within a stratum does not matter
4. Higher stratum rules CAN reference verdicts produced by lower strata

**Provenance tracking:** During predicate evaluation, track which facts and verdicts are accessed. Pass a `&mut ProvenanceCollector` through eval_pred that records each FactRef and VerdictRef access. After successful evaluation, extract the collected refs into VerdictProvenance.

**Public API in lib.rs:** Export the top-level evaluate function:
```rust
pub fn evaluate(
    bundle: &serde_json::Value,
    facts: &serde_json::Value,
) -> Result<EvalResult, EvalError> {
    let contract = Contract::from_interchange(bundle)?;
    let fact_set = assemble_facts(&contract, facts)?;
    let verdict_set = eval_strata(&contract, &fact_set)?;
    Ok(EvalResult { verdicts: verdict_set })
}

pub struct EvalResult {
    pub verdicts: VerdictSet,
}
```

Note: This evaluate() function handles rules-only evaluation. Operation and Flow execution will be added in plan 03-03.

**Verdict output serialization:** Add `VerdictSet::to_json(&self) -> serde_json::Value` that produces the verdict output format:
```json
{
  "verdicts": [
    {
      "type": "verdict_name",
      "payload": { ... },
      "provenance": {
        "rule": "rule_id",
        "stratum": 0,
        "facts_used": ["fact1", "fact2"],
        "verdicts_used": []
      }
    }
  ]
}
```

Write unit tests covering:
- Single-stratum evaluation (all rules at stratum 0)
- Multi-stratum evaluation (stratum 1 rules referencing stratum 0 verdicts)
- Rule condition false -> no verdict produced
- Provenance correctly tracks facts_used and verdicts_used
- Empty rule set -> empty verdict set
  </action>
  <verify>
`cargo test -p tenor-eval` passes all unit tests.
Test stratified evaluation with at least 2 strata.
Verify provenance tracking records correct fact and verdict references.
`cargo build --workspace` succeeds.
  </verify>
  <done>
Stratified rule evaluation produces correct verdicts in stratum order. Provenance chains track facts_used and verdicts_used. Public `evaluate()` API accepts interchange bundle + facts JSON and returns verdict set. Multi-stratum evaluation correctly allows higher strata to reference lower strata verdicts.
  </done>
</task>

</tasks>

<verification>
- `cargo build --workspace` compiles without errors or warnings
- `cargo test -p tenor-eval` passes all unit tests (types, numeric, assembly, predicate, rules)
- No `f64` in evaluation code paths
- `evaluate(bundle, facts)` returns correct verdicts for a hand-constructed test case
</verification>

<success_criteria>
- All evaluator core modules implemented: types, numeric, assemble, predicate, rules, provenance
- rust_decimal used exclusively for all numeric arithmetic
- FactSet assembly follows spec Section 5.2 type-checking semantics
- Stratified rule evaluation follows spec Section 7.4
- Provenance tracking records facts_used and verdicts_used per verdict
- Public evaluate() API works end-to-end for rules-only contracts
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-evaluator/03-02-SUMMARY.md`
</output>
