---
phase: 03-cli-evaluator
plan: 03
type: tdd
wave: 2
depends_on: [03-02]
files_modified:
  - crates/eval/src/operation.rs
  - crates/eval/src/flow.rs
  - crates/eval/src/lib.rs
  - crates/eval/src/types.rs
autonomous: true
requirements: [EVAL-02, EVAL-03]

must_haves:
  truths:
    - "Operations check persona authorization and preconditions before executing effects"
    - "Operation execution applies entity state transitions and returns outcome labels"
    - "Multi-outcome Operations route through effect-to-outcome mapping"
    - "Flows take an immutable snapshot of FactSet + VerdictSet at initiation"
    - "All Flow steps evaluate against the frozen snapshot, not recomputed state"
    - "Entity state changes during Flow execution do NOT trigger verdict re-evaluation"
    - "Sub-flows inherit the parent Flow's frozen snapshot"
    - "Every verdict and operation result carries a complete derivation chain"
  artifacts:
    - path: "crates/eval/src/operation.rs"
      provides: "Operation execution with persona check, preconditions, effects, outcome routing"
      contains: "execute_operation"
    - path: "crates/eval/src/flow.rs"
      provides: "Flow execution with frozen verdict snapshot"
      contains: "execute_flow"
  key_links:
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/operation.rs"
      via: "OperationStep calls execute_operation"
      pattern: "execute_operation"
    - from: "crates/eval/src/flow.rs"
      to: "crates/eval/src/types.rs"
      via: "Snapshot struct with immutable FactSet + VerdictSet"
      pattern: "Snapshot"
    - from: "crates/eval/src/operation.rs"
      to: "crates/eval/src/predicate.rs"
      via: "Precondition evaluation uses eval_pred"
      pattern: "eval_pred"
---

<objective>
Implement Operation execution and Flow execution with frozen verdict semantics in the `tenor-eval` crate. This completes the evaluator's write-path: Operations apply entity state transitions, and Flows orchestrate multi-step evaluation with immutable verdict snapshots.

Purpose: EVAL-03 (frozen verdict semantics) is only testable through Flow execution -- verdicts computed at flow initiation must remain unchanged even as entity state changes during the flow. This is the spec's key semantic commitment for deterministic evaluation.
Output: Complete evaluator capable of evaluating rules, executing operations, and orchestrating flows with provenance tracking throughout.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-evaluator/03-RESEARCH.md
@.planning/phases/03-cli-evaluator/03-02-SUMMARY.md

@docs/TENOR.md (Sections 9, 11, 14 -- Operation, Flow, Complete Evaluation Model)
@crates/eval/src/lib.rs
@crates/eval/src/types.rs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Implement Operation execution with persona, preconditions, effects, and outcomes</name>
  <files>
    crates/eval/src/operation.rs
    crates/eval/src/types.rs
  </files>
  <action>
**operation.rs:** Implement Operation execution following spec Section 9:

`execute_operation(op: &Operation, persona: &str, facts: &FactSet, verdicts: &VerdictSet, entity_states: &mut EntityStateMap) -> Result<OperationResult, OperationError>`

Execution steps (spec Section 9.2):
1. **Persona check:** Verify `persona` is in `op.allowed_personas`. If not, return `OperationError::PersonaRejected { operation_id, persona }`.
2. **Precondition check:** If operation has preconditions, evaluate each using `eval_pred` against current facts/verdicts. If any fails, return `OperationError::PreconditionFailed { operation_id, condition }`.
3. **Effect execution:** For each effect in the operation:
   - Look up target entity in entity_states
   - Verify current entity state matches the effect's `from_state`
   - Apply state transition to `to_state`
   - Record in provenance: entity_id, from_state, to_state
4. **Outcome determination:**
   - For single-outcome Operations: return the declared outcome label
   - For multi-outcome Operations: use effect-to-outcome mapping -- the outcome is determined by which effects were triggered (which depends on current entity state)
5. **Return:** `OperationResult { outcome: String, effects_applied: Vec<EffectRecord>, provenance: OperationProvenance }`

**OperationError variants:**
- `PersonaRejected { operation_id: String, persona: String }`
- `PreconditionFailed { operation_id: String, condition_desc: String }`
- `InvalidEntityState { entity_id: String, expected: String, actual: String }`
- `EntityNotFound { entity_id: String }`

**OperationProvenance:** Records entity state changes:
```rust
pub struct OperationProvenance {
    pub operation_id: String,
    pub persona: String,
    pub effects: Vec<EffectRecord>,
}
pub struct EffectRecord {
    pub entity_id: String,
    pub from_state: String,
    pub to_state: String,
}
```

**EntityStateMap:** `BTreeMap<String, String>` mapping entity_id to current state. Initialize from contract entity declarations (each entity starts in its declared initial state). Add to types.rs.

**types.rs additions:** Add Operation, Effect, Entity structs to Contract deserialization if not already complete. Add EntityStateMap type.

Write unit tests covering:
- Persona authorization: allowed persona succeeds, unauthorized persona fails
- Precondition evaluation: met precondition proceeds, unmet precondition fails
- Entity state transitions: valid transition succeeds, invalid from_state fails
- Multi-outcome routing with effect-to-outcome mapping
  </action>
  <verify>
`cargo test -p tenor-eval` passes all tests including operation execution tests.
Test at least: authorized persona + met precondition + valid state transition -> success, unauthorized persona -> PersonaRejected, invalid entity state -> InvalidEntityState.
  </verify>
  <done>
Operations execute with persona check, precondition evaluation, entity state transitions, and outcome determination. OperationProvenance records all state changes. Multi-outcome routing works via effect-to-outcome mapping.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Implement Flow execution with frozen verdict snapshot</name>
  <files>
    crates/eval/src/flow.rs
    crates/eval/src/lib.rs
    crates/eval/src/types.rs
  </files>
  <action>
**flow.rs:** Implement Flow execution following spec Section 11, with frozen verdict semantics from Section 11.4.

**Snapshot type:**
```rust
pub struct Snapshot {
    pub facts: FactSet,       // Immutable -- borrowed for lifetime of flow
    pub verdicts: VerdictSet,  // Immutable -- never recomputed during flow
}
```

The Snapshot MUST be borrowed immutably (`&Snapshot`). Entity state changes go to a SEPARATE mutable `EntityStateMap`. This separation is the key to frozen verdict semantics.

`execute_flow(flow: &Flow, persona: &str, snapshot: &Snapshot, entity_states: &mut EntityStateMap) -> Result<FlowResult, EvalError>`

Flow execution is a state machine walk:
1. Start at `flow.entry` step
2. At each step, match on step type:
   - **OperationStep:** Call `execute_operation(op, step.persona, &snapshot.facts, &snapshot.verdicts, entity_states)`. On Ok, route to `step.outcomes[&result.outcome]`. On Err, route to `step.on_failure` (if exists) or propagate error.
   - **BranchStep:** Evaluate condition predicate against FROZEN snapshot (not recomputed): `eval_pred(condition, &snapshot.facts, &snapshot.verdicts)`. Route to `if_true` or `if_false` step.
   - **SubFlowStep:** Recursively call `execute_flow(sub_flow, step.persona, snapshot, entity_states)`. Sub-flows INHERIT the parent snapshot per spec E5.
   - **TerminalStep:** Return the terminal outcome label.
3. Build FlowProvenance as an ordered list of StepRecords.

**FlowResult:**
```rust
pub struct FlowResult {
    pub outcome: String,
    pub steps_executed: Vec<StepRecord>,
    pub entity_state_changes: Vec<EffectRecord>,
}
pub struct StepRecord {
    pub step_id: String,
    pub step_type: String,  // "operation", "branch", "sub_flow", "terminal"
    pub result: String,      // outcome label or branch taken
}
```

**Update lib.rs evaluate() function:** Enhance to support full evaluation including flows. The evaluation model (spec Section 14):
1. Assemble facts
2. Evaluate rules (stratified) to produce verdicts
3. If contract has flows and a flow execution is requested, create Snapshot from current FactSet + VerdictSet, then execute flow

Add a new public API: `evaluate_flow(bundle: &Value, facts: &Value, flow_id: &str, persona: &str) -> Result<FlowEvalResult, EvalError>` which runs the full pipeline and then executes the named flow.

**Critical invariant to test:** After an OperationStep changes entity state during flow execution, subsequent BranchSteps MUST still see the ORIGINAL verdicts from the snapshot -- NOT verdicts recomputed with the new entity state. This is the frozen verdict semantic commitment.

Write unit tests covering:
- Simple flow: entry -> operation -> terminal
- Branch flow: entry -> branch -> (true: terminal_a, false: terminal_b)
- Frozen verdict test: flow where operation changes entity state, subsequent branch checks a verdict that would change if verdicts were recomputed -- verify the branch uses the frozen (original) verdict
- Sub-flow inherits parent snapshot
- OperationStep on_failure routing
  </action>
  <verify>
`cargo test -p tenor-eval` passes all tests including flow tests.
The frozen verdict test MUST be present and pass: create a scenario where entity state change WOULD change a verdict, verify the flow uses the original verdict.
`cargo build --workspace` succeeds.
  </verify>
  <done>
Flow execution uses immutable Snapshot for all step evaluation. Entity state changes are tracked separately in mutable EntityStateMap. Sub-flows inherit parent snapshot. Frozen verdict semantics verified by test case where post-operation entity state change does not affect verdict evaluation. Complete derivation chains built for all operations and flows.
  </done>
</task>

</tasks>

<verification>
- `cargo build --workspace` compiles without errors
- `cargo test -p tenor-eval` passes all tests
- Frozen verdict test explicitly demonstrates that entity state changes during flow do NOT affect verdict evaluation
- Operation execution handles persona rejection, precondition failure, and entity state mismatch
- Flow execution handles operation steps, branch steps, sub-flow steps, and terminal steps
</verification>

<success_criteria>
- Operation execution implements persona check, precondition eval, effect application, outcome routing
- Flow execution uses immutable Snapshot created at flow initiation
- Entity state is mutable during flow; verdicts are not
- Sub-flows inherit parent snapshot (not create new ones)
- Complete provenance chains: VerdictProvenance, OperationProvenance, FlowResult with StepRecords
- Frozen verdict semantics proven by test case
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-evaluator/03-03-SUMMARY.md`
</output>
