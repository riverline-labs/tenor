---
phase: 05-domain-validation
plan: 06
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
  - crates/cli/src/explain.rs
  - crates/cli/tests/cli_integration.rs
autonomous: true
requirements:
  - CLI-06

must_haves:
  truths:
    - "tenor explain <bundle.json> produces a human-readable 4-section contract summary"
    - "tenor explain <file.tenor> works by elaborating internally first"
    - "Default output is business-readable styled terminal text"
    - "--format markdown produces portable markdown output"
    - "--verbose adds technical details (types, entity states, rule strata)"
    - "Risk/coverage section includes analysis findings from S1-S8"
  artifacts:
    - path: "crates/cli/src/explain.rs"
      provides: "Explain command implementation with 4 sections: summary, narrative, inventory, risk"
      min_lines: 200
    - path: "crates/cli/src/main.rs"
      provides: "Updated CLI wiring for explain command (no longer stub)"
      contains: "cmd_explain"
    - path: "crates/cli/tests/cli_integration.rs"
      provides: "CLI integration tests for explain subcommand"
      contains: "explain"
  key_links:
    - from: "crates/cli/src/explain.rs"
      to: "tenor_analyze::analyze"
      via: "analysis API call for risk/coverage section"
      pattern: "tenor_analyze.*analyze"
    - from: "crates/cli/src/main.rs"
      to: "crates/cli/src/explain.rs"
      via: "module import and cmd_explain call"
      pattern: "mod explain"
---

<objective>
Implement the `tenor explain` CLI subcommand that produces a human-readable contract summary with 4 sections: contract summary, decision flow narrative, fact inventory, and risk/coverage notes.

Purpose: CLI-06 requirement. Provides a way for both business stakeholders and developers to understand what a Tenor contract does without reading the DSL source. Uses domain contracts from Wave 1 as real test data.

Output: Working `tenor explain` command with styled terminal output (default), markdown output (`--format markdown`), and verbose mode (`--verbose`). CLI integration tests.
</objective>

<execution_context>
@/Users/bwb/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bwb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-domain-validation/05-CONTEXT.md
@.planning/phases/05-domain-validation/05-RESEARCH.md
@.planning/phases/05-domain-validation/05-01-SUMMARY.md
@crates/cli/src/main.rs
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tenor explain command</name>
  <files>
    crates/cli/Cargo.toml
    crates/cli/src/main.rs
    crates/cli/src/explain.rs
  </files>
  <action>
    **1. Add dependencies to `crates/cli/Cargo.toml`:**
    ```toml
    crossterm = "0.28"
    textwrap = "0.16"
    ```

    **2. Create `crates/cli/src/explain.rs`** with the full explain implementation.

    The module should export a single entry function:
    ```rust
    pub fn explain(bundle: &serde_json::Value, format: ExplainFormat, verbose: bool) -> String
    ```

    Where `ExplainFormat` is an enum: `Terminal` (styled) or `Markdown`.

    **Section 1: Contract Summary**
    - Extract bundle `id` as contract name
    - Count constructs by kind: Fact, Entity, Rule, Persona, Operation, Flow
    - For each entity: list state count
    - For styled terminal: use crossterm bold for headings, cyan for names
    - For markdown: use `##` headings
    - Example output: "Name: saas_subscription | Entities: Subscription (7 states) | Personas: 3 | Rules: 5 across 2 strata | Flows: 1"

    **Section 2: Decision Flow Narrative**
    - For each Flow construct: walk the steps array
    - Generate plain-language description of each step:
      - OperationStep: "{persona} {operation_description}" + precondition summary
      - BranchStep: "If {condition} then ... else ..."
      - HandoffStep: "Handed off to {target_persona}"
      - ParallelStep: "Concurrently: {branch descriptions}"
      - SubFlowStep: "Sub-process: {sub_flow_id}"
      - TerminateStep: "Process ends: {reason}"
    - In verbose mode: include operation effect details (entity state transitions), precondition expressions

    **Section 3: Fact Inventory**
    - List all Facts with: id, type (human-readable), source, default value (if any)
    - Format as aligned table (terminal: fixed-width columns, markdown: table)
    - Group by type category (numeric, boolean, enum, record, list)

    **Section 4: Risk / Coverage Notes**
    - Call `tenor_analyze::analyze(bundle)` to get S1-S8 results
    - Summarize findings in plain language:
      - S1: "N entities, M total states"
      - S2: dead states → "WARNING: N dead state(s) found" or checkmark
      - S5: verdict count
      - S6: flow path count
      - S8: verdict uniqueness status
    - In verbose mode: list all analysis findings with severity

    **3. Update `crates/cli/src/main.rs`:**
    - Add `mod explain;`
    - Update the `Explain` command variant to accept new args:
      ```rust
      Explain {
          /// Path to .tenor source file or interchange JSON bundle
          file: PathBuf,
          /// Output format (terminal or markdown)
          #[arg(long, default_value = "terminal")]
          format: ExplainOutputFormat,
          /// Show technical details
          #[arg(long)]
          verbose: bool,
      }
      ```
    - Replace `stub_not_implemented("explain", ...)` with `cmd_explain(...)` function that:
      - Detects input type by extension (.tenor vs .json)
      - If .tenor: elaborate first, then explain the bundle
      - If .json: parse as interchange bundle, then explain
      - Calls `explain::explain()` and prints result

    **Terminal styling guidelines (Claude's discretion):**
    - Section headings: UPPERCASE BOLD with `═` underline
    - Entity/persona names: cyan
    - Warnings: yellow
    - Checkmarks: green
    - Use textwrap for narrative text at terminal width (default 80)
  </action>
  <verify>
    ```bash
    cargo build -p tenor-cli
    # Test with a domain contract (from 05-01)
    cargo run -p tenor-cli -- explain domains/saas/saas_subscription.tenor
    # Test with --format markdown
    cargo run -p tenor-cli -- explain domains/saas/saas_subscription.tenor --format markdown
    # Test with --verbose
    cargo run -p tenor-cli -- explain domains/saas/saas_subscription.tenor --verbose
    # Test with .json input (elaborate first, then explain the JSON)
    cargo run -p tenor-cli -- elaborate domains/saas/saas_subscription.tenor > /tmp/saas.json
    cargo run -p tenor-cli -- explain /tmp/saas.json
    ```
    All commands must exit 0 and produce readable output with all 4 sections.
  </verify>
  <done>tenor explain produces 4-section human-readable output in terminal (styled) and markdown formats, with verbose mode. Accepts both .tenor and .json inputs.</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI integration tests for explain</name>
  <files>
    crates/cli/tests/cli_integration.rs
  </files>
  <action>
    Add integration tests for the explain subcommand to `crates/cli/tests/cli_integration.rs`, following the existing test patterns (assert_cmd subprocess tests).

    **Tests to add:**

    1. `explain_tenor_file_exits_0` — Run `tenor explain` on a valid .tenor file (use an existing conformance fixture or domain contract), verify exit 0 and stdout contains "CONTRACT SUMMARY" or equivalent heading.

    2. `explain_json_bundle_exits_0` — Elaborate a .tenor to a temp .json file, then run `tenor explain` on the JSON. Verify exit 0.

    3. `explain_markdown_format` — Run with `--format markdown`, verify stdout contains markdown headings (`##`).

    4. `explain_verbose_flag` — Run with `--verbose`, verify stdout contains additional technical details (entity states, rule strata).

    5. `explain_missing_file_exits_1` — Run on a nonexistent file, verify exit 1.

    6. `explain_invalid_json_exits_1` — Run on an invalid JSON file, verify exit 1.

    Follow existing patterns in cli_integration.rs:
    ```rust
    #[test]
    fn explain_tenor_file_exits_0() {
        tenor()
            .args(["explain", "domains/saas/saas_subscription.tenor"])
            .assert()
            .success()
            .stdout(predicate::str::contains("CONTRACT SUMMARY").or(predicate::str::contains("Contract Summary")));
    }
    ```
  </action>
  <verify>
    ```bash
    cargo test -p tenor-cli -- explain
    ```
    All explain integration tests pass. Full workspace:
    ```bash
    cargo test --workspace
    ```
  </verify>
  <done>CLI integration tests for explain subcommand pass. Full workspace test suite still passes.</done>
</task>

</tasks>

<verification>
1. `tenor explain <file.tenor>` produces styled 4-section output (summary, narrative, inventory, risk)
2. `tenor explain <bundle.json>` works with interchange JSON input
3. `--format markdown` produces markdown output
4. `--verbose` adds technical details
5. `cargo test -p tenor-cli -- explain` — all integration tests pass
6. `cargo test --workspace` — full suite passes
7. No longer returns exit code 2 (not-implemented)
</verification>

<success_criteria>
- tenor explain is a fully functional CLI subcommand (not a stub)
- Output is business-readable by default, developer-detailed with --verbose
- Styled terminal and markdown formats both work
- Accepts both .tenor and .json inputs
- Risk/coverage section uses tenor-analyze API for real analysis data
- CLI integration tests cover happy path, formats, error cases
</success_criteria>

<output>
After completion, create `.planning/phases/05-domain-validation/05-06-SUMMARY.md`
</output>
