{
  "protocol": {
    "name": "Constraint-First Formalization Protocol",
    "version": "0.2.1",
    "description": "Invariant-driven semantic design. Candidates survive pressure or die."
  },
  "construct": {
    "name": "P7 Operation Outcome Typing",
    "description": "Operations declare named outcome types that are statically enumerable. Flow OperationStep routing references declared outcomes rather than ad-hoc labels. This is not a new construct -- it modifies the existing Operation and Flow constructs to add outcome declaration and typed outcome routing.",
    "depends_on": ["Fact", "Entity", "Rule", "Operation", "Flow", "TypeDecl", "Persona"]
  },
  "version": "1.0",
  "phase1": {
    "invariants": [
      {
        "id": "I1",
        "description": "Every Flow OperationStep outcome key must be a member of the declared outcome set of the referenced Operation. If an OperationStep routes on outcome label L for Operation O, then L must be in O.outcomes. Checked at elaboration time (Pass 5).",
        "testable": true,
        "structural": true,
        "class": "soundness"
      },
      {
        "id": "I2",
        "description": "The set of outcomes for any Operation is statically determinable. For every Operation O, O.outcomes is a finite, non-empty set of outcome labels known at elaboration time (Pass 2). No outcome can be dynamically created, conditionally declared, or depend on runtime values.",
        "testable": true,
        "structural": true,
        "class": "analyzability"
      },
      {
        "id": "I3",
        "description": "No implicit or catch-all outcomes are permitted. Every possible success-path result of an Operation is a named member of its declared outcome set. There is no default outcome, no wildcard match, and no implicit 'other' category. The outcome set is closed.",
        "testable": true,
        "structural": true,
        "class": "completeness"
      },
      {
        "id": "I4",
        "description": "Outcome typing does not affect evaluation determinism. Given the same inputs (persona, verdict_set, entity_state), the same Operation produces the same outcome. The addition of named outcomes does not introduce any new source of non-determinism into the evaluation model.",
        "testable": true,
        "structural": true,
        "class": "determinism"
      },
      {
        "id": "I5",
        "description": "The outcome set is finite and closed. For any Operation O, O.outcomes is a finite enumeration (not an open set, not parameterized, not dependent on type variables). The cardinality of O.outcomes is statically known.",
        "testable": true,
        "structural": true,
        "class": "termination"
      },
      {
        "id": "I6",
        "description": "Outcomes and errors are disjoint channels. The outcome set of an Operation describes success-path results. The error_contract describes failure-path results. No outcome label may also appear in error_contract. The error channel is unchanged by P7 -- persona_rejected and precondition_failed remain error conditions, not outcomes.",
        "testable": true,
        "structural": true,
        "class": "soundness"
      }
    ]
  },
  "phase2": {
    "candidates": [
      {
        "id": "A",
        "description": "Inline Outcome Enum. Operations declare an 'outcomes' field listing named outcome labels as strings. Each label is a terminal success-path result of the operation. Flows reference outcomes by label. The error_contract mechanism is unchanged. Operations with a single success path declare outcomes: [\"success\"] (or any single label). Operations with multiple success paths (e.g., approve/reject decisions) declare each path as a named outcome.",
        "formalism": {
          "structure": "Operation = (id: OperationId, allowed_personas: Set<PersonaId>, precondition: PredicateExpression, effects: Set<(EntityId x StateId x StateId)>, error_contract: Set<ErrorType>, outcomes: Set<OutcomeLabel>) where OutcomeLabel is a non-empty UTF-8 string unique within the Operation's outcome set. |outcomes| >= 1. The error_contract set and outcomes set are disjoint: outcomes INTERSECT error_contract = EMPTY. Each OutcomeLabel is a bare string with no associated payload data.",
          "evaluation_rule": "execute(op, persona, verdict_set, entity_state) proceeds as before: persona check, precondition evaluation, atomic effect application, provenance emission. On success, the executor produces exactly one OutcomeLabel from op.outcomes. For Operations with a single outcome, the outcome is deterministic. For Operations with multiple outcomes (e.g., approve/reject), the outcome is determined by the executor based on which effects were applied -- each effect tuple can be associated with an outcome via convention or explicit mapping. The outcome label is returned alongside the new entity state. The existing evaluation function signature becomes: execute: Operation x PersonaId x ResolvedVerdictSet x EntityState -> (EntityState', OutcomeLabel) | Error.",
          "resolution_rule": "Outcome resolution in Flows: when a Flow OperationStep invokes an Operation and receives an OutcomeLabel, the step's outcomes map is consulted. The map keys must be a subset of (or equal to) the referenced Operation's declared outcomes. Resolution is a single map lookup: outcomes[label] -> StepId | Terminal. If the label is not in the map, this is an elaboration error (caught at Pass 5, not runtime)."
        },
        "claims": [
          {
            "invariant_id": "I1",
            "argument": "Pass 5 validates each OperationStep's outcome keys against the referenced Operation's declared outcomes set. For each key K in step.outcomes, Pass 5 checks K in op.outcomes. If K is not found, an elaboration error is emitted. The Operation construct index (Pass 2) provides the outcome set. This is a straightforward set-membership check on statically known sets."
          },
          {
            "invariant_id": "I2",
            "argument": "Outcomes are declared as a literal set of strings on the Operation construct, parsed in Pass 0 and indexed in Pass 2. They cannot appear inside conditional blocks, cannot depend on Fact values or Rule verdicts, and cannot be computed at runtime. The set is fixed at contract definition time, identical to how allowed_personas and effects are fixed."
          },
          {
            "invariant_id": "I3",
            "argument": "The outcomes set is closed: only the declared labels are valid. There is no default case, no wildcard, and no 'else' branch. If a Flow OperationStep's outcomes map does not include a label that the Operation can produce, Pass 5 can optionally warn about unhandled outcomes (or require exhaustive handling -- see design tension below). The Operation itself cannot produce an outcome not in its declared set."
          },
          {
            "invariant_id": "I4",
            "argument": "The addition of outcome labels does not change the evaluation rule's determinism properties. The persona check, precondition evaluation, and effect application are unchanged. The outcome label is produced by the executor after effect application -- for single-outcome Operations it is trivially deterministic. For multi-outcome Operations, the outcome is determined by which effects were applied, which is itself determined by the entity state (a function of the inputs). No new source of non-determinism is introduced."
          },
          {
            "invariant_id": "I5",
            "argument": "The outcomes set is a literal string set with finite cardinality declared in the contract text. It is not parameterized by types, not dependent on runtime values, and not expandable. |outcomes| is a natural number known at elaboration time."
          },
          {
            "invariant_id": "I6",
            "argument": "The formalism explicitly requires outcomes INTERSECT error_contract = EMPTY. This is a structural constraint checked at elaboration time (Pass 5). Error conditions (persona_rejected, precondition_failed, and any declared error_contract entries) are returned as Error values from execute(). Outcomes are returned as OutcomeLabel values from execute() on the success path. The two channels have different return types and different handling semantics in Flows (outcomes map vs on_failure handler)."
          }
        ],
        "complexity": {
          "time": "O(n) for indexing n outcome labels per Operation during Pass 2; O(m * k) for validating m OperationStep outcome maps where k is the average number of outcome keys per step",
          "space": "O(n) per Operation for storing the declared outcome set, where n is the number of outcome labels",
          "static": "O(|Ops| * max|outcomes|) for enumerating all possible outcomes across all Operations; O(|Flows| * |Steps| * max|outcomes|) for verifying Flow outcome routing coverage"
        },
        "failure_modes": [
          {
            "description": "Outcome labels carry no typed payload. An outcome 'approved' cannot carry data (e.g., the approval amount or the approving persona). If outcome-specific data is needed, it must be conveyed through entity state changes or separate Facts.",
            "trigger": "Contract author wants to pass data from an Operation's outcome to subsequent Flow steps",
            "severity": "ergonomic"
          },
          {
            "description": "For Operations with a single success path, the mandatory outcomes declaration adds syntactic overhead (outcomes: [success]) that provides no new information.",
            "trigger": "Simple Operations where 'it worked' is the only success outcome",
            "severity": "ergonomic"
          },
          {
            "description": "The mapping from effects to outcomes is not encoded in the Operation formalism -- it is an executor obligation. The Operation declares both outcomes and effects but does not formally specify which effects correspond to which outcomes.",
            "trigger": "Operation with multiple outcomes AND multiple effects where the association is ambiguous",
            "severity": "degraded"
          }
        ]
      },
      {
        "id": "B",
        "description": "Typed Outcome Variants. Operations declare outcome variants as a tagged-union-like structure where each variant can carry typed payload data. Each outcome variant has a name and an optional payload type (a BaseType). Flows receive the outcome variant and route on the variant name. This is more expressive than Candidate A: outcomes can carry data, enabling downstream Flow steps to access outcome-specific information.",
        "formalism": {
          "structure": "Operation = (id: OperationId, allowed_personas: Set<PersonaId>, precondition: PredicateExpression, effects: Set<(EntityId x StateId x StateId)>, error_contract: Set<ErrorType>, outcomes: Map<OutcomeLabel, BaseType?>) where each OutcomeLabel maps to an optional BaseType payload. |outcomes| >= 1. The error_contract set and outcomes key set are disjoint.",
          "evaluation_rule": "execute(op, persona, verdict_set, entity_state) returns (EntityState', OutcomeLabel, PayloadValue?) | Error. The executor produces the outcome label and its optional payload after effect application. Payload values must conform to the declared BaseType for that outcome. This introduces a new element to the evaluation model: the payload production, which must be type-checked against the declared payload type at runtime.",
          "resolution_rule": "Flow OperationSteps route on the variant name (identical to Candidate A). The payload value is available for binding in subsequent steps if the language provides a mechanism for it. Currently, Flows cannot bind values from Operation results -- they only route. The payload would need a new binding mechanism in Flows."
        },
        "claims": [
          {
            "invariant_id": "I1",
            "argument": "Identical to Candidate A for routing validation. Flow OperationStep outcome keys are validated against Operation outcome names. The payload type does not affect routing -- routing is on the label, not the payload."
          },
          {
            "invariant_id": "I2",
            "argument": "Identical to Candidate A. Outcome names are declared statically. Payload types are declared statically (BaseTypes are resolved during Pass 3)."
          },
          {
            "invariant_id": "I3",
            "argument": "Identical to Candidate A. The outcome map is closed. No implicit or catch-all outcomes."
          },
          {
            "invariant_id": "I4",
            "argument": "The addition of payload types introduces a new type-checking obligation at runtime: the executor must produce a payload value that conforms to the declared type. However, this is a conformance obligation (like E2 entity state validation), not a source of non-determinism. Given the same inputs, the same payload type is produced. Determinism is preserved."
          },
          {
            "invariant_id": "I5",
            "argument": "Identical to Candidate A. The outcome map has finite, statically known cardinality."
          },
          {
            "invariant_id": "I6",
            "argument": "Identical to Candidate A. Outcomes and errors are disjoint. Payload types do not affect the error channel."
          }
        ],
        "complexity": {
          "time": "O(n) for indexing outcomes; O(n * t) for type-checking payload types during Pass 3 where t is the type resolution cost; O(m * k) for validating Flow outcome maps",
          "space": "O(n * s) per Operation where s is the average payload type size in the type environment",
          "static": "Higher than Candidate A: payload types must be included in S5 verdict space analysis and S6 flow path enumeration. O(|Ops| * max|outcomes| * max|payload_size|)"
        },
        "failure_modes": [
          {
            "description": "Payload values have no consumption mechanism in Flows. Flows route on outcome labels but cannot bind or use payload values. The payload would be produced by the executor and immediately discarded by the Flow unless a new binding mechanism is added. This requires either: (a) a new Flow step type for payload binding, or (b) modifying OperationStep to support payload binding, or (c) making payloads available as ephemeral Facts. All three options require significant changes to the Flow formalism beyond what P7 scopes.",
            "trigger": "Any Operation that declares a non-null payload type on an outcome",
            "severity": "fatal"
          },
          {
            "description": "Runtime type-checking of payload values introduces a new conformance obligation that cannot be verified at elaboration time. The elaborator can verify that the declared payload type is well-formed, but cannot verify that the executor produces conforming values.",
            "trigger": "Any Operation with typed payloads -- the type conformance is an executor obligation",
            "severity": "degraded"
          },
          {
            "description": "Payload types increase interchange format complexity. Each outcome variant in the interchange format carries a type descriptor, increasing the size and complexity of Operation documents.",
            "trigger": "Operations with multiple outcomes each having different payload types",
            "severity": "ergonomic"
          }
        ]
      },
      {
        "id": "C",
        "description": "Outcome as Separate Construct. Outcomes are declared as standalone constructs referenced by Operations and Flows. An OutcomeDecl defines a named outcome that can be shared across multiple Operations. This enables reuse: if multiple Operations can produce the same outcome (e.g., 'approved', 'rejected'), the outcome is declared once and referenced by name.",
        "formalism": {
          "structure": "OutcomeDecl = (id: OutcomeId) where OutcomeId is a non-empty UTF-8 string unique within the contract. Operation = (id: OperationId, ..., outcomes: Set<OutcomeRef>) where OutcomeRef references a declared OutcomeDecl by id. Flow OperationStep outcomes map keys are OutcomeRefs. A new construct kind 'OutcomeDecl' is added to the construct set.",
          "evaluation_rule": "Identical to Candidate A at the evaluation level. execute() returns an OutcomeId on success. The indirection through OutcomeDecl does not change the evaluation semantics.",
          "resolution_rule": "Two-phase resolution: (1) OutcomeRef -> OutcomeDecl (Pass 5, like persona resolution), (2) Flow outcome map key -> OutcomeDecl (Pass 5). Both are single lookups in the construct index."
        },
        "claims": [
          {
            "invariant_id": "I1",
            "argument": "Flow OperationStep outcome keys are OutcomeRefs validated against the referenced Operation's outcome set (which contains OutcomeRefs). Each OutcomeRef is additionally validated against the OutcomeDecl index. Two validation steps, both at Pass 5."
          },
          {
            "invariant_id": "I2",
            "argument": "OutcomeDecls are top-level constructs, statically declared and indexed in Pass 2. Operation outcome sets reference OutcomeDecl ids, which are resolved in Pass 5. The complete set of outcomes for any Operation is the union of its declared OutcomeRefs, all resolvable at elaboration time."
          },
          {
            "invariant_id": "I3",
            "argument": "Identical to Candidate A. The outcome set is closed and explicit."
          },
          {
            "invariant_id": "I4",
            "argument": "Identical to Candidate A. OutcomeDecl is a declaration-only construct with no evaluation semantics."
          },
          {
            "invariant_id": "I5",
            "argument": "Identical to Candidate A. OutcomeDecl sets are finite."
          },
          {
            "invariant_id": "I6",
            "argument": "OutcomeDecl ids and error_contract entries must be disjoint. Checked at Pass 5."
          }
        ],
        "complexity": {
          "time": "O(d) for indexing d OutcomeDecls; O(n) per Operation for resolving outcome references; O(m * k) for Flow validation. Total higher than Candidate A due to indirection.",
          "space": "O(d) for OutcomeDecl index plus O(n) per Operation for resolved outcome sets",
          "static": "Identical to Candidate A once references are resolved. The indirection adds resolution cost but not analysis cost."
        },
        "failure_modes": [
          {
            "description": "Introduces a new construct kind (OutcomeDecl) which adds complexity to the construct index, the interchange format, the elaboration passes, and the conformance suite. This is disproportionate to the benefit: outcome labels are simple strings that do not benefit from construct-level indirection.",
            "trigger": "Any use of outcome typing -- the indirection is always present",
            "severity": "degraded"
          },
          {
            "description": "Shared outcomes across Operations create semantic ambiguity. If Operations approve_order and approve_refund both reference outcome 'approved', does 'approved' mean the same thing in both contexts? The outcome label is decontextualized by being a separate construct.",
            "trigger": "Two Operations referencing the same OutcomeDecl with different semantic meanings",
            "severity": "degraded"
          },
          {
            "description": "OutcomeDecl sharing is premature. In v1.0, there is no cross-contract reference mechanism (P5 is about types, not outcomes). The reuse benefit is limited to within a single contract, where the duplication of outcome label strings is trivial.",
            "trigger": "Attempting to justify OutcomeDecl as a reuse mechanism when cross-contract outcomes are not supported",
            "severity": "ergonomic"
          }
        ]
      }
    ]
  },
  "phase3": {
    "counterexamples": [
      {
        "id": "CE1",
        "target_candidate": "B",
        "violates": "I4",
        "witness": "Operation process_claim declares outcomes: {approved: Money, rejected: null}. The executor must produce a Money value when the outcome is 'approved'. But nothing in the Operation formalism constrains which entity state transitions correspond to which outcomes. The Operation declares effects: [{entity_id: Claim, from: submitted, to: approved}, {entity_id: Claim, from: submitted, to: rejected}]. When the executor applies the (submitted -> approved) transition, it must also produce a Money payload -- but the value comes from outside the contract's closed-world semantics. The executor must fabricate a Money value that satisfies the declared type but has no derivation chain within the evaluation model. This violates provenance-as-semantics (C7) and introduces an implicit dependency on the executor's internal logic for determining payload values.",
        "minimal": true,
        "rebuttal": {
          "argument": "The counterexample is correct. Payload values produced by the executor have no derivation within the contract's evaluation model. They are opaque values injected by the executor with no provenance chain. This breaks C7 (provenance as semantics) and C5 (closed-world semantics). The contract cannot specify what the payload value should be because the Operation formalism has no mechanism for computing values -- it only produces state transitions. Typed payloads would require the Operation to compute values, which approaches Turing-completeness (C1 violation risk). The candidate cannot satisfy I4 because payload production introduces a new computation step whose behavior is defined outside the contract.",
          "valid": false,
          "kind": "refutation",
          "falsified_claim": "I4"
        }
      },
      {
        "id": "CE2",
        "target_candidate": "C",
        "violates": "I3",
        "witness": "OutcomeDecl 'approved' is declared once and referenced by Operations approve_order, approve_refund, and approve_escalation. Each Operation has different effects and different semantic contexts. A Flow step invoking approve_order routes on outcome 'approved' -- but the same label 'approved' from approve_refund means something entirely different (refund approved vs order approved). The shared label creates the illusion of a common outcome type when the semantics are Operation-specific. A static analyzer checking 'which Operations can produce outcome approved?' returns three Operations, but the answer is misleading because 'approved' means different things in each context. The shared construct decontextualizes outcomes, violating the closed-world principle: the meaning of an outcome depends on context that is not captured in the OutcomeDecl.",
        "minimal": true,
        "rebuttal": {
          "argument": "The counterexample demonstrates a real design tension but does not constitute an invariant violation of I3 specifically. I3 requires that outcomes are named members of the declared set -- and they are, even if shared. However, the decontextualization is a real problem: it makes static analysis results misleading and violates C6 (explicit over implicit) because the semantic meaning of 'approved' is implicit in the Operation context rather than explicit in the OutcomeDecl. This is a scope narrowing: if Candidate C survives, it must acknowledge that shared outcomes lose contextual meaning.",
          "valid": true,
          "kind": "scope_narrowing",
          "limitation_description": "Shared OutcomeDecl constructs decontextualize outcome semantics. The meaning of an outcome label depends on the Operation that produces it, but OutcomeDecl does not capture this context. Static analysis results involving shared outcomes may be misleading."
        }
      },
      {
        "id": "CE3",
        "target_candidate": "A",
        "violates": "I3",
        "witness": "Operation transfer_funds declares outcomes: [completed]. It has effects: [{entity_id: Transfer, from: pending, to: completed}, {entity_id: Transfer, from: pending, to: failed}]. The (pending -> failed) effect is associated with the error_contract via on_failure handling. But what if the executor encounters a condition where the transfer partially succeeds? The outcome set [completed] does not include 'partial' or 'failed' as outcomes. The error_contract handles failures. But between complete success and error-channel failure, there may be intermediate results that are neither errors nor the declared outcome. Is 'completed' truly exhaustive of all success-path results?",
        "minimal": true,
        "rebuttal": {
          "argument": "The counterexample reveals a genuine design question but does not violate I3 as stated. I3 says every possible success-path result is a named member. If partial success is a possible success-path result, it must be declared as an outcome. If it is a failure condition, it belongs in error_contract. The contract author must decide: is partial success a success outcome or an error? If the author omits 'partial' from outcomes when partial results are possible, that is a contract authoring error, not an invariant violation. The Operation formalism requires exhaustive declaration of success outcomes -- the author is responsible for correctness. However, the formalism cannot statically verify that the declared outcomes are truly exhaustive of all executor behaviors. This is analogous to AL11 (operation source-state validation is an executor obligation).",
          "valid": true,
          "kind": "scope_narrowing",
          "limitation_description": "Outcome exhaustiveness is a contract authoring obligation. The elaborator can verify that Flow routing references valid declared outcomes, but cannot verify that the declared outcome set is exhaustive of all possible executor success-path behaviors. This parallels AL11 (source-state validation is an executor obligation)."
        }
      },
      {
        "id": "CE4",
        "target_candidate": "A",
        "violates": "I1",
        "witness": "Contract has Operation approve_order with outcomes: [approved, rejected]. Flow order_flow has OperationStep invoking approve_order with outcomes map: {approved: next_step}. The outcome 'rejected' is not handled in the Flow outcomes map. If the executor produces outcome 'rejected', the Flow has no routing for it. Is this an elaboration error (Flow must handle all outcomes) or valid (partial handling, with unhandled outcomes treated as... what exactly)?",
        "minimal": true,
        "rebuttal": {
          "argument": "This is a critical design decision, not an invariant violation of I1. I1 says outcome keys must be members of the declared set -- {approved} IS a subset of {approved, rejected}. The question is whether I1 should be strengthened to require exhaustive handling: the Flow must handle ALL declared outcomes, not just a subset. There are two valid positions: (a) require exhaustive handling (every declared outcome must appear in the Flow outcomes map or in the on_failure handler), or (b) allow partial handling with the requirement that unhandled outcomes fall through to the on_failure handler. Position (a) is safer and aligns with I3 (no implicit outcomes -- unhandled outcomes are an implicit 'fall through to failure'). Position (b) is more flexible but creates an implicit behavior (unhandled outcomes silently become failures). Per C6 (explicit over implicit), position (a) is preferred. This is a scope decision that affects the elaboration validation rules.",
          "valid": true,
          "kind": "scope_narrowing",
          "limitation_description": "Flow OperationStep outcome handling must be exhaustive: every declared outcome of the referenced Operation must appear as a key in the OperationStep outcomes map. Unhandled outcomes are elaboration errors (Pass 5). This is the strict interpretation aligned with C6 (explicit over implicit). Partial handling with implicit fall-through to on_failure is not permitted."
        }
      },
      {
        "id": "CE5",
        "target_candidate": "A",
        "violates": "I6",
        "witness": "Operation check_eligibility declares outcomes: [eligible, ineligible] and error_contract: [precondition_failed, persona_rejected]. A contract author also adds 'ineligible' to the error_contract, reasoning that ineligibility is a kind of failure. Now 'ineligible' appears in both outcomes and error_contract. The Operation formalism allows this because the two sets are declared independently. Does the disjointness constraint catch this?",
        "minimal": true,
        "rebuttal": {
          "argument": "This is exactly what I6 is designed to catch. The formalism explicitly requires outcomes INTERSECT error_contract = EMPTY. Pass 5 checks this. If 'ineligible' appears in both sets, it is an elaboration error. The counterexample confirms that I6 is necessary and that the validation rule works as intended.",
          "valid": true,
          "kind": "refutation"
        }
      },
      {
        "id": "CE6",
        "target_candidate": "C",
        "violates": "I2",
        "witness": "The contract declares OutcomeDecl approved, OutcomeDecl rejected, OutcomeDecl pending. Operation fast_approve references outcomes: [approved]. Operation full_review references outcomes: [approved, rejected, pending]. A later spec revision removes OutcomeDecl pending. Operation full_review now has a dangling outcome reference. Because outcomes are declared as separate constructs, changes to OutcomeDecl declarations have non-local effects on Operations that reference them. With Candidate A, outcome labels are local to each Operation -- removing an outcome from one Operation does not affect any other Operation.",
        "minimal": true,
        "rebuttal": {
          "argument": "This is a valid concern about the fragility of shared construct references, but it is not a violation of I2. I2 says the outcome set is statically determinable -- and it still is (it is just invalid because of a dangling reference). The dangling reference is caught by Pass 5 validation. However, the non-local effect of OutcomeDecl changes is a real ergonomic and maintenance concern. This is a consequence of the indirection that Candidate C introduces.",
          "valid": true,
          "kind": "scope_narrowing",
          "limitation_description": "Shared OutcomeDecl constructs create non-local dependencies. Changes to OutcomeDecl declarations can break Operations that reference them, requiring coordinated updates across multiple constructs."
        }
      },
      {
        "id": "CE7",
        "target_candidate": "A",
        "violates": "I4",
        "witness": "Operation decide_claim has outcomes: [approved, rejected] and effects: [{entity_id: Claim, from: review, to: approved}, {entity_id: Claim, from: review, to: rejected}]. The outcome is 'approved' if the (review -> approved) transition is applied, 'rejected' if the (review -> rejected) transition is applied. But the Operation formalism does not declare which effects correspond to which outcomes. The executor must determine this mapping. Two conforming executors could disagree on the mapping (executor A maps the first effect to 'approved', executor B maps effects based on the target state name). Is the outcome deterministic across implementations?",
        "minimal": true,
        "rebuttal": {
          "argument": "This counterexample identifies a real gap: the association between effects and outcomes is not encoded in the Operation formalism. However, this does not violate I4 (determinism) because I4 states that given the same inputs, the same Operation produces the same outcome. The outcome is determined by the executor's implementation, which must be deterministic within a single executor. Cross-executor determinism for the effect-to-outcome mapping is indeed not guaranteed by the Operation formalism alone. This is analogous to AL11 and AL12: certain behaviors are executor obligations. The contract should declare the mapping explicitly. The solution is to require that the Operation DSL syntax associates effects with outcomes, making the mapping part of the contract (not the executor's discretion). This is a scope narrowing: Operations with multiple outcomes and multiple effects must explicitly associate each effect with an outcome.",
          "valid": true,
          "kind": "scope_narrowing",
          "limitation_description": "When an Operation declares multiple outcomes and multiple effects, each effect must be associated with exactly one outcome. The DSL syntax and interchange format must encode this association explicitly. The executor does not determine the effect-to-outcome mapping -- the contract does. This ensures cross-executor determinism for outcome production."
        }
      }
    ],
    "composition_failures": [
      {
        "target_candidate": "B",
        "conflicts_with": "Flow",
        "violates": "I4",
        "description": "Candidate B introduces typed payloads on outcomes, but the Flow formalism has no mechanism to consume payload values. Flow OperationSteps route on outcome labels and proceed to the next step. There is no binding syntax, no variable introduction, and no way for subsequent steps to access the payload. Adding payload consumption would require modifying the Flow evaluation rule (Section 11.4), the Flow step type definitions (Section 11.2), and potentially introducing variables into a construct that is currently variable-free (Flows sequence, they do not compute). This is a fundamental composition failure: the payload capability cannot be used within the existing Flow formalism, and extending the Flow formalism to support it exceeds the scope of P7."
      },
      {
        "target_candidate": "C",
        "conflicts_with": "Operation",
        "violates": "I2",
        "description": "Candidate C introduces a new construct kind (OutcomeDecl) that must be added to the construct index, the interchange format, the elaboration pass pipeline, and the conformance suite. The spec currently defines the construct set in Section 3 as a closed set. Adding a new construct kind changes the construct count, requires updates to ElaboratorSpec (Section 13), and adds a new entry to the interchange serialization rules (Pass 6). The scope of this change is disproportionate to the benefit: outcome labels are simple strings that do not require construct-level formalization. By contrast, Persona required construct-level formalization because persona identifiers are referenced across multiple construct boundaries and participate in authority topology analysis (S4). Outcome labels are scoped to their declaring Operation and consumed only by Flow OperationSteps referencing that Operation. The indirection adds complexity without enabling new analyses."
      },
      {
        "target_candidate": "A",
        "conflicts_with": "Persona",
        "violates": "I1",
        "description": "Composition test -- NOT a failure. Candidate A composes correctly with Persona. Operation outcome typing does not affect persona resolution. The outcomes set and allowed_personas set are independent: outcomes describe what the Operation produces, allowed_personas describes who can invoke it. Persona resolution (Pass 5) is unchanged. S4 authority topology analysis is unchanged -- it does not depend on outcome labels. The only interaction is that when a Flow OperationStep invokes an Operation, both the persona (from the step) and the outcome routing (from the step's outcomes map) are validated, but against different sets. No conflict."
      }
    ]
  },
  "derived": {
    "eliminated": [
      {
        "candidate_id": "B",
        "reason": "counterexample_unrebutted",
        "source_id": "CE1"
      }
    ],
    "survivors": [
      {
        "candidate_id": "A",
        "scope_narrowings": [
          "Outcome exhaustiveness is a contract authoring obligation. The elaborator can verify that Flow routing references valid declared outcomes, but cannot verify that the declared outcome set is exhaustive of all possible executor success-path behaviors.",
          "Flow OperationStep outcome handling must be exhaustive: every declared outcome of the referenced Operation must appear as a key in the OperationStep outcomes map.",
          "When an Operation declares multiple outcomes and multiple effects, each effect must be associated with exactly one outcome. The DSL syntax and interchange format must encode this association explicitly."
        ]
      },
      {
        "candidate_id": "C",
        "scope_narrowings": [
          "Shared OutcomeDecl constructs decontextualize outcome semantics.",
          "Shared OutcomeDecl constructs create non-local dependencies."
        ]
      }
    ]
  },
  "phase4": {
    "attempted": true,
    "succeeded": false,
    "reason": "Candidates A and C differ fundamentally in their approach: A treats outcomes as Operation-local string sets, C treats them as shared top-level constructs. Merging is not possible because the indirection in C is either present or absent -- there is no partial merge. Candidate A is preferred because: (1) outcome labels are semantically scoped to the declaring Operation, not shared across Operations -- an 'approved' outcome on approve_order is not the same concept as 'approved' on approve_refund; (2) C introduces a new construct kind (OutcomeDecl) with disproportionate specification and implementation cost for no demonstrated analytical benefit; (3) C's shared outcomes create non-local dependencies and decontextualize semantics (CE2, CE6); (4) A's simplicity aligns with the existing pattern where Operation fields are self-contained (allowed_personas, effects, error_contract are all Operation-local). The spec already has a precedent for Operation-local sets: error_contract is a per-Operation string set, not a shared construct. Outcomes follow the same pattern.",
    "selected": "A",
    "selection_basis": "Candidate A (Inline Outcome Enum) is strictly simpler. Outcomes are Operation-local, avoiding the decontextualization and non-local dependency problems of Candidate C. Both candidates satisfy all invariants, but C introduces a new construct kind with disproportionate cost. The existing pattern (error_contract as per-Operation string set) supports A's approach. Outcome sharing across Operations in v1.0 provides no analytical benefit since cross-contract outcomes are not supported and within-contract string duplication is trivial."
  },
  "phase5": {
    "obligations": [
      {
        "property": "S5 (Operation effect analysis) can enumerate all possible outcomes for any Operation",
        "argument": "With declared outcomes (I2: statically determinable set), S5 has direct access to the complete outcome set for every Operation. For any Operation O, O.outcomes is a finite set of strings available in the construct index after Pass 2. S5 can report: 'Operation O can produce outcomes {o1, o2, ..., on}' without executing the Operation. The outcome set is a structural property of the Operation declaration, not a runtime behavior. This is a direct enumeration, not an inference -- the outcomes are declared, not derived.",
        "provable": true
      },
      {
        "property": "S6 (Flow path enumeration) can verify that all Operation outcomes are handled in Flow routing",
        "argument": "For each Flow step of kind OperationStep, S6 can: (1) resolve the referenced Operation via step.op, (2) retrieve the Operation's declared outcomes set, (3) compare the OperationStep's outcomes map keys against the declared set. If the map keys equal the declared set, routing is exhaustive. If they are a strict subset, routing is partial (which is an elaboration error per CE4's scope narrowing). S6 can additionally trace every outcome to its destination (StepId or Terminal) and enumerate all possible Flow paths by composing Operation outcome routing across all steps. The path enumeration is bounded by O(|Steps| * max|outcomes|) per Flow.",
        "provable": true
      },
      {
        "property": "Outcome typing does not break closed-world semantics (C5)",
        "argument": "Outcome labels are declared in the contract text. They are strings with no external dependencies, no runtime determination, and no implicit behaviors. The outcome set is fully determined by the contract. The executor produces outcome labels but must choose from the declared set -- the contract constrains the executor's behavior. The outcome-to-effect mapping (per CE7's scope narrowing) is also declared in the contract. No ambient authority, no external reference, and no implicit behavior is introduced.",
        "provable": true
      },
      {
        "property": "Outcome typing integrates into the existing six-pass pipeline without requiring pass reordering",
        "argument": "Pass 0: Outcome declarations on Operations are parsed as part of the Operation syntax. Pass 1: No change -- outcomes are part of the Operation construct, not a separate import target. Pass 2: Outcome sets are indexed as part of the Operation construct entry. Pass 3: No change -- outcomes are string labels, not types (unlike Candidate B's typed payloads). Pass 4: No change -- outcomes do not participate in expression type-checking. Pass 5: Validation added: (a) outcome labels unique within each Operation, (b) outcomes INTERSECT error_contract = EMPTY for each Operation, (c) Flow OperationStep outcome map keys match declared outcomes of referenced Operation, (d) exhaustive handling check. Pass 6: Outcomes serialized as part of Operation interchange. No pass reordering required.",
        "provable": true
      }
    ],
    "all_provable": true
  },
  "phase6": {
    "canonical": {
      "construct": "P7 Operation Outcome Typing",
      "formal_statement": "An Operation declares a non-empty, finite, closed set of named outcomes. Operation = (...existing fields..., outcomes: Set<OutcomeLabel>) where OutcomeLabel is a non-empty UTF-8 string unique within the Operation's outcome set. |outcomes| >= 1. The outcome set and error_contract set must be disjoint (outcomes INTERSECT error_contract = EMPTY). Outcome labels are Operation-local: the label 'approved' on Operation A is not related to the label 'approved' on Operation B. When an Operation executes successfully (persona check passes, precondition holds, effects applied), it produces exactly one OutcomeLabel from its declared set. The execute() signature becomes: execute: Operation x PersonaId x ResolvedVerdictSet x EntityState -> (EntityState', OutcomeLabel) | Error. The existing error channel (Error with error_contract) is unchanged. When an Operation declares multiple outcomes and multiple effects, each effect must be associated with exactly one outcome, and this association is part of the Operation declaration. Flow OperationStep routing is updated: the outcomes map keys must exactly equal the declared outcome set of the referenced Operation (exhaustive handling required). Unhandled outcomes are elaboration errors (Pass 5). The OperationStep on_failure handler continues to handle error-channel results (persona_rejected, precondition_failed). Migration from AL13: existing contracts using ad-hoc outcome labels like 'success' must add corresponding outcome declarations to their Operations. An Operation with outcomes: [success] and a Flow OperationStep with outcomes: {success: next_step} is the canonical representation of the previous ad-hoc pattern. This is a breaking change covered by the v0.3 to v1.0 major version bump.",
      "evaluation_def": "The Operation evaluation rule is extended minimally. execute(op, persona, verdict_set, entity_state) proceeds through the existing four-step sequence: (1) persona check, (2) precondition evaluation, (3) atomic effect application, (4) provenance emission. On success, the executor additionally produces an OutcomeLabel from op.outcomes. For single-outcome Operations, the outcome label is the sole member of the set. For multi-outcome Operations with effect-to-outcome associations, the outcome is determined by which effects were applied. The outcome label is included in OperationProvenance. Flow evaluation (execute_flow) is updated: at an OperationStep, after execute() returns (state', outcome), the step's outcomes map is consulted: outcomes[outcome] -> StepId | Terminal. This replaces the previous classify(result) function which used ad-hoc labels.",
      "satisfies": ["I1", "I2", "I3", "I4", "I5", "I6"],
      "acknowledged_limitations": [
        "Outcome exhaustiveness is a contract authoring obligation. The elaborator can verify that Flow routing references valid declared outcomes and that handling is exhaustive, but cannot verify that the declared outcome set is exhaustive of all possible executor success-path behaviors. This parallels AL11 (source-state validation is an executor obligation).",
        "Outcome labels carry no typed payload. An outcome 'approved' cannot carry data (e.g., the approval amount). If outcome-specific data is needed, it must be conveyed through entity state changes or separate Facts. Typed outcome payloads were considered (Candidate B) and rejected because they conflict with the closed-world evaluation model (payload values have no derivation chain within the contract).",
        "When an Operation declares multiple outcomes and multiple effects, the effect-to-outcome association must be explicit in the contract. The DSL syntax and interchange format encode which effects belong to which outcome. The executor does not determine this mapping.",
        "Migration from AL13 is a breaking change. Existing v0.3 contracts with ad-hoc outcome labels in Flow OperationSteps must add corresponding outcomes declarations to their Operations when migrating to v1.0. This is covered by the major version bump (v0.3 -> v1.0)."
      ]
    }
  },
  "outcome": "canonical",
  "outcome_notes": "Candidate A (Inline Outcome Enum) survived all pressure and was selected over Candidates B (Typed Outcome Variants) and C (Outcome as Separate Construct) in Phase 4. Candidate B was eliminated by counterexample CE1: typed payloads have no derivation chain within the contract's closed-world evaluation model, violating C7 (provenance as semantics). Candidate B also had a composition failure with Flow: the Flow formalism has no mechanism to consume payload values, and adding one exceeds P7 scope. Candidate C was not eliminated by counterexamples (CE2 and CE6 were scope narrowings) but was rejected in Phase 4 selection: the indirection through OutcomeDecl adds a new construct kind with disproportionate cost, decontextualizes outcome semantics, and creates non-local dependencies. Candidate A's canonical form establishes Operation-local outcome sets (paralleling the existing error_contract pattern), exhaustive Flow outcome handling, and explicit effect-to-outcome associations for multi-outcome Operations. AL13 is superseded: outcome routing is no longer Flow-side classification only -- it is grounded in Operation-declared outcomes."
}
