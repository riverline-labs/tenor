{
  "protocol": {
    "name": "Constraint-First Formalization Protocol",
    "version": "0.2.1",
    "description": "Invariant-driven semantic design. Candidates survive pressure or die."
  },
  "construct": {
    "name": "Flow Migration Compatibility",
    "description": "Formal conditions under which an in-flight flow at position p in contract v1 can be safely force-migrated to contract v2. Defines forward path existence, backward data dependency satisfaction, entity state equivalence, directional asymmetry, position sensitivity, recursive sub-flow compatibility, and semantic non-interference. Extends Phase 3.1 migration taxonomy with flow-level per-position compatibility refinement.",
    "depends_on": ["Flow", "Operation", "Entity", "Rule", "Fact", "Migration Semantics"]
  },
  "version": "1.0",
  "phase1": {
    "invariants": [
      {
        "id": "FMC1",
        "description": "Forward path existence: For every step in every reachable future path from position p in v1, there must exist a step in v2 with equivalent semantics. Step equivalence requires: (a) the same operation reference (operation id), (b) a compatible persona (the step's persona exists in v2's persona declarations and is in the operation's allowed_personas in v2), and (c) compatible routing (every outcome declared by the v2 operation is handled by the step, and every routing target step exists in v2). Reachable future paths are computed per S6 (Section 15) from the current position to all terminal states, including all branches of BranchStep (if_true, if_false), all outcomes of OperationStep, success and failure paths of SubFlowStep, and all branches of ParallelStep.",
        "testable": true,
        "structural": true,
        "class": "completeness"
      },
      {
        "id": "FMC2",
        "description": "Backward data dependency satisfaction: All data dependencies of v2 steps in reachable future paths from position p must be satisfiable from the execution context established by v1's partial execution. Data dependencies for a v2 step are: (a) fact references in the step's operation precondition must have values available in the frozen snapshot (taken at v1 flow initiation), (b) verdict references (verdict_present checks) in the step's operation precondition must be satisfiable from the frozen verdict snapshot, (c) entity states required as transition sources by the step's operation effects must be reachable from the current entity state via v2's transition declarations, (d) the step's persona must be authorized under v2's persona and operation definitions. A dependency is satisfiable if the required value exists in the frozen snapshot, or the required entity state is the current state or reachable via v2 transitions from the current state, or the required fact has a declared default in v2.",
        "testable": true,
        "structural": true,
        "class": "soundness"
      },
      {
        "id": "FMC3",
        "description": "Entity state equivalence: Every entity whose state was established by v1 execution up to position p must have that state available in v2's entity definition. Formally: for every entity e referenced by any step in any reachable future path from p, if the current state of e (as established by v1 operations executed before p) is s, then s must be a member of v2's entity declaration for e. Additionally, v2's entity declaration for e must include all states that are transition targets in v2 operations reachable from p, and those transition sources must be reachable from s via v2's declared transitions.",
        "testable": true,
        "structural": true,
        "class": "soundness"
      },
      {
        "id": "FMC4",
        "description": "Directional asymmetry: The compatibility function must account for the structural asymmetry between v1's executed path and v2's expected path. When v2 introduces new steps between existing steps, or changes existing steps to have stronger preconditions, the new data dependencies may reference state (facts, verdicts, entity states) that v1's execution path never established because v1 never executed the steps that would produce them. Forward path existence (FMC1) alone is insufficient -- a path may exist structurally in v2 but be unexecutable because its data dependencies assume a v2-specific execution history that the v1 flow does not have. Directional asymmetry is not a separate compatibility check but a structural property that FMC2 must capture: the data dependency check must evaluate v2's dependencies against v1's actual execution context (frozen snapshot plus current entity states), not against v2's assumed execution context.",
        "testable": true,
        "structural": true,
        "class": "soundness"
      },
      {
        "id": "FMC5",
        "description": "Position sensitivity: Flow compatibility is a function of (flow_def_v1, flow_def_v2, current_position, current_entity_states, frozen_snapshot) -- not a static property of two flow definitions alone. The same pair of flow definitions (v1, v2) may yield compatible at one position and incompatible at another. This means compatibility analysis must be performed per-flow-instance (since each instance has a specific position and entity state), not per-flow-type. The compatibility function signature is: compatible(v1_flow, v2_flow, position, entity_states, snapshot) -> {compatible, incompatible(reasons)}.",
        "testable": true,
        "structural": true,
        "class": "determinism"
      },
      {
        "id": "FMC6",
        "description": "Recursive sub-flow compatibility: If a reachable future path from position p includes a SubFlowStep that references sub-flow F, then F must itself be compatibility-checked at its entry point under the same conditions. The sub-flow inherits the parent flow's frozen snapshot (Section 11.4) and operates within the same entity state context. Compatibility checking is transitive through the flow reference DAG: if F references sub-flow G via a SubFlowStep, G must also be checked. Cyclic sub-flow references are prohibited by the Tenor spec (flows are acyclic DAGs), so the transitive check terminates.",
        "testable": true,
        "structural": true,
        "class": "completeness"
      },
      {
        "id": "FMC7",
        "description": "No semantic side effects: The compatibility analysis is a deployment-time static check. It does not modify the flow execution semantics of either v1 or v2. A flow that passes the compatibility check executes under v2 semantics exactly as if it had been initiated under v2. A flow that fails the compatibility check continues under v1 semantics (or is aborted, depending on executor policy) with no change to its evaluation model. The compatibility function is a pure function with no side effects on flow state, entity state, snapshots, or verdicts.",
        "testable": true,
        "structural": true,
        "class": "soundness"
      }
    ]
  },
  "phase2": {
    "candidates": [
      {
        "id": "A",
        "description": "Graph-theoretic: Define compatibility as a graph morphism from v1's reachable subgraph at position p to v2's step graph. A flow is compatible iff for every path in the reachable subgraph of v1, there exists a corresponding path in v2 with step equivalence at each node and data dependency satisfaction at each edge.",
        "formalism": {
          "structure": "Let G1(p) = the reachable subgraph of v1's flow from position p. G1(p) is a directed acyclic graph where nodes are steps and edges are routing transitions (outcome-to-next-step mappings). Let G2 = v2's complete flow step graph. Compatibility holds iff there exists a graph homomorphism h: G1(p) -> G2 such that: (1) for every node s in G1(p), h(s) is step-equivalent to s (same operation id, compatible persona, compatible outcome routing), (2) for every edge (s, t) in G1(p) labeled with outcome o, there exists an edge (h(s), h(t)) in G2 labeled with outcome o, (3) for every node h(s) in the image of h, all data dependencies of h(s) are satisfiable from the frozen snapshot and current entity states. Step equivalence: equiv(s1, s2) = (s1.operation == s2.operation) AND (s2.persona is in s2.operation.allowed_personas in v2) AND (for every outcome o declared by s2.operation in v2, s2 has a routing entry for o).",
          "evaluation_rule": "The compatibility check traverses G1(p) in topological order (guaranteed to terminate since flows are DAGs). For each node s, find the corresponding node h(s) in G2 by operation id match. Verify step equivalence. Verify data dependency satisfaction for h(s) against the frozen snapshot. If any node fails, return incompatible with the failing node and reason. If all nodes pass, return compatible. ParallelStep: all branches must have corresponding compatible branches in v2. SubFlowStep: recursively check the referenced sub-flow at its entry point.",
          "resolution_rule": "The graph morphism h is uniquely determined by step id matching (v1 step_id maps to v2 step with same step_id). If no v2 step has the same step_id, compatibility fails (FMC1 violation). If the step_id exists but has different semantics, compatibility depends on step equivalence and data dependency checks. Resolution is deterministic: the mapping is identity on step ids."
        },
        "claims": [
          {
            "invariant_id": "FMC1",
            "argument": "The graph homomorphism requirement (condition 1) directly encodes FMC1: every step in G1(p) must map to a step-equivalent step in G2. The path preservation requirement (condition 2) ensures that routing structure is preserved. Together, these guarantee that every reachable future path from p has a structurally equivalent path in v2."
          },
          {
            "invariant_id": "FMC2",
            "argument": "Condition 3 of the graph homomorphism checks data dependency satisfaction for every node in the image of h. The evaluation rule specifies that dependencies are checked against the frozen snapshot and current entity states. This captures FMC2's requirement that v2 steps' dependencies must be satisfiable from v1's established context."
          },
          {
            "invariant_id": "FMC3",
            "argument": "Entity state equivalence is subsumed by the data dependency check (condition 3). Each step's operation effects specify entity state transitions with source and target states. If the source state does not exist in v2's entity definition, the dependency check fails. The graph-theoretic model treats entity state as a data dependency rather than a separate condition."
          },
          {
            "invariant_id": "FMC4",
            "argument": "Directional asymmetry is captured by the evaluation rule: dependencies are checked against the frozen snapshot (established by v1 execution), not against v2's assumed execution history. If v2 introduces steps that would produce new verdicts or entity states, and downstream v2 steps depend on those new artifacts, the dependency check fails because the frozen snapshot does not contain them. The graph morphism structure does not inherently capture asymmetry -- it relies on the data dependency check to detect it."
          },
          {
            "invariant_id": "FMC5",
            "argument": "The compatibility function takes G1(p) as input, where p is the current position. Different positions produce different reachable subgraphs, which may or may not have valid morphisms to G2. Position sensitivity is inherent in the definition of G1(p)."
          },
          {
            "invariant_id": "FMC6",
            "argument": "The evaluation rule explicitly handles SubFlowStep by recursively checking the referenced sub-flow. The graph traversal recurses into sub-flows, creating a transitive compatibility check through the flow reference DAG."
          },
          {
            "invariant_id": "FMC7",
            "argument": "The graph morphism is a static analysis of graph structure and data dependencies. It does not execute any flow steps, modify any state, or produce any verdicts. The compatibility function is purely structural."
          }
        ]
      },
      {
        "id": "B",
        "description": "Predicate-based: Define compatibility as a conjunction of three independently evaluable predicates: ForwardPathExists(v1, v2, p), DataDependencySatisfied(v1, v2, p, snapshot), EntityStateEquivalent(v1, v2, entity_states). Each predicate is specified with precise input/output types and evaluation rules grounded in Tenor constructs.",
        "formalism": {
          "structure": "Compatibility(v1, v2, p, entity_states, snapshot) = ForwardPathExists(v1, v2, p) AND DataDependencySatisfied(v1, v2, p, entity_states, snapshot) AND EntityStateEquivalent(v1, v2, entity_states). Each predicate is defined independently: (1) ForwardPathExists(v1, v2, p) = for every step s in ReachablePaths(v1, p), there exists step s' in v2.steps where equiv(s, s') holds. (2) DataDependencySatisfied(v1, v2, p, entity_states, snapshot) = for every step s' in v2 that corresponds to a reachable step from p, all fact_ref in s'.operation.precondition are present in snapshot.facts, all verdict_present checks in s'.operation.precondition are satisfiable from snapshot.verdicts, all entity transition sources in s'.operation.effects are reachable from entity_states via v2 transitions, and s'.persona is authorized. (3) EntityStateEquivalent(v1, v2, entity_states) = for every (entity_id, state) in entity_states, state is in v2.entities[entity_id].states.",
          "evaluation_rule": "Evaluate predicates in order: FMC3 first (cheapest -- set membership), FMC1 second (graph structure), FMC2 last (most expensive -- requires dependency enumeration). Short-circuit on first failure. Each predicate returns (bool, Vec<Reason>) where Reason describes the specific failing condition. The conjunction is compatible iff all three predicates return true. Evaluation order is an optimization; the logical result is independent of order.",
          "resolution_rule": "Each predicate is deterministic given its inputs. ForwardPathExists uses the same step-id-based mapping as Candidate A. DataDependencySatisfied enumerates dependencies from v2's operation definitions (precondition fact_ref, verdict_present, effect transitions, persona). EntityStateEquivalent is a simple set membership check. No ambiguity in resolution."
        },
        "claims": [
          {
            "invariant_id": "FMC1",
            "argument": "ForwardPathExists directly encodes FMC1 as an independent predicate. It checks that every reachable step has a v2 equivalent with the same operation, compatible persona, and compatible routing."
          },
          {
            "invariant_id": "FMC2",
            "argument": "DataDependencySatisfied directly encodes FMC2 as an independent predicate. It enumerates all four dependency types (fact references, verdict references, entity state transitions, persona authorization) and checks each against the established context."
          },
          {
            "invariant_id": "FMC3",
            "argument": "EntityStateEquivalent directly encodes FMC3 as an independent predicate. It checks that every entity's current state exists in v2's entity definition."
          },
          {
            "invariant_id": "FMC4",
            "argument": "Directional asymmetry is captured by DataDependencySatisfied: when v2 steps reference verdicts or entity states that v1 never established, the predicate fails because those artifacts are absent from the frozen snapshot and current entity states. The predicate evaluates v2's dependencies against v1's actual execution context, not v2's assumed context."
          },
          {
            "invariant_id": "FMC5",
            "argument": "Position sensitivity is explicit in the function signature: Compatibility takes p (position) as an input parameter. ReachablePaths(v1, p) varies with p, so the predicate results vary with position."
          },
          {
            "invariant_id": "FMC6",
            "argument": "ForwardPathExists expands SubFlowStep references by recursively computing ReachablePaths for the referenced sub-flow and including those steps in the compatibility check. DataDependencySatisfied similarly expands sub-flow steps' dependencies."
          },
          {
            "invariant_id": "FMC7",
            "argument": "All three predicates are pure functions. They read flow definitions, entity states, and snapshots but do not modify any state. The compatibility check has no side effects."
          }
        ]
      },
      {
        "id": "C",
        "description": "Layered analysis: Separate the compatibility analysis into three layers corresponding to Tenor's isolation properties. Layer 1 (Verdict layer) leverages frozen snapshot semantics -- verdict changes do NOT affect in-flight flows, so no compatibility check is needed for Rule/Fact changes at the verdict level. Layer 2 (Entity state layer) checks FMC3 for all entities referenced by remaining steps. Layer 3 (Operation/flow structure layer) checks FMC1 + FMC2 for step structure and data dependencies. This candidate leverages the insight that frozen verdict semantics provide natural isolation for one entire layer of the analysis.",
        "formalism": {
          "structure": "LayeredCompatibility(v1, v2, p, entity_states, snapshot) = Layer1(v1, v2, snapshot) AND Layer2(v1, v2, p, entity_states) AND Layer3(v1, v2, p, entity_states, snapshot). Layer 1 (Verdict isolation): ALWAYS PASSES for in-flight flows. The frozen verdict snapshot taken at flow initiation (Section 11.4) is immutable. Changes to Rule definitions, Fact type changes, or Rule removal in v2 do not affect verdicts already frozen in the snapshot. No compatibility check needed for the verdict layer. Layer 2 (Entity state): For every entity e referenced by any step in ReachablePaths(v1, p), verify: (a) current state of e is in v2.entities[e].states, (b) all transition targets needed by v2 operations in remaining path are declared in v2.entities[e].transitions, (c) transitions from current state to needed target states exist in v2. Layer 3 (Operation/flow structure): For every step s in ReachablePaths(v1, p), verify: (a) v2 has a step with equivalent operation and persona (FMC1), (b) all non-verdict data dependencies of the v2 step are satisfiable -- fact references present in snapshot, entity state transitions valid per Layer 2, persona authorized (FMC2 minus the verdict component, which is isolated by Layer 1).",
          "evaluation_rule": "Layer 1 is a no-op for in-flight flows (always passes by construction). Layer 2 evaluates entity state membership and transition existence. Layer 3 evaluates step equivalence and non-verdict data dependencies. Evaluation order: Layer 1 (trivial), Layer 2 (entity state -- cheap set checks), Layer 3 (structure and dependencies -- most expensive). The layered decomposition enables targeted reporting: if Layer 2 fails, the executor knows the issue is entity state; if Layer 3 fails, the issue is structural or data dependency.",
          "resolution_rule": "Layer 1 resolution: frozen snapshot semantics are defined by Section 11.4. The snapshot is taken at flow initiation and is immutable for the flow's lifetime. Changes to Rule or Fact constructs in v2 do not retroactively modify the snapshot. This is a fundamental property of Tenor's evaluation model, not an assumption. Layer 2 and Layer 3 resolution follow the same deterministic rules as Candidate B's EntityStateEquivalent and ForwardPathExists/DataDependencySatisfied predicates."
        },
        "claims": [
          {
            "invariant_id": "FMC1",
            "argument": "Layer 3 checks forward path existence by verifying that every step in the reachable subgraph has a v2 equivalent with matching operation, persona, and routing. This is the same check as Candidates A and B, embedded within the layered framework."
          },
          {
            "invariant_id": "FMC2",
            "argument": "Data dependency satisfaction is split across Layer 1 and Layer 3. Verdict dependencies are handled by Layer 1 (frozen -- always satisfied for in-flight flows). Fact dependencies, entity state dependencies, and persona authorization are handled by Layer 3. The split leverages the insight that verdict dependencies are inherently satisfied by Tenor's frozen snapshot semantics, reducing the dependency check surface."
          },
          {
            "invariant_id": "FMC3",
            "argument": "Layer 2 directly checks entity state equivalence as a dedicated analysis layer. Entity states are NOT frozen by the snapshot (they are live, mutable state), so they require explicit compatibility checking. The layered model correctly identifies entity state as a non-isolated layer."
          },
          {
            "invariant_id": "FMC4",
            "argument": "Directional asymmetry is captured by Layer 3's data dependency check. When v2 introduces new steps whose operations require verdicts or facts not in the frozen snapshot, Layer 3 detects the missing dependencies. The layered model improves directional asymmetry detection by eliminating false positives: Rule changes that only affect verdict production are correctly identified as non-issues (Layer 1 isolation), while operation-level dependency changes that truly reflect directional asymmetry are flagged by Layer 3."
          },
          {
            "invariant_id": "FMC5",
            "argument": "Position sensitivity is inherent in the reachable path computation used by both Layer 2 and Layer 3. Different positions produce different reachable paths, which produce different entity references and step dependency checks."
          },
          {
            "invariant_id": "FMC6",
            "argument": "SubFlowStep references are expanded during Layer 3's step traversal. The referenced sub-flow's steps are included in the reachable path and checked for step equivalence and data dependency satisfaction. Layer 2 also includes entity references from sub-flow steps."
          },
          {
            "invariant_id": "FMC7",
            "argument": "All three layers are read-only analyses. Layer 1 is a property of the evaluation model (no computation needed). Layer 2 and Layer 3 are pure functions over flow definitions, entity definitions, and the frozen snapshot. No state is modified."
          }
        ]
      }
    ]
  },
  "phase3": {
    "counterexamples": [
      {
        "id": "CE1",
        "target_candidate": "all",
        "scenario": "Escrow release -- safe migration at step_check_threshold when only fact type widened",
        "test": "v1 flow: step_confirm -> step_check_threshold -> step_auto_release -> Terminal(success), with branching on threshold check. v2 changes only the compliance_threshold fact type from Money(precision:10, scale:2) to Money(precision:12, scale:2) -- a widening change. All steps, operations, entities, and routing are identical. In-flight v1 flow at position step_check_threshold. Check: FMC1 (all future steps exist in v2 with same operations), FMC2 (frozen snapshot has the compliance_threshold value at its original precision -- the widened type accepts it), FMC3 (EscrowAccount.held and DeliveryRecord.confirmed both exist in v2).",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["A", "B", "C"],
          "explanation": "All candidates correctly identify this as a safe migration. Candidate A: graph morphism exists (identity mapping on step ids), all data dependencies satisfied from frozen snapshot. Candidate B: all three predicates pass -- ForwardPathExists (identical step structure), DataDependencySatisfied (snapshot facts still valid under widened type), EntityStateEquivalent (same entity states). Candidate C: Layer 1 (verdict layer isolated), Layer 2 (entity states identical), Layer 3 (step structure identical, fact dependencies satisfied). The key insight is that the frozen snapshot contains the actual fact value, not the type declaration -- the widened type in v2 accepts the existing value."
        }
      },
      {
        "id": "CE2",
        "target_candidate": "A",
        "scenario": "Escrow with new compliance step -- unsafe migration at step_check_threshold due to directional asymmetry",
        "test": "v1 flow: step_confirm -> step_check_threshold -> step_auto_release -> Terminal(success). v2 flow: step_confirm -> step_compliance_check -> step_check_threshold -> step_auto_release -> Terminal(success). v2 adds step_compliance_check between step_confirm and step_check_threshold, and step_auto_release in v2 now has a precondition requiring verdict_present(compliance_cleared). In-flight v1 flow at step_check_threshold. The v1 flow never executed step_compliance_check, so the compliance_cleared verdict was never produced and is not in the frozen snapshot.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["A"],
          "explanation": "Candidate A correctly identifies this as unsafe. The graph morphism maps v1's step_check_threshold to v2's step_check_threshold (same step id). Forward path preservation holds (step_check_threshold -> step_auto_release -> Terminal exists in v2). However, condition 3 (data dependency satisfaction) fails: step_auto_release in v2 has a precondition referencing compliance_cleared verdict, which is not in the frozen snapshot because the v1 flow never executed step_compliance_check. The graph-theoretic model detects the directional asymmetry through its data dependency check. Candidate A survives because FMC4 (directional asymmetry) is captured by the dependency check, not the graph structure."
        }
      },
      {
        "id": "CE3",
        "target_candidate": "B",
        "scenario": "Escrow with new compliance step -- unsafe migration testing predicate decomposition",
        "test": "Same scenario as CE2: v2 adds step_compliance_check with downstream precondition dependency. In-flight v1 flow at step_check_threshold. Test whether the predicate-based decomposition correctly identifies which predicate fails and why.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["B"],
          "explanation": "Candidate B correctly identifies this as unsafe through the DataDependencySatisfied predicate. ForwardPathExists passes (step_check_threshold and step_auto_release exist in v2 with same operation ids). EntityStateEquivalent passes (entity states unchanged). DataDependencySatisfied fails: v2's step_auto_release.operation.precondition includes verdict_present(compliance_cleared), and this verdict is absent from snapshot.verdicts. The predicate-based model provides clear diagnostic: 'DataDependencySatisfied failed at step_auto_release: verdict compliance_cleared not in frozen snapshot.' This is superior to Candidate A's generic 'dependency check failed' because it identifies the specific predicate and dependency type."
        }
      },
      {
        "id": "CE4",
        "target_candidate": "C",
        "scenario": "Position-sensitive compatibility -- same flow pair, different positions yield different results",
        "test": "v2 removes entity state 'cancelled' from Order entity. v1 had states: [draft, submitted, approved, cancelled]. v2 has states: [draft, submitted, approved]. In-flight v1 flow has two instances: Instance A at step_submit_order (Order in state 'draft', no future path transitions to 'cancelled'), Instance B at step_cancel_order (Order in state 'submitted', this step transitions Order to 'cancelled'). Check both instances for compatibility.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["C"],
          "explanation": "Candidate C correctly handles position sensitivity through its layered analysis. Instance A: Layer 1 (isolated), Layer 2 (current state 'draft' exists in v2, no future path transitions to 'cancelled' -- PASS), Layer 3 (all steps in reachable path have v2 equivalents with satisfiable dependencies -- PASS). Result: COMPATIBLE. Instance B: Layer 1 (isolated), Layer 2 (current state 'submitted' exists in v2, BUT the step_cancel_order operation's effect transitions Order to 'cancelled' which does NOT exist in v2 -- FAIL). Result: INCOMPATIBLE. The layered model correctly produces different results for different positions of the same flow type, demonstrating FMC5 (position sensitivity). Layer 2 provides targeted diagnostics: 'Entity Order target state cancelled not in v2 entity definition.'"
        }
      },
      {
        "id": "CE5",
        "target_candidate": "all",
        "scenario": "Multi-week approval chain -- removed approval step, flow past vs. before the removed step",
        "test": "v1 flow: step_submit -> step_manager_approve -> step_director_approve -> step_vp_approve -> step_execute -> Terminal(success). v2 removes step_vp_approve (VP approval no longer required for amounts under $50k). v2 flow: step_submit -> step_manager_approve -> step_director_approve -> step_execute -> Terminal(success). In-flight v1 flow Instance A at step_director_approve: forward path includes step_vp_approve which does not exist in v2. Instance B at step_execute: forward path is only Terminal(success), which exists in v2.",
        "result": {
          "outcome": "narrowed",
          "candidates_tested": ["A", "B", "C"],
          "narrowing": "All candidates correctly identify Instance A as incompatible (FMC1 fails: step_vp_approve has no v2 equivalent) and Instance B as compatible (all remaining steps exist in v2). However, this scenario exposes a subtlety: in v1, step_director_approve routes success to step_vp_approve. In v2, step_director_approve routes success to step_execute. The step_director_approve step itself has CHANGED ROUTING even though its operation is the same. For Instance A at step_director_approve: the current step's routing in v2 goes to step_execute (not step_vp_approve), which means the v1 flow at step_director_approve would use v2's routing and skip step_vp_approve entirely. This is actually compatible -- the flow migrates to v2's routing and proceeds directly to step_execute. SCOPE NARROWING: step equivalence should compare operation and persona only, not routing. Routing at the current step uses v2's definition (the flow is migrating TO v2). The forward path check should use v2's routing from the current position, not v1's routing.",
          "limitation_description": "Step equivalence for the CURRENT step (at position p) should use v2's routing definition, since the flow is migrating to v2. For steps AHEAD of position p, the reachable path should be computed using v2's step graph from the current position. FMC1's 'reachable future paths from position p in v1' should be refined to: 'reachable future paths from position p using v2's step graph.' The v1 step graph is relevant only to determine the current position; all forward analysis uses v2's definitions."
        }
      },
      {
        "id": "CE6",
        "target_candidate": "all",
        "scenario": "Subscription lifecycle -- new outcome on billing operation makes positions incompatible",
        "test": "v1 flow: step_activate -> step_bill -> step_renew_check -> Terminal(success|failure). v1 operation bill_subscriber has outcomes: [paid, declined]. v2 adds outcome 'prorated' to bill_subscriber. v2 flow handles all three outcomes at step_bill. In-flight v1 flow at step_activate (before step_bill): check if the flow can migrate to v2. v1's step_bill only handles outcomes [paid, declined] but v2's bill_subscriber operation declares [paid, declined, prorated]. Since the flow is migrating to v2, step_bill should use v2's step definition which handles all three outcomes.",
        "result": {
          "outcome": "narrowed",
          "candidates_tested": ["A", "B", "C"],
          "narrowing": "This scenario interacts with the CE5 narrowing. If the migrated flow uses v2's step definitions (including v2's routing for step_bill which handles the new 'prorated' outcome), then compatibility holds -- v2's step_bill handles all outcomes of v2's bill_subscriber operation. The operation change (adding 'prorated') is a construct-level BREAKING change per Section 17.2.5 (exhaustive outcome handling), but at the flow level, if v2's flow already handles the new outcome, the migrated flow is compatible. SCOPE NARROWING: flow-level compatibility should check v2's step definitions against v2's operation definitions (since the migrated flow executes under v2). The construct-level breaking change taxonomy (Section 17.2) provides the initial signal; the flow-level compatibility check provides the per-instance refinement.",
          "limitation_description": "Flow-level compatibility refines construct-level breaking change classification. A construct-level BREAKING change (new operation outcome) may be flow-level COMPATIBLE if v2's flow definition already handles the new outcome. The compatibility check evaluates v2's step definitions against v2's operation definitions for the reachable path from the current position. This means flow compatibility is more permissive than construct-level classification for outcome additions when v2's flow is updated to handle them."
        }
      },
      {
        "id": "CE7",
        "target_candidate": "all",
        "scenario": "SubFlowStep with changed sub-flow -- recursive compatibility check",
        "test": "v1 main flow: step_initiate -> step_run_audit(SubFlowStep referencing audit_flow) -> step_finalize -> Terminal(success). v1 audit_flow: step_collect -> step_review -> Terminal(success). v2 changes audit_flow: step_collect -> step_automated_screen -> step_review -> Terminal(success). v2 adds step_automated_screen which has a precondition requiring fact audit_config that was not present in v1's fact declarations. In-flight v1 main flow at step_initiate: the next step is step_run_audit which references audit_flow. Recursive compatibility check on audit_flow at its entry point (step_collect).",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["A", "B", "C"],
          "explanation": "All candidates correctly identify this as unsafe through recursive compatibility checking. The main flow's step_run_audit references audit_flow. Recursive check on audit_flow at entry (step_collect): FMC1 passes (step_collect and step_review exist in v2, step_automated_screen is a new step only reachable via v2's routing). Per the CE5 narrowing, the reachable path from step_collect uses v2's graph, which includes step_automated_screen. FMC2 fails: step_automated_screen's operation precondition references fact audit_config, which is not in the frozen snapshot (v1 never declared this fact). The sub-flow is incompatible, making the parent flow incompatible at step_initiate. Candidate A: graph morphism fails at sub-flow level (dependency check). Candidate B: DataDependencySatisfied fails recursively. Candidate C: Layer 3 fails at sub-flow step_automated_screen (missing fact dependency)."
        }
      },
      {
        "id": "CE8",
        "target_candidate": "all",
        "scenario": "ParallelStep with changed branch -- both branches must be compatible",
        "test": "v1 flow: step_start -> step_parallel(branches: [branch_verify, branch_prepare]) -> step_complete -> Terminal(success). branch_verify: step_id_check -> step_address_check -> Terminal. branch_prepare: step_account_setup -> Terminal. v2 changes branch_verify to add step_credit_check after step_id_check, with a new precondition requiring verdict_present(identity_verified) produced by step_id_check. In-flight v1 flow at step_start (about to enter step_parallel). Check compatibility of both branches.",
        "result": {
          "outcome": "narrowed",
          "candidates_tested": ["A", "B", "C"],
          "narrowing": "All candidates check both parallel branches independently. branch_prepare: unchanged, compatible. branch_verify: v2 adds step_credit_check with precondition verdict_present(identity_verified). If step_id_check's operation produces a verdict of type identity_verified, this verdict would be produced during v2 execution of the branch (the flow has not yet started the parallel branches). Since the parallel branches have not executed yet (flow is at step_start), the verdicts needed by step_credit_check would be produced by earlier steps in the same branch (step_id_check). SCOPE NARROWING: data dependency satisfaction should consider not only the frozen snapshot but also verdicts/state that would be produced by steps WITHIN the remaining path that execute BEFORE the dependent step. This is a refinement of FMC2: dependencies can be satisfied by (a) frozen snapshot, (b) current entity states, (c) verdicts/facts produced by steps earlier in the same execution path within v2.",
          "limitation_description": "FMC2 data dependency satisfaction should account for intra-path production: a v2 step's dependency may be satisfied by a verdict or entity state produced by an earlier v2 step in the same execution path. However, computing intra-path production requires symbolic execution of v2's remaining path, which may be undecidable in general (operation outcomes determine which path is taken, and outcomes are not known statically). Conservative approach: only consider dependencies satisfiable from the frozen snapshot and current entity states. Aggressive approach: also consider dependencies satisfiable from v2 steps that MUST execute before the dependent step (i.e., steps that are on every path from the current position to the dependent step). The conservative approach may reject safe migrations; the aggressive approach requires path dominance analysis."
        }
      },
      {
        "id": "CE9",
        "target_candidate": "C",
        "scenario": "Frozen verdict isolation -- Rule changes do NOT break compatibility because verdicts are frozen",
        "test": "v1 contract declares rule classify_amount that produces verdict amount_category. v1 flow uses step_check_category whose operation has precondition verdict_present(amount_category). v2 changes the rule's predicate (widened condition) and changes the verdict payload type. In-flight v1 flow at step_check_category. The frozen verdict snapshot already contains amount_category (produced at flow initiation under v1's rules). Does the Rule change affect compatibility?",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["C"],
          "explanation": "Candidate C correctly identifies this as COMPATIBLE via Layer 1 (verdict isolation). The frozen verdict snapshot was created at flow initiation under v1's rules. The snapshot is immutable -- it is not affected by v2's Rule changes. When the migrated flow reaches step_check_category, the precondition verdict_present(amount_category) checks the FROZEN snapshot, which still contains the v1-produced verdict. Layer 1 correctly classifies all verdict-layer changes as non-issues for in-flight flows. Candidates A and B would also reach the correct result (the verdict is in the snapshot, so the dependency check passes), but Candidate C's explicit Layer 1 isolation provides a clearer conceptual model: verdict changes are categorically safe for in-flight flows, no per-step analysis needed."
        }
      },
      {
        "id": "CE10",
        "target_candidate": "A",
        "scenario": "Graph morphism limitation -- step id collision with different semantics",
        "test": "v1 flow: step_A(operation: check_balance) -> step_B(operation: transfer) -> Terminal. v2 flow: step_A(operation: verify_identity) -> step_B(operation: transfer) -> Terminal. v2 changes step_A's operation from check_balance to verify_identity. The step ids are the same but the operations are different. In-flight v1 flow at step_A.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["A"],
          "explanation": "Candidate A's resolution rule maps v1 steps to v2 steps by step_id. step_A maps to v2's step_A, but step equivalence check fails: v1 step_A.operation = check_balance, v2 step_A.operation = verify_identity. These are different operations, so equiv(v1.step_A, v2.step_A) = false. FMC1 fails. Candidate A correctly identifies this as incompatible. The step-id-based mapping finds the corresponding step but the equivalence check catches the semantic change. Per the CE5 narrowing (reachable path uses v2's graph from current position), the current step is at step_A and v2's step_A has a different operation -- the flow cannot continue under v2 because the expected operation semantics have changed."
        }
      },
      {
        "id": "CE11",
        "target_candidate": "B",
        "scenario": "Persona authorization change makes step incompatible",
        "test": "v1 flow: step_approve(operation: approve_order, persona: manager). v1 operation approve_order has allowed_personas: [manager, director]. v2 changes allowed_personas to [director] (removes manager). In-flight v1 flow at step_approve with persona manager. The step's persona (manager) is no longer authorized for the operation in v2.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["B"],
          "explanation": "Candidate B's DataDependencySatisfied predicate includes persona authorization checking. For step_approve in v2, the operation approve_order now requires persona in [director]. The v1 flow step specifies persona: manager. DataDependencySatisfied checks: is manager in v2's approve_order.allowed_personas? No -- manager was removed. The predicate fails with reason: 'persona manager not in allowed_personas [director] for operation approve_order at step_approve.' Candidate B correctly identifies this as incompatible, demonstrating that persona changes are first-class compatibility conditions, not just structural annotations."
        }
      },
      {
        "id": "CE12",
        "target_candidate": "C",
        "scenario": "Entity parent change disrupts state propagation for in-flight flow",
        "test": "v1 declares entity LineItem { parent: Order, states: [pending, approved], ... }. v2 changes entity LineItem { parent: Account, states: [pending, approved], ... }. In-flight v1 flow at step_approve_line_item: the operation transitions LineItem from pending to approved, with state propagation to parent Order. In v2, the parent is Account, so propagation would go to Account instead of Order.",
        "result": {
          "outcome": "survives",
          "candidates_tested": ["C"],
          "explanation": "Candidate C's Layer 2 (entity state layer) checks entity state equivalence. The current state 'pending' exists in v2 (PASS). The target state 'approved' exists in v2 (PASS). However, the parent entity changed from Order to Account. If the operation's effects rely on parent state propagation, the propagation target changes. Layer 2 detects this through the entity definition change: v2's LineItem.parent is Account, but the current entity state context has propagation chains to Order. Layer 3 also catches this: the operation's effects in v2 would propagate to Account, but the in-flight flow's entity state context has Order as the parent. This is correctly identified as INCOMPATIBLE. The parent field change for an in-flight entity disrupts the state propagation chain."
        }
      }
    ]
  },
  "derived": {
    "eliminated": [],
    "survivors": [
      {
        "candidate_id": "A",
        "scope_narrowings": [
          "Step equivalence should compare operation and persona only; routing at the current step uses v2's definition since the flow is migrating to v2.",
          "Flow-level compatibility refines construct-level breaking change classification -- a construct-level BREAKING change may be flow-level COMPATIBLE if v2's flow handles the change.",
          "Data dependency satisfaction should account for intra-path production (verdicts/state produced by earlier v2 steps in the same execution path), though conservative analysis may omit this."
        ]
      },
      {
        "candidate_id": "B",
        "scope_narrowings": [
          "Step equivalence should compare operation and persona only; routing at the current step uses v2's definition since the flow is migrating to v2.",
          "Flow-level compatibility refines construct-level breaking change classification -- a construct-level BREAKING change may be flow-level COMPATIBLE if v2's flow handles the change.",
          "Data dependency satisfaction should account for intra-path production (verdicts/state produced by earlier v2 steps in the same execution path), though conservative analysis may omit this."
        ]
      },
      {
        "candidate_id": "C",
        "scope_narrowings": [
          "Step equivalence should compare operation and persona only; routing at the current step uses v2's definition since the flow is migrating to v2.",
          "Flow-level compatibility refines construct-level breaking change classification -- a construct-level BREAKING change may be flow-level COMPATIBLE if v2's flow handles the change.",
          "Data dependency satisfaction should account for intra-path production (verdicts/state produced by earlier v2 steps in the same execution path), though conservative analysis may omit this."
        ]
      }
    ]
  },
  "phase4": {
    "attempted": true,
    "succeeded": true,
    "collapse_test": {
      "description": "All three candidates survived Phase 3 pressure testing with identical scope narrowings. The question is whether any candidate strictly subsumes the others. Candidate A (graph-theoretic) provides the structural framework (graph morphism for path matching) but treats entity state as a generic data dependency. Candidate B (predicate-based) provides the decomposition (three independent predicates) with clear diagnostic reporting but does not leverage Tenor's frozen verdict isolation. Candidate C (layered analysis) subsumes both: it incorporates A's graph traversal in Layer 3, B's predicate decomposition across its three layers, AND adds the frozen verdict isolation insight (Layer 1) that neither A nor B explicitly models. The Layer 1 insight is not just an optimization -- it is a correctness property: Candidate C correctly identifies verdict-layer changes as categorically safe for in-flight flows (CE9), while A and B reach the same result through the more expensive path of checking each verdict dependency against the frozen snapshot. C's layered model also provides superior diagnostics: failures are categorized by layer (verdict/entity/structure), not just by step.",
      "result": "Candidate C (layered analysis) subsumes Candidates A and B. Candidate C's three layers map directly to the three invariant conditions (FMC1+FMC2 in Layer 3, FMC3 in Layer 2) while adding Layer 1 as a correctness optimization. The graph-theoretic path traversal from Candidate A is used within Layer 3. The predicate decomposition from Candidate B maps to the three layers. Candidate C adds the frozen verdict isolation property that is unique to Tenor's evaluation model."
    },
    "selected_candidate": {
      "id": "C_merged",
      "description": "Layered Flow Migration Compatibility Analysis (Candidate C subsumes A and B). The compatibility check is decomposed into three analysis layers corresponding to Tenor's isolation properties: Layer 1 (Verdict isolation -- always passes for in-flight flows due to frozen snapshot semantics), Layer 2 (Entity state equivalence -- checks current entity states against v2 definitions), Layer 3 (Operation/flow structure -- checks forward path existence and non-verdict data dependency satisfaction using graph traversal from Candidate A and predicate decomposition from Candidate B).",
      "formalism": {
        "structure": "Compatible(v1, v2, p, entity_states, snapshot) = Layer1(snapshot) AND Layer2(v2, p, entity_states) AND Layer3(v1, v2, p, entity_states, snapshot). Layer 1: PASSES by construction for in-flight flows. Frozen verdict snapshot (Section 11.4) is immutable; verdict-layer changes in v2 (Rule changes, Fact type changes affecting verdict production) do not affect the snapshot. Layer 2: For every entity e referenced by any step in ReachablePaths(v2, p), verify current_state(e) is in v2.entities[e].states AND all transition targets needed by v2 operations in the remaining path are declared in v2.entities[e].transitions AND transitions from current_state(e) to needed targets exist. Layer 3: For every step s in ReachablePaths(v2, p), verify (a) v2 has a step with same operation id and authorized persona [FMC1], (b) all fact_ref dependencies of s.operation.precondition are present in snapshot.facts, all entity state transition sources are satisfied per Layer 2, and persona is authorized [FMC2 minus verdict component]. ReachablePaths uses v2's step graph from position p (per CE5 narrowing). Step equivalence checks operation id and persona only (per CE5 narrowing).",
        "evaluation_rule": "Evaluate layers in order: Layer 1 (trivial -- no computation), Layer 2 (entity state -- set membership checks), Layer 3 (structure and dependencies -- graph traversal with dependency enumeration). Short-circuit on first failure. Layer 3 uses topological traversal of v2's reachable step graph from position p. For SubFlowStep: recursively check the referenced sub-flow at its entry point (FMC6). For ParallelStep: check all branches independently; all must be compatible. Return structured result: compatible | incompatible(layer, step, reason).",
        "resolution_rule": "Layer 1 resolution is a theorem of Tenor's evaluation model (Section 11.4 frozen snapshot semantics). Layer 2 resolution is set membership in v2's entity state declarations. Layer 3 resolution uses step-id-based mapping from v1 position to v2 steps, with equivalence defined as same operation id + authorized persona. Routing is always v2's definition (the flow migrates to v2). All resolution is deterministic given the inputs."
      },
      "claims": [
        {
          "invariant_id": "FMC1",
          "argument": "Layer 3 checks forward path existence by traversing ReachablePaths(v2, p) and verifying that each step has the expected operation and authorized persona. The graph traversal from Candidate A provides the structural analysis. Routing uses v2's step graph (per CE5 narrowing)."
        },
        {
          "invariant_id": "FMC2",
          "argument": "Data dependency satisfaction is decomposed across layers. Verdict dependencies are categorically satisfied by Layer 1 (frozen snapshot immutability). Entity state dependencies are checked by Layer 2. Fact dependencies and persona authorization are checked by Layer 3. The decomposition leverages Tenor's isolation properties for correctness and efficiency."
        },
        {
          "invariant_id": "FMC3",
          "argument": "Layer 2 directly checks entity state equivalence as a dedicated analysis layer. Entity states are live (not frozen), so they require explicit checking against v2's entity definitions."
        },
        {
          "invariant_id": "FMC4",
          "argument": "Directional asymmetry is captured by Layer 3's data dependency check against the frozen snapshot (established by v1 execution). When v2 steps require facts or verdicts that v1 never produced, Layer 3 detects the missing dependencies. Layer 1 improves asymmetry detection by eliminating false positives: Rule changes that only affect verdict production are correctly classified as non-issues."
        },
        {
          "invariant_id": "FMC5",
          "argument": "Position sensitivity is inherent in the function signature: Compatible takes p (position) and entity_states as inputs. ReachablePaths(v2, p) varies with p, producing different results for different positions."
        },
        {
          "invariant_id": "FMC6",
          "argument": "Layer 3's traversal recursively expands SubFlowStep references, checking the sub-flow at its entry point. The flow reference DAG is acyclic (Tenor spec constraint), so recursion terminates."
        },
        {
          "invariant_id": "FMC7",
          "argument": "All three layers are pure read-only analyses. No flow state, entity state, snapshot, or verdict is modified. The compatibility function is side-effect-free."
        }
      ]
    },
    "replaces": ["A", "B", "C"]
  },
  "phase5": {
    "obligations": [
      {
        "id": "SO1",
        "property": "Flow path enumeration from any position. Given a flow definition F and a position p (step id), compute ReachablePaths(F, p) -- the set of all execution paths from p to terminal states.",
        "argument": "ReachablePaths is defined by S6 (Section 15: Static Analysis Obligations). The computation traverses the flow's step graph from position p, following all routing edges. For OperationStep: one successor per declared outcome. For BranchStep: two successors (if_true, if_false). For SubFlowStep: success path + failure handler path. For ParallelStep: all branch entry points, plus the join step. Terminal states are explicit (Terminal(success), Terminal(failure)). The graph is a DAG (no cycles in Tenor flows), so traversal terminates. The output is a set of paths, each represented as an ordered sequence of step ids.",
        "provable": true,
        "static_analysis_ref": "S6"
      },
      {
        "id": "SO2",
        "property": "Step equivalence checker. Given a v1 step s and a v2 step s', determine whether they are equivalent for migration compatibility purposes.",
        "argument": "Step equivalence is defined as: equiv(s, s') = (s.operation_id == s'.operation_id) AND (s'.persona is in s'.operation.allowed_personas in v2). Routing is NOT part of step equivalence (per CE5 scope narrowing -- the migrated flow uses v2's routing). This is a pure structural comparison of two step definitions against v2's operation definitions. The check is decidable and deterministic.",
        "provable": true
      },
      {
        "id": "SO3",
        "property": "Data dependency enumerator. Given a v2 step s and the corresponding v2 operation definition, enumerate all data dependencies: fact references, verdict references, entity state transition sources, and persona authorization requirements.",
        "argument": "Dependencies are extracted from the v2 operation definition: (a) fact_ref nodes in operation.precondition expression tree -> fact dependencies, (b) verdict_present nodes in operation.precondition -> verdict dependencies, (c) operation.effects[*].from_state -> entity state dependencies, (d) step.persona cross-referenced with operation.allowed_personas -> persona dependencies. Each dependency type has a clear extraction rule from the interchange JSON structure. The enumeration is deterministic and complete (all dependencies are structurally present in the operation definition).",
        "provable": true
      },
      {
        "id": "SO4",
        "property": "Position-sensitive compatibility function. Takes (v1_flow, v2_flow, position, entity_states, snapshot) and returns compatible | incompatible(layer, step, reasons).",
        "argument": "This is the top-level entry point implementing the C_merged candidate's three-layer analysis. Layer 1: no computation (frozen verdict isolation). Layer 2: for each entity referenced in ReachablePaths(v2, position), check current state membership in v2's entity definition. Layer 3: for each step in ReachablePaths(v2, position), check step equivalence (SO2) and data dependency satisfaction (SO3) against the snapshot. Return structured result with layer, step, and reason for any failure. The function is a composition of SO1, SO2, and SO3.",
        "provable": true
      },
      {
        "id": "SO5",
        "property": "Per-flow-instance migration recommendation in diff output. When `tenor diff --breaking` reports flow-level changes, include compatible_positions and incompatible_positions for each active flow type.",
        "argument": "Given a set of flow instances (each with a flow type, position, and entity states), the compatibility function (SO4) is evaluated for each instance. The diff output groups results by flow type and reports: (a) positions where force-migration is safe (all compatibility layers pass), (b) positions where force-migration is unsafe (at least one layer fails) with the specific failure reasons, (c) a summary recommendation per flow type (all_compatible, partially_compatible, all_incompatible). This enables per-flow-type policy decisions: an executor can force-migrate compatible instances while applying blue-green or abort to incompatible ones.",
        "provable": true
      }
    ],
    "all_provable": true
  },
  "phase6": {
    "canonical": {
      "construct": "Flow Migration Compatibility",
      "formal_statement": "Flow Migration Compatibility defines the formal conditions under which an in-flight flow instance, currently at position p in contract version v1, can be safely force-migrated to contract version v2.\n\nDEFINITION. A flow instance is COMPATIBLE for force-migration from v1 to v2 at position p if and only if all three of the following conditions hold:\n\n1. FORWARD PATH EXISTENCE (FMC1): For every step s in ReachablePaths(v2, p) -- the set of all steps reachable from position p using v2's flow step graph -- there exists a step in v2 with equivalent semantics. Step equivalence requires: the step references the same operation (by operation id), and the step's persona is authorized for that operation under v2's definitions (the persona exists in v2 and is in the operation's allowed_personas). Routing is evaluated using v2's step definitions, since the migrated flow executes under v2.\n\n2. DATA DEPENDENCY SATISFACTION (FMC2): For every step s in ReachablePaths(v2, p), all data dependencies of s's operation under v2 are satisfiable from the execution context established by v1's partial execution:\n   (a) Fact dependencies: Every fact_ref in the operation's precondition expression must have a value in the frozen snapshot (taken at v1 flow initiation per Section 11.4), or the fact must have a declared default in v2.\n   (b) Verdict dependencies: Satisfied by construction. The frozen verdict snapshot is immutable (Section 11.4). Changes to Rule definitions, Fact types affecting verdict production, or Rule removal in v2 do not affect verdicts already frozen in the snapshot. Verdict-layer changes are categorically safe for in-flight flows.\n   (c) Entity state dependencies: The entity state required as a transition source by the operation's effects must be the current state of the entity (as established by v1 execution) or reachable from the current state via v2's declared transitions. Checked by Layer 2 (see below).\n   (d) Persona authorization: The step's persona must be in the operation's allowed_personas under v2's definitions.\n\n3. ENTITY STATE EQUIVALENCE (FMC3): For every entity e referenced by any step in ReachablePaths(v2, p), the current state of e (as established by v1 operations executed before position p) must be a member of v2's entity declaration for e. Additionally, all entity states that are transition targets of v2 operations in the reachable path must be declared in v2's entity definition, and transitions from the current state to those targets must exist in v2's transition declarations.\n\nSTRUCTURAL PROPERTIES:\n\n4. DIRECTIONAL ASYMMETRY (FMC4): Conditions 1-3 inherently account for directional asymmetry. When v2 introduces new steps between existing steps, or changes existing steps to have stronger preconditions, the new data dependencies are checked against v1's actual execution context (frozen snapshot and current entity states), not against v2's assumed execution history. A dependency that v2's execution path would naturally satisfy (because v2 would execute the step that produces it) may fail for a migrated v1 flow that never executed that step. This is the fundamental asymmetry: v1's executed path and v2's expected path may have different side-effect histories.\n\n5. POSITION SENSITIVITY (FMC5): Compatibility is a function of (v1_flow, v2_flow, position, entity_states, snapshot). The same pair of flow definitions may be compatible at one position and incompatible at another. Compatibility analysis must be performed per-flow-instance, not per-flow-type, because each instance has a specific position and entity state context.\n\n6. RECURSIVE SUB-FLOW COMPATIBILITY (FMC6): If the reachable path from position p includes a SubFlowStep referencing sub-flow F, then F must be compatibility-checked at its entry point under the same conditions (same frozen snapshot, same entity state context). Compatibility checking is transitive through the flow reference DAG. The DAG is acyclic (Tenor spec constraint), so the transitive check terminates.\n\n7. SEMANTIC NON-INTERFERENCE (FMC7): The compatibility analysis is a deployment-time static check with no side effects. It does not modify flow execution semantics, entity states, snapshots, or verdicts under either v1 or v2.\n\nTHREE-LAYER ANALYSIS MODEL:\n\nThe compatibility check is implemented as a three-layer analysis corresponding to Tenor's isolation properties:\n\n- Layer 1 (Verdict layer): ALWAYS PASSES for in-flight flows. The frozen verdict snapshot (Section 11.4) is immutable. Changes to Rule definitions, Fact types, or Rule removal in v2 do not affect verdicts already in the snapshot. This is a theorem of Tenor's evaluation model, not an assumption.\n\n- Layer 2 (Entity state layer): Checks FMC3. Entity states are live (mutable by operations), not frozen. Verifies that every entity's current state exists in v2's entity definition and that required transitions are declared.\n\n- Layer 3 (Operation/flow structure layer): Checks FMC1 + FMC2 (minus verdict dependencies, which are handled by Layer 1). Traverses ReachablePaths(v2, p), checking step equivalence (operation id + authorized persona) and non-verdict data dependencies (fact references in snapshot, entity state transition validity, persona authorization).\n\nCOEXISTENCE LAYER PATTERN:\n\nWhen an executor declares force-migrate policy and some flow instances fail the compatibility check, the executor MAY implement a coexistence layer (informally called v1.5):\n- New flow initiations execute under v2.\n- Incompatible in-flight flow instances continue executing under v1.\n- Compatible in-flight flow instances are force-migrated to v2.\n- When a v1-retained flow reaches a terminal state, its results are translated to v2's output format if needed.\n\nThe coexistence layer is an EXECUTOR IMPLEMENTATION STRATEGY, not a spec-level obligation. The spec defines the compatibility conditions; how the executor handles incompatible instances is an executor choice (blue-green, abort, coexistence, or other strategies). The coexistence pattern is documented because it naturally emerges from position-sensitive compatibility analysis and represents the most granular migration strategy.\n\nSCOPE NARROWINGS FROM PRESSURE TESTING:\n\n1. Reachable path computation uses v2's step graph from the current position (not v1's). The v1 step graph determines the current position; all forward analysis uses v2's definitions. This means routing changes at or after the current position are evaluated under v2's semantics.\n\n2. Flow-level compatibility refines construct-level breaking change classification. A construct-level BREAKING change (e.g., new operation outcome per Section 17.2.5) may be flow-level COMPATIBLE if v2's flow definition already handles the change. The construct-level taxonomy provides the initial signal; the flow-level check provides per-instance refinement.\n\n3. Data dependency satisfaction may optionally account for intra-path production: a v2 step's dependency may be satisfied by a verdict or entity state produced by an earlier v2 step in the same execution path. Conservative analysis considers only the frozen snapshot and current entity states. Aggressive analysis additionally considers dependencies satisfiable from v2 steps that MUST execute before the dependent step (path dominance). The conservative approach is REQUIRED; the aggressive approach is OPTIONAL and requires path dominance analysis.",
      "evaluation_def": "Given a flow instance with (flow_type, position p, entity_states, frozen_snapshot) and two contract versions v1, v2:\n\n1. LAYER 1 - VERDICT ISOLATION: No computation. Frozen snapshot is immutable by Section 11.4. PASSES.\n\n2. LAYER 2 - ENTITY STATE EQUIVALENCE: For each entity e referenced in ReachablePaths(v2, p):\n   - Check: current_state(e) is in v2.entities[e].states\n   - Check: for each v2 operation in the reachable path that affects e, the transition's target state is in v2.entities[e].states\n   - Check: a transition from current_state(e) to required target states exists in v2.entities[e].transitions\n   - If any check fails: return incompatible(layer=2, entity=e, reason)\n\n3. LAYER 3 - OPERATION/FLOW STRUCTURE: Compute ReachablePaths(v2, p) via S6. For each step s in the reachable path:\n   - Step equivalence: v2 has step s with same operation id. s.persona is in v2's operation.allowed_personas.\n   - Fact dependencies: every fact_ref in v2's operation.precondition is present in frozen_snapshot.facts OR has a declared default in v2.\n   - Persona authorization: s.persona exists in v2's persona declarations.\n   - SubFlowStep: recursively check referenced sub-flow at entry point.\n   - ParallelStep: check all branches independently; all must pass.\n   - If any check fails: return incompatible(layer=3, step=s, reason)\n\n4. All layers pass: return compatible.\n\nThe function signature is: compatible(v1_flow, v2_flow, position, entity_states, snapshot) -> Compatible | Incompatible(layer, location, reasons).",
      "satisfies": ["FMC1", "FMC2", "FMC3", "FMC4", "FMC5", "FMC6", "FMC7"],
      "acknowledged_limitations": [
        "Reachable path computation uses v2's step graph from the current position. The v1 step graph is only used to identify the current position. This means the analysis assumes the flow will follow v2's routing after migration.",
        "Flow-level compatibility is more permissive than construct-level breaking change classification. A construct-level BREAKING change may be flow-level COMPATIBLE at certain positions. This means flow-level analysis is a refinement, not a replacement, of the Section 17.2 taxonomy.",
        "Conservative data dependency analysis considers only the frozen snapshot and current entity states. It does not account for verdicts or state that v2 steps would produce during execution. This may reject migrations that are actually safe (false negatives). Aggressive analysis with path dominance is optional and reduces false negatives at the cost of implementation complexity.",
        "The coexistence layer pattern is documented as one valid executor strategy but is not prescribed. Executors may choose any strategy (blue-green, abort, coexistence, or others) for handling incompatible flow instances.",
        "Entity parent field changes are detected through Layer 2 (entity state) and Layer 3 (operation effects) but the full impact of parent change on state propagation chains may require transitive analysis not specified in v1.0.",
        "TypeDecl changes that transitively affect fact types referenced in flow step operations are captured by the data dependency check (Layer 3) but the transitive path (TypeDecl -> Fact -> precondition -> step) is not explicitly enumerated as a separate analysis."
      ]
    }
  },
  "outcome": "collapse",
  "outcome_notes": "Three candidates survived Phase 3 pressure testing with three shared scope narrowings (reachable path uses v2's graph, flow-level refines construct-level breaking changes, intra-path dependency production). In Phase 4, Candidate C (layered analysis) was identified as subsuming Candidates A and B: it incorporates A's graph-theoretic reachable path traversal within Layer 3, B's predicate decomposition across its three layers, and adds the frozen verdict isolation insight (Layer 1) that is unique to Tenor's evaluation model. The collapse produced C_merged, which defines flow migration compatibility as a three-layer analysis: Layer 1 (verdict layer -- always isolated by frozen snapshot), Layer 2 (entity state -- live state requiring explicit checking), Layer 3 (operation/flow structure -- forward path existence and non-verdict data dependencies). The canonical form defines seven invariants (FMC1-FMC7) with three as testable conditions (forward path, data dependency, entity state) and four as structural properties (directional asymmetry, position sensitivity, recursive sub-flow, semantic non-interference). Six acknowledged limitations capture scope narrowings from pressure testing. The definition is position-sensitive (per-instance, not per-type) and references S6 for path enumeration implementation."
}